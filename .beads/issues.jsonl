{"id":"google-contacts-cisco-0ly","title":"XML Directory Endpoints","description":"# Unknown\n\n\n## Overview\n\nCreate FastAPI endpoints to serve Cisco IP Phone XML directory. Implements the three-level hierarchy: main menu → group menu → individual contact.\n\n## Priority\n\n**P0 (Critical)** - Required for MVP\n\n## Dependencies\n\n- Task 4.1: XML Formatter Service\n- Task 3.1: Full Sync Implementation\n\n## Objectives\n\n1. Create main directory endpoint (`GET /directory`)\n2. Create group directory endpoint (`GET /directory/groups/\u003cgroup\u003e`)\n3. Create individual contact endpoint (`GET /directory/contacts/\u003cid\u003e`)\n4. Create help endpoint (`GET /directory/help`)\n5. Set proper XML content-type headers\n6. Handle errors gracefully with XML error responses\n7. Add request logging\n8. Test with Cisco IP Phone or simulator\n\n## Implementation Steps\n\n### 1. Create Directory Routes\n\nCreate `google_contacts_cisco/api/directory_routes.py`:\n\n```python\n\"\"\"Cisco IP Phone directory routes.\"\"\"\nfrom fastapi import APIRouter, Depends, HTTPException, Request\nfrom fastapi.responses import Response\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom uuid import UUID\n\nfrom ..models import get_db\nfrom ..models.contact import Contact\nfrom ..repositories.contact_repository import ContactRepository\nfrom ..services.xml_formatter import get_xml_formatter\nfrom ..utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\nrouter = APIRouter(prefix=\"/directory\", tags=[\"Cisco Directory\"])\n\n\ndef get_base_url(request: Request) -\u003e str:\n    \"\"\"Get base URL from request.\n    \n    Args:\n        request: FastAPI request\n        \n    Returns:\n        Base URL string\n    \"\"\"\n    return f\"{request.url.scheme}://{request.url.netloc}\"\n\n\n@router.get(\"\")\nasync def get_main_directory(\n    request: Request,\n    db: Session = Depends(get_db)\n):\n    \"\"\"Get main directory menu with group options.\n    \n    Returns XML menu for Cisco IP Phone main directory.\n    \"\"\"\n    try:\n        base_url = get_base_url(request)\n        formatter = get_xml_formatter(base_url)\n        \n        xml_content = formatter.generate_main_directory()\n        \n        logger.info(\"Generated main directory XML\")\n        \n        return Response(\n            content=xml_content,\n            media_type=\"text/xml; charset=utf-8\"\n        )\n    \n    except Exception as e:\n        logger.error(f\"Error generating main directory: {e}\")\n        return _error_response(\"Error loading directory\")\n\n\n@router.get(\"/groups/{group}\")\nasync def get_group_directory(\n    group: str,\n    request: Request,\n    db: Session = Depends(get_db)\n):\n    \"\"\"Get directory for specific group.\n    \n    Args:\n        group: Group identifier (e.g., \"2ABC\")\n        \n    Returns XML menu with contacts in the group.\n    \"\"\"\n    try:\n        base_url = get_base_url(request)\n        formatter = get_xml_formatter(base_url)\n        contact_repo = ContactRepository(db)\n        \n        # Get all active contacts\n        all_contacts = contact_repo.get_all_active()\n        \n        # Filter contacts by group\n        group_contacts = [\n            c for c in all_contacts\n            if formatter.map_contact_to_group(c) == group.upper()\n        ]\n        \n        # Sort by display name\n        group_contacts.sort(key=lambda c: c.display_name.lower())\n        \n        xml_content = formatter.generate_group_directory(group, group_contacts)\n        \n        logger.info(f\"Generated group directory for {group}: {len(group_contacts)} contacts\")\n        \n        return Response(\n            content=xml_content,\n            media_type=\"text/xml; charset=utf-8\"\n        )\n    \n    except Exception as e:\n        logger.error(f\"Error generating group directory for {group}: {e}\")\n        return _error_response(f\"Error loading group {group}\")\n\n\n@router.get(\"/contacts/{contact_id}\")\nasync def get_contact_directory(\n    contact_id: UUID,\n    request: Request,\n    db: Session = Depends(get_db)\n):\n    \"\"\"Get directory for individual contact.\n    \n    Args:\n        contact_id: Contact UUID\n        \n    Returns XML directory with contact's phone numbers.\n    \"\"\"\n    try:\n        base_url = get_base_url(request)\n        formatter = get_xml_formatter(base_url)\n        \n        # Get contact from database\n        contact = db.query(Contact).filter(Contact.id == contact_id).first()\n        \n        if not contact:\n            logger.warning(f\"Contact not found: {contact_id}\")\n            return _error_response(\"Contact not found\")\n        \n        if contact.deleted:\n            logger.warning(f\"Contact deleted: {contact_id}\")\n            return _error_response(\"Contact no longer available\")\n        \n        xml_content = formatter.generate_contact_directory(contact)\n        \n        logger.info(f\"Generated contact directory for {contact.display_name}\")\n        \n        return Response(\n            content=xml_content,\n            media_type=\"text/xml; charset=utf-8\"\n        )\n    \n    except ValueError as e:\n        logger.error(f\"Invalid contact ID: {contact_id}\")\n        return _error_response(\"Invalid contact\")\n    \n    except Exception as e:\n        logger.error(f\"Error generating contact directory for {contact_id}: {e}\")\n        return _error_response(\"Error loading contact\")\n\n\n@router.get(\"/help\")\nasync def get_help(\n    context: str = \"main\",\n    request: Request = None\n):\n    \"\"\"Get help text for directory.\n    \n    Args:\n        context: Help context (main, group/\u003cgroup\u003e, contact)\n        \n    Returns help text in Cisco XML format.\n    \"\"\"\n    try:\n        logger.info(f\"Generating help for context: {context}\")\n        \n        # Get formatter with base URL\n        base_url = get_base_url(request)\n        formatter = get_xml_formatter(base_url)\n        \n        # Generate help\n        xml = formatter.generate_help(context)\n        \n        logger.debug(f\"Help XML generated for context {context}\")\n        return Response(content=xml, media_type=\"text/xml; charset=utf-8\")\n        \n    except Exception as e:\n        logger.error(f\"Error generating help: {str(e)}\", exc_info=True)\n        return _error_response(\"Error loading help\")\n\n\ndef _error_response(message: str) -\u003e Response:\n    \"\"\"Generate error XML response.\n    \n    Args:\n        message: Error message to display\n        \n    Returns:\n        Response with error XML\n    \"\"\"\n    from lxml import etree\n    \n    root = etree.Element(\"CiscoIPPhoneText\")\n    \n    title = etree.SubElement(root, \"Title\")\n    title.text = \"Error\"\n    \n    text = etree.SubElement(root, \"Text\")\n    text.text = message\n    \n    # Add prompt\n    prompt = etree.SubElement(root, \"Prompt\")\n    prompt.text = \"Press Exit to return\"\n    \n    xml_str = etree.tostring(\n        root,\n        encoding='UTF-8',\n        xml_declaration=True\n    ).decode('utf-8')\n    \n    return Response(\n        content=xml_str,\n        media_type=\"text/xml; charset=utf-8\",\n        status_code=200  # Cisco phones expect 200 even for errors\n    )\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Test Main Directory**:\n   ```bash\n   curl http://localhost:8000/directory\n   # Should return XML menu\n   ```\n\n2. **Test Group Directory**:\n   ```bash\n   curl http://localhost:8000/directory/groups/2ABC\n   # Should return contacts starting with A, B, C\n   ```\n\n3. **Test Individual Contact**:\n   ```bash\n   # Get a contact ID from database first\n   curl http://localhost:8000/directory/contacts/\u003cuuid\u003e\n   # Should return phone numbers\n   ```\n\n4. **Test Help**:\n   ```bash\n   curl \"http://localhost:8000/directory/help?context=main\"\n   # Should return help text\n   ```\n\n4. **Test with Cisco Phone**:\n   - Configure phone to use: `http://your-server:8000/directory`\n   - Navigate through menu\n   - Verify all levels work\n\n5. **Run Tests**:\n   ```bash\n   pytest tests/test_directory_endpoints.py -v\n   ```\n\n## Notes\n\n- **Content-Type**: Must be `text/xml; charset=utf-8` for Cisco phones\n- **Error Handling**: Return XML errors, not JSON\n- **Status Codes**: Always return 200 even for errors (Cisco requirement)\n- **Base URL**: Dynamically generated from request\n- **Performance**: Query optimization for large contact lists\n- **Caching**: Consider adding caching for frequently accessed groups\n- **SoftKeys**: \n  - Menu soft keys (Main/Group directories):\n    - Position 1: Exit (return to phone's directory list)\n    - Position 2: View (select item)\n    - Position 4: Help (show help text)\n  - Contact directory soft keys:\n    - Position 1: Exit (go to home directory)\n    - Position 2: Back (go back one level)\n    - Position 3: Call (select phone number)\n- **Help Text**: Context-specific help available via Help soft key\n\n## Common Issues\n\n1. **Wrong Content-Type**: Phones show raw XML\n2. **Not HTTPS**: Some phones require SSL\n3. **Slow Response**: Add caching or pagination\n4. **Special Characters**: Ensure proper XML escaping\n5. **Empty Groups**: Display message, not empty menu\n\n## Performance Optimization\n\nFor large contact lists:\n- Add database indexes on display_name\n- Cache group mappings\n- Implement pagination if needed\n- Use SELECT with LIMIT for group queries\n\n## Related Documentation\n\n- FastAPI Responses: https://fastapi.tiangolo.com/advanced/custom-response/\n- Cisco XML Services: https://www.cisco.com/c/en/us/td/docs/voice_ip_comm/cuipph/all_models/xsi/\n\n## Estimated Time\n\n3-4 hours","acceptance_criteria":"☑ Main directory returns valid XML\n☑ Group directory filters contacts correctly\n☑ Individual contact shows all phone numbers\n☑ Content-Type is set to `text/xml; charset=utf-8`\n☑ Missing contacts return proper XML error\n☑ Invalid group returns empty or error XML\n☑ XML validates and displays on Cisco phone\n☑ Endpoints return in \u003c 100ms\n☑ Tests verify all endpoints","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":180,"created_at":"2026-01-08T03:10:59.338783386Z","created_by":"vscode","updated_at":"2026-01-08T03:26:33.684665405Z","closed_at":"2026-01-08T03:11:16.471291857Z","close_reason":"Closed","labels":["P0","api","backend","cisco-xml"]}
{"id":"google-contacts-cisco-1i0","title":"Database Setup","description":"# Unknown\n\n\n## Overview\n\nSet up SQLite database with SQLAlchemy ORM and Alembic migrations. Define the database schema for contacts, phone numbers, and sync state.\n\n## Priority\n\n**P0 (Critical)** - Required for MVP\n\n## Dependencies\n\n- Task 1.1: Environment Setup (must be completed first)\n\n## Objectives\n\n1. Configure SQLAlchemy with SQLite\n2. Define database models (Contact, PhoneNumber, SyncState)\n3. Set up Alembic for database migrations\n4. Create initial migration\n5. Test database connectivity and basic operations\n\n## Technical Context\n\n### Database: SQLite\n- File-based database: `data/contacts.db`\n- No separate server required\n- Sufficient for single-user application\n- ACID compliant\n\n## Data Model\n\n### Contact Entity\n- `id`: UUID (primary key)\n- `resource_name`: String (Google Contacts resource name)\n- `etag`: String (for conflict detection)\n- `given_name`: String (nullable)\n- `family_name`: String (nullable)\n- `display_name`: String (required, indexed)\n- `organization`: String (nullable)\n- `job_title`: String (nullable)\n- `created_at`: DateTime\n- `updated_at`: DateTime\n- `deleted`: Boolean (soft delete)\n- `synced_at`: DateTime (last sync timestamp)\n- **Relationship**: one-to-many with PhoneNumber\n\n## Implementation Steps\n\n### 1. Create Database Configuration\n\nCreate `google_contacts_cisco/config.py`:\n\n```python\n\"\"\"Application configuration.\"\"\"\nfrom pathlib import Path\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    \"\"\"Application settings.\"\"\"\n    \n    # Database\n    database_url: str = \"sqlite:///./data/contacts.db\"\n    \n    # Application\n    app_name: str = \"Google Contacts Cisco Directory\"\n    debug: bool = False\n    \n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n\n\nsettings = Settings()\n```\n\n## Verification\n\nAfter completing this task:\n1. Run `alembic upgrade head` - should complete without errors\n2. Check that `data/contacts.db` file exists\n3. Run `pytest tests/test_database.py` - all tests should pass\n4. Verify tables exist in database using SQLite browser or command line\n\n## Notes\n\n- UUID is used for primary keys for better distributed system support\n- Soft deletes are used (deleted flag) rather than hard deletes\n- Indexes are created on frequently queried fields\n- Relationships are properly defined for easy navigation\n\n## Related Documentation\n\n- SQLAlchemy 2.0: https://docs.sqlalchemy.org/en/20/\n- Alembic: https://alembic.sqlalchemy.org/\n- Pydantic Settings: https://docs.pydantic.dev/latest/concepts/pydantic_settings/\n\n## Estimated Time\n\n3-4 hours","acceptance_criteria":"☐ SQLAlchemy is configured with SQLite\n☐ Database file location is configurable\n☐ All three models are defined with proper types and relationships\n☐ Alembic is initialized and configured\n☐ Initial migration is created and applied\n☐ Database tables are created successfully\n☐ Indexes are created on display_name and phone number value\n☐ Basic CRUD operations work for all models\n☐ Tests verify database operations","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":180,"created_at":"2026-01-08T03:10:59.024373481Z","created_by":"vscode","updated_at":"2026-01-08T03:26:31.260935806Z","closed_at":"2026-01-08T03:11:16.431867347Z","close_reason":"Closed","labels":["P0","backend","database"]}
{"id":"google-contacts-cisco-1y9","title":"Incremental Sync Implementation","description":"# Unknown\n\n\n## Overview\n\nImplement incremental synchronization using sync tokens to efficiently update only changed contacts since the last sync. This reduces API calls and improves sync performance.\n\n## Priority\n\n**P1 (High)** - Should have for production\n\n## Dependencies\n\n- Task 3.1: Full Sync Implementation\n- Task 2.2: Google API Client\n\n## Objectives\n\n1. Implement incremental sync using sync tokens\n2. Handle contact updates (modified contacts)\n3. Handle contact deletions (soft delete)\n4. Handle sync token expiration (410 error)\n5. Implement fallback to full sync when needed\n6. Test incremental sync workflow\n\n## Technical Context\n\n### Incremental Sync Process\n1. Retrieve stored sync token from database\n2. Request changes since last sync using sync token\n3. Process returned contacts (updates and deletions)\n4. Update database accordingly\n5. Store new sync token\n\n## Implementation Steps\n\n### 1. Update Sync Service with Incremental Sync\n\nUpdate `google_contacts_cisco/services/sync_service.py`:\n\n```python\n# Add this method to SyncService class\n\ndef incremental_sync(self, batch_size: int = 100) -\u003e dict:\n    \"\"\"Perform incremental sync using sync token.\n    \n    Args:\n        batch_size: Number of contacts to commit per batch\n        \n    Returns:\n        Sync statistics\n    \"\"\"\n    logger.info(\"Starting incremental sync\")\n    \n    # Get latest sync state\n    sync_state = self.sync_repo.get_latest_sync_state()\n    \n    if not sync_state or not sync_state.sync_token:\n        logger.warning(\"No sync token available, performing full sync instead\")\n        return self.full_sync(batch_size)\n    \n    sync_token = sync_state.sync_token\n    logger.info(f\"Using sync token: {sync_token[:20]}...\")\n    \n    # Create new sync state\n    new_sync_state = self.sync_repo.create_sync_state(status=\"syncing\")\n    self.db.commit()\n    \n    stats = {\n        \"total_fetched\": 0,\n        \"updated\": 0,\n        \"deleted\": 0,\n        \"errors\": 0,\n        \"pages\": 0\n    }\n    \n    try:\n        # Fetch changes from Google\n        for response_data in self.google_client.list_connections(\n            page_size=100,\n            sync_token=sync_token\n        ):\n            stats[\"pages\"] += 1\n            \n            # Parse response\n            response = GoogleConnectionsResponse(**response_data)\n            \n            if not response.connections:\n                logger.info(f\"Page {stats['pages']}: No changes\")\n                continue\n            \n            logger.info(f\"Page {stats['pages']}: Processing {len(response.connections)} changes\")\n            \n            # Process each contact\n            for person in response.connections:\n                try:\n                    stats[\"total_fetched\"] += 1\n                    \n                    if person.is_deleted():\n                        # Handle deleted contact\n                        self._handle_deleted_contact(person.resource_name)\n                        stats[\"deleted\"] += 1\n                    else:\n                        # Handle updated contact\n                        from ..services.contact_transformer import transform_google_person_to_contact\n                        contact_data = transform_google_person_to_contact(person)\n                        self.contact_repo.upsert_contact(contact_data)\n                        stats[\"updated\"] += 1\n                    \n                    # Commit in batches\n                    if stats[\"total_fetched\"] % batch_size == 0:\n                        self.db.commit()\n                        logger.info(f\"Committed batch: {stats['total_fetched']} changes processed\")\n                \n                except Exception as e:\n                    logger.error(f\"Error processing contact {person.resource_name}: {e}\")\n                    stats[\"errors\"] += 1\n                    continue\n            \n            # Commit remaining changes in page\n            self.db.commit()\n            \n            # Store new sync token if this is the last page\n            if not response.next_page_token and response.next_sync_token:\n                self.sync_repo.update_sync_state(\n                    new_sync_state,\n                    sync_token=response.next_sync_token\n                )\n                self.db.commit()\n                logger.info(f\"Stored new sync token: {response.next_sync_token[:20]}...\")\n            \n            # Small delay between pages\n            time.sleep(0.1)\n        \n        # Mark sync as complete\n        self.sync_repo.update_sync_state(new_sync_state, status=\"idle\")\n        self.db.commit()\n        \n        logger.info(f\"Incremental sync completed: {stats}\")\n        return stats\n    \n    except HttpError as e:\n        if e.resp.status == 410:\n            # Sync token expired, perform full sync\n            logger.warning(\"Sync token expired (410), falling back to full sync\")\n            self.sync_repo.update_sync_state(\n                new_sync_state,\n                status=\"error\",\n                error_message=\"Sync token expired, performing full sync\"\n            )\n            self.db.commit()\n            return self.full_sync(batch_size)\n        else:\n            logger.error(f\"Incremental sync failed: {e}\")\n            self.sync_repo.update_sync_state(\n                new_sync_state,\n                status=\"error\",\n                error_message=str(e)\n            )\n            self.db.commit()\n            raise\n    \n    except Exception as e:\n        logger.error(f\"Incremental sync failed: {e}\")\n        self.sync_repo.update_sync_state(\n            new_sync_state,\n            status=\"error\",\n            error_message=str(e)\n        )\n        self.db.commit()\n        raise\n\ndef _handle_deleted_contact(self, resource_name: str):\n    \"\"\"Handle deleted contact by soft-deleting it.\n    \n    Args:\n        resource_name: Resource name of deleted contact\n    \"\"\"\n    contact = self.contact_repo.get_by_resource_name(resource_name)\n    if contact:\n        contact.deleted = True\n        contact.synced_at = datetime.utcnow()\n        logger.info(f\"Marked contact as deleted: {resource_name}\")\n    else:\n        logger.warning(f\"Deleted contact not found in database: {resource_name}\")\n\ndef auto_sync(self, batch_size: int = 100) -\u003e dict:\n    \"\"\"Automatically choose between full and incremental sync.\n    \n    Args:\n        batch_size: Number of contacts to commit per batch\n        \n    Returns:\n        Sync statistics\n    \"\"\"\n    sync_state = self.sync_repo.get_latest_sync_state()\n    \n    if sync_state and sync_state.sync_token:\n        logger.info(\"Sync token available, performing incremental sync\")\n        return self.incremental_sync(batch_size)\n    else:\n        logger.info(\"No sync token available, performing full sync\")\n        return self.full_sync(batch_size)\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Test Incremental Sync**:\n   ```bash\n   # First do a full sync\n   curl -X POST http://localhost:8000/api/sync/full\n   \n   # Update a contact in Google Contacts\n   \n   # Then do incremental sync\n   curl -X POST http://localhost:8000/api/sync/incremental\n   \n   # Should only sync changed contacts\n   ```\n\n2. **Test Auto Sync**:\n   ```bash\n   curl -X POST http://localhost:8000/api/sync\n   # Automatically chooses full or incremental\n   ```\n\n3. **Verify Sync Token**:\n   ```bash\n   sqlite3 data/contacts.db\n   SELECT sync_token FROM sync_states ORDER BY last_sync_at DESC LIMIT 1;\n   ```\n\n4. **Run Tests**:\n   ```bash\n   pytest tests/test_incremental_sync.py -v\n   ```\n\n## Notes\n\n- **Efficiency**: Incremental sync only processes changes, much faster than full sync\n- **Soft Delete**: Deleted contacts are marked, not physically deleted\n- **Token Expiration**: 410 error triggers automatic fallback to full sync\n- **Propagation Delay**: Google changes may take several minutes to appear in sync\n- **Auto Sync**: Recommended endpoint - automatically chooses best sync method\n\n## Common Issues\n\n1. **410 Sync Token Expired**: Normal after long periods, just triggers full sync\n2. **Missing Deleted Contacts**: Contact never synced, can't be deleted\n3. **Slow Incremental Sync**: May have many changes, consider full sync\n4. **Propagation Delay**: Changes may not appear immediately (several minutes)\n\n## Performance Comparison\n\n- **Full Sync**: O(n) where n is total contacts\n- **Incremental Sync**: O(m) where m is changed contacts\n- For 10,000 contacts with 10 changes: ~1000x faster\n\n## Related Documentation\n\n- Google Sync Tokens: https://developers.google.com/people/v1/contacts#sync\n- Incremental Sync Guide: https://developers.google.com/people/v1/how-tos/sync\n\n## Estimated Time\n\n3-4 hours","acceptance_criteria":"☑ Incremental sync uses stored sync token\n☑ Updated contacts are updated in database\n☑ Deleted contacts are soft-deleted (marked as deleted)\n☑ Sync token expiration triggers full sync\n☑ New sync token is stored after successful sync\n☑ Incremental sync is faster than full sync\n☑ No sync token triggers full sync\n☑ Tests verify incremental sync logic","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":1,"issue_type":"task","estimated_minutes":180,"created_at":"2026-01-08T03:10:59.237521748Z","created_by":"vscode","updated_at":"2026-01-08T03:26:32.870781026Z","closed_at":"2026-01-08T03:11:16.46356984Z","close_reason":"Closed","labels":["P1","backend","sync"]}
{"id":"google-contacts-cisco-24i","title":"Test Infrastructure \u0026 Coverage Verification","description":"# Unknown\n\n\n## Overview\n\nSet up comprehensive testing infrastructure, establish testing standards, verify overall test coverage across the codebase, and ensure all components have been properly tested according to the test plan. This task focuses on test infrastructure and verification, NOT writing individual unit tests (those should be written alongside each implementation task).\n\n## Priority\n\n**P1 (High)** - Required for production readiness\n\n## Dependencies\n\n- All implementation tasks (1-19) - Each should include their own tests\n- Task 1.1: Environment Setup\n\n## Objectives\n\n1. Set up pytest configuration and standards\n2. Create shared test fixtures and utilities\n3. Configure coverage reporting and thresholds\n4. Verify test coverage across all modules (\u003e80% target)\n5. Identify and document coverage gaps\n6. Set up CI/CD test integration\n7. Create test execution scripts\n8. Document testing patterns and best practices\n9. Verify test quality (not just quantity)\n10. Create test coverage dashboard\n\n## Technical Context\n\n### What This Task IS About\n- ✅ Setting up pytest configuration\n- ✅ Creating shared test fixtures (conftest.py)\n- ✅ Configuring coverage tools and reports\n- ✅ Verifying overall test coverage\n- ✅ Identifying gaps in test coverage\n- ✅ Documenting testing standards\n- ✅ Setting up CI/CD test integration\n\n## Implementation Steps\n\n### 1. Set Up pytest Configuration\n\nCreate `pyproject.toml` additions:\n\n```toml\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\npython_files = [\"test_*.py\"]\npython_classes = [\"Test*\"]\npython_functions = [\"test_*\"]\naddopts = [\n    \"-v\",\n    \"--strict-markers\",\n    \"--cov=google_contacts_cisco\",\n    \"--cov-report=term-missing\",\n    \"--cov-report=html\",\n    \"--cov-report=xml\",\n    \"--cov-fail-under=80\",\n]\nmarkers = [\n    \"unit: Unit tests\",\n    \"integration: Integration tests\",\n    \"e2e: End-to-end tests\",\n    \"slow: Slow running tests\",\n]\n\n[tool.coverage.run]\nsource = [\"google_contacts_cisco\"]\nomit = [\n    \"*/tests/*\",\n    \"*/conftest.py\",\n    \"*/__init__.py\",\n    \"*/main.py\",\n]\n\n[tool.coverage.report]\nexclude_lines = [\n    \"pragma: no cover\",\n    \"def __repr__\",\n    \"raise AssertionError\",\n    \"raise NotImplementedError\",\n    \"if __name__ == .__main__.:\",\n    \"if TYPE_CHECKING:\",\n    \"@abstractmethod\",\n]\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Verify pytest Configuration**:\n   ```bash\n   uv run pytest --collect-only\n   ```\n\n2. **Run All Tests**:\n   ```bash\n   ./scripts/test.sh\n   ```\n\n3. **Check Coverage**:\n   ```bash\n   python scripts/verify-coverage.py\n   ```\n\n4. **Generate Coverage Report**:\n   ```bash\n   ./scripts/coverage-report.sh\n   ```\n\n5. **Verify Coverage Thresholds**:\n   ```bash\n   uv run pytest --cov=google_contacts_cisco --cov-fail-under=80\n   ```\n\n6. **Check Test Quality**:\n   - Review tests for each module\n   - Ensure edge cases are covered\n   - Verify error paths are tested\n   - Check that mocks are used appropriately\n\n7. **Identify Coverage Gaps**:\n   ```bash\n   uv run pytest --cov=google_contacts_cisco --cov-report=term-missing\n   # Look for lines marked with \"!\" in the output\n   ```\n\n## Notes\n\n- **Not About Writing Tests**: This task sets up infrastructure and verifies coverage\n- **Tests Per Task**: Each implementation task (1-19) should include its own tests\n- **Quality Over Quantity**: 80% coverage with good tests \u003e 100% coverage with poor tests\n- **Critical Paths**: Focus extra effort on testing critical functionality\n- **Fast Execution**: All unit tests should run in \u003c30 seconds total\n- **CI/CD Ready**: Configuration should work in CI/CD pipelines\n\n## Common Issues\n\n1. **Low Coverage**: Review tasks 1-19, ensure tests were written for each\n2. **Slow Tests**: Check for unnecessary database operations or API calls\n3. **Flaky Tests**: Remove time-dependent assertions, ensure proper isolation\n4. **Import Errors**: Verify PYTHONPATH and package structure\n5. **Coverage Reporting Fails**: Ensure coverage.xml is generated correctly\n\n## Best Practices\n\n1. **One Test, One Concept**: Each test should verify one thing\n2. **Arrange-Act-Assert**: Structure tests clearly\n3. **Descriptive Names**: Test names should explain what is tested\n4. **Independent Tests**: Tests should not depend on each other\n5. **Fast Tests**: Unit tests should run in milliseconds\n6. **Use Fixtures**: Reuse test data via fixtures\n7. **Mock External Dependencies**: Don't call real APIs in unit tests\n\n## Related Documentation\n\n- pytest: https://docs.pytest.org/\n- pytest-cov: https://pytest-cov.readthedocs.io/\n- Coverage.py: https://coverage.readthedocs.io/\n- Testing Best Practices: https://docs.python-guide.org/writing/tests/\n\n## Estimated Time\n\n4-6 hours (infrastructure setup and verification only)\n\n**Note**: Time for writing individual unit tests is included in each implementation task (1-19).","acceptance_criteria":"☐ pytest configuration established with proper settings\n☐ Shared test fixtures created (conftest.py)\n☐ Coverage reporting configured (terminal, HTML, XML)\n☐ All modules have \u003e80% test coverage\n☐ Critical paths have \u003e95% coverage\n☐ Coverage gaps are identified and documented\n☐ Test execution scripts created\n☐ CI/CD integration configured\n☐ Testing best practices documented\n☐ Test quality verified (not just quantity)\n☐ Coverage reports generated and accessible","notes":"- **Not About Writing Tests**: This task sets up infrastructure and verifies coverage\n- **Tests Per Task**: Each implementation task (1-19) should include its own tests\n- **Quality Over Quantity**: 80% coverage with good tests \u003e 100% coverage with poor tests\n- **Critical Paths**: Focus extra effort on testing critical functionality\n- **Fast Execution**: All unit tests should run in \u003c30 seconds total\n- **CI/CD Ready**: Configuration should work in CI/CD pipelines\n\n\n**Related Files:**\n\n- See `.ai/planning/tasks/` for complete implementation guide\n\n- Includes code examples, test suites, and verification steps","status":"open","priority":1,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.512832163Z","created_by":"vscode","updated_at":"2026-01-08T03:26:35.773613853Z","labels":["P1","infrastructure","testing"]}
{"id":"google-contacts-cisco-2ox","title":"OAuth 2.0 Implementation","description":"# Unknown\n\n\n## Overview\n\nImplement OAuth 2.0 authentication flow with Google to enable access to the user's Google Contacts. This includes handling authorization, token storage, and automatic token refresh.\n\n## Priority\n\n**P0 (Critical)** - Required for MVP\n\n## Dependencies\n\n- Task 1.1: Environment Setup\n- Task 1.3: Configuration Management\n\n## Objectives\n\n1. Implement OAuth 2.0 authorization flow with Google\n2. Handle OAuth callback and token exchange\n3. Store OAuth tokens securely in file system\n4. Implement automatic token refresh\n5. Handle token expiration gracefully\n6. Create web interface for OAuth setup\n\n## Technical Context\n\n### OAuth 2.0 Flow\n1. **Authorization Request**: Redirect user to Google's consent screen\n2. **Authorization Grant**: User approves access, Google redirects back with authorization code\n3. **Token Exchange**: Exchange authorization code for access token and refresh token\n4. **Token Storage**: Save tokens to file system\n5. **Token Usage**: Use access token to make API requests\n6. **Token Refresh**: Automatically refresh expired access tokens using refresh token\n\n## Implementation Steps\n\n### 1. Create OAuth Configuration\n\nUpdate `google_contacts_cisco/auth/__init__.py`:\n\n```python\n\"\"\"Authentication module.\"\"\"\nfrom .oauth import (\n    get_oauth_client,\n    get_credentials,\n    is_authenticated,\n    revoke_credentials,\n)\n\n__all__ = [\n    \"get_oauth_client\",\n    \"get_credentials\",\n    \"is_authenticated\",\n    \"revoke_credentials\",\n]\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Manual Testing**:\n   ```bash\n   # Start the application\n   uvicorn google_contacts_cisco.main:app --reload\n   \n   # Visit http://localhost:8000/auth/google\n   # - Should redirect to Google consent screen\n   # - Grant access\n   # - Should redirect back with success message\n   \n   # Check auth status\n   curl http://localhost:8000/auth/status\n   # Should return {\"authenticated\": true}\n   \n   # Check token file\n   ls -la data/token.json\n   # File should exist with 600 permissions\n   ```\n\n2. **Automated Tests**:\n   ```bash\n   pytest tests/test_oauth.py tests/test_oauth_api.py -v\n   ```\n\n3. **Token File Format**:\n   ```bash\n   cat data/token.json\n   # Should contain valid JSON with token, refresh_token, etc.\n   ```\n\n## Notes\n\n- **Refresh Token**: Google only provides refresh token on first authorization with `prompt=consent`\n- **Token Expiration**: Access tokens expire after 1 hour, refresh tokens are long-lived\n- **File Permissions**: Token file has 600 permissions (owner read/write only)\n- **Offline Access**: Using `access_type='offline'` to get refresh token\n- **Scope Changes**: If scopes change, user must re-authorize\n- **Error Handling**: Clear error messages guide users when OAuth fails\n\n## Security Best Practices\n\n1. Never log or expose tokens\n2. Store tokens with restricted file permissions (600)\n3. Validate redirect URI matches configuration\n4. Use HTTPS in production\n5. Handle token refresh before they expire\n6. Revoke tokens when no longer needed\n\n## Related Documentation\n\n- Google OAuth 2.0: https://developers.google.com/identity/protocols/oauth2\n- Google Python Auth Library: https://google-auth.readthedocs.io/\n- OAuth 2.0 RFC: https://tools.ietf.org/html/rfc6749\n- FastAPI OAuth: https://fastapi.tiangolo.com/advanced/security/\n\n## Estimated Time\n\n4-6 hours","acceptance_criteria":"☐ OAuth authorization flow redirects to Google correctly\n☐ Authorization callback handles the auth code properly\n☐ Tokens are exchanged successfully\n☐ Tokens are stored in file system with proper permissions\n☐ Token file is loaded on subsequent requests\n☐ Expired access tokens are refreshed automatically\n☐ Refresh token failures trigger re-authorization\n☐ Web page shows OAuth connection status\n☐ OAuth errors are handled gracefully with clear messages","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.105738785Z","created_by":"vscode","updated_at":"2026-01-08T03:26:31.785559819Z","closed_at":"2026-01-08T03:11:16.451329998Z","close_reason":"Closed","labels":["P0","auth","backend"]}
{"id":"google-contacts-cisco-31x","title":"End-to-End Tests","description":"# Unknown\n\n\n## Overview\n\nCreate end-to-end tests using Playwright to simulate real user workflows from the browser, testing the complete application stack including the Vue frontend, FastAPI backend, and database.\n\n## Priority\n\n**P2 (Medium)** - Important but not blocking for MVP\n\n## Dependencies\n\n- Task 7.2: Integration Tests\n- Task 6: Web Frontend (all tasks 15-19)\n\n## Objectives\n\n1. Set up Playwright for browser automation\n2. Test complete user workflows\n3. Test OAuth setup process\n4. Test contact browsing and filtering\n5. Test search functionality\n6. Test sync management\n7. Test on multiple browsers (Chromium, Firefox, WebKit)\n8. Create reusable page objects\n9. Generate test reports with screenshots\n\n## Technical Context\n\n### Playwright Features\n- Cross-browser testing (Chromium, Firefox, WebKit)\n- Auto-wait for elements\n- Screenshot and video recording\n- Network interception\n- Mobile device emulation\n\n## Implementation Steps\n\n### 1. Install Playwright\n\nUpdate `pyproject.toml`:\n\n```toml\n[project.optional-dependencies]\ndev = [\n    \"pytest\u003e=7.4.0\",\n    \"pytest-cov\u003e=4.1.0\",\n    \"pytest-asyncio\u003e=0.21.0\",\n    \"pytest-mock\u003e=3.12.0\",\n    \"playwright\u003e=1.40.0\",\n    \"pytest-playwright\u003e=0.4.3\",\n]\n```\n\nInstall and set up:\n\n```bash\nuv pip install playwright pytest-playwright\nuv run playwright install\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Install Playwright**:\n   ```bash\n   uv pip install playwright pytest-playwright\n   uv run playwright install\n   ```\n\n2. **Start Application**:\n   ```bash\n   # Terminal 1: Backend\n   uv run python -m google_contacts_cisco.main\n   \n   # Terminal 2: Frontend\n   cd frontend \u0026\u0026 npm run dev\n   ```\n\n3. **Run E2E Tests**:\n   ```bash\n   uv run pytest tests/e2e -v --headed\n   # Use --headed to see browser\n   ```\n\n4. **Run on Specific Browser**:\n   ```bash\n   uv run pytest tests/e2e --browser chromium\n   uv run pytest tests/e2e --browser firefox\n   uv run pytest tests/e2e --browser webkit\n   ```\n\n5. **Generate Test Report**:\n   ```bash\n   uv run pytest tests/e2e --html=test-results/report.html --self-contained-html\n   ```\n\n6. **Debug Mode**:\n   ```bash\n   PWDEBUG=1 uv run pytest tests/e2e -v\n   # Opens Playwright Inspector\n   ```\n\n## Notes\n\n- **Page Objects**: Reusable page abstractions\n- **Auto-wait**: Playwright waits automatically for elements\n- **Screenshots**: Captured on test failures\n- **Videos**: Recorded for failed tests\n- **Multi-browser**: Tests run on Chromium, Firefox, WebKit\n- **Headless**: Run without visible browser for CI/CD\n- **Debugging**: Use PWDEBUG=1 for step-through debugging\n\n## Common Issues\n\n1. **Timeouts**: Increase timeout for slow operations\n2. **Element Not Found**: Wait for element before interacting\n3. **Flaky Tests**: Add proper waits, avoid hardcoded sleeps\n4. **Browser Not Installed**: Run `playwright install`\n5. **Port Conflicts**: Ensure app is running on correct port\n\n## Best Practices\n\n- Use page objects for maintainability\n- Test user workflows, not implementation\n- Use descriptive test names\n- Take screenshots on failures\n- Avoid hardcoded waits\n- Test on multiple browsers\n- Use semantic selectors (data-testid)\n- Clean up after tests\n\n## Related Documentation\n\n- Playwright Python: https://playwright.dev/python/\n- pytest-playwright: https://github.com/microsoft/playwright-pytest\n- Page Object Pattern: https://playwright.dev/python/docs/pom\n\n## Estimated Time\n\n6-8 hours","acceptance_criteria":"☐ Playwright is configured and working\n☐ User workflows are tested end-to-end\n☐ OAuth flow is tested (with mocks)\n☐ Contact browsing works in browser\n☐ Search functionality works in browser\n☐ Sync management UI is tested\n☐ Tests run on multiple browsers\n☐ Screenshots captured on failures\n☐ Test reports generated\n☐ Tests are maintainable with page objects","notes":"- **Page Objects**: Reusable page abstractions\n- **Auto-wait**: Playwright waits automatically for elements\n- **Screenshots**: Captured on test failures\n- **Videos**: Recorded for failed tests\n- **Multi-browser**: Tests run on Chromium, Firefox, WebKit\n- **Headless**: Run without visible browser for CI/CD\n- **Debugging**: Use PWDEBUG=1 for step-through debugging\n\n\n**Related Files:**\n\n- See `.ai/planning/tasks/` for complete implementation guide\n\n- Includes code examples, test suites, and verification steps","status":"open","priority":2,"issue_type":"task","estimated_minutes":360,"created_at":"2026-01-08T03:10:59.551874113Z","created_by":"vscode","updated_at":"2026-01-08T03:26:36.157453832Z","labels":["P2","e2e","testing"]}
{"id":"google-contacts-cisco-44p","title":"Google API Client","description":"# Unknown\n\n\n## Overview\n\nCreate a wrapper around the Google People API client to handle contact retrieval, pagination, error handling, and rate limiting. This client will be used by the sync service to fetch contacts from Google.\n\n## Priority\n\n**P0 (Critical)** - Required for MVP\n\n## Dependencies\n\n- Task 2.1: OAuth 2.0 Implementation\n- Task 1.2: Database Setup (for testing)\n\n## Objectives\n\n1. Create Google People API client wrapper\n2. Implement contact list retrieval with pagination\n3. Implement error handling with retries and exponential backoff\n4. Implement rate limit handling\n5. Follow Google API best practices (sequential requests)\n6. Create connection testing functionality\n\n## Technical Context\n\n### Google People API v1\n- **Base URL**: `https://people.googleapis.com/v1`\n- **Endpoint**: `/people/me/connections`\n- **Person Fields**: names, emailAddresses, phoneNumbers, organizations, metadata\n- **Page Size**: Up to 1000 contacts per page (recommended: 100-500)\n- **Pagination**: Use `pageToken` from response\n- **Sync Token**: For incremental updates\n\n## Implementation Steps\n\n### 1. Create Google API Client Service\n\nCreate `google_contacts_cisco/services/google_client.py`:\n\n```python\n\"\"\"Google People API client.\"\"\"\nimport time\nfrom typing import Iterator, Optional, List, Dict, Any\n\nfrom googleapiclient.discovery import build\nfrom googleapiclient.errors import HttpError\nfrom google.oauth2.credentials import Credentials\n\nfrom ..auth.oauth import get_credentials\nfrom ..utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\n\n# Person fields to retrieve from Google Contacts\nPERSON_FIELDS = [\n    \"names\",\n    \"emailAddresses\",\n    \"phoneNumbers\",\n    \"organizations\",\n    \"metadata\",\n]\n\n\nclass GoogleContactsClient:\n    \"\"\"Client for Google People API.\"\"\"\n    \n    def __init__(self, credentials: Optional[Credentials] = None):\n        \"\"\"Initialize Google Contacts client.\n        \n        Args:\n            credentials: OAuth credentials (if None, loads from storage)\n        \"\"\"\n        self.credentials = credentials or get_credentials()\n        if not self.credentials:\n            raise ValueError(\"No valid credentials available. Please authenticate first.\")\n        \n        self.service = build('people', 'v1', credentials=self.credentials)\n        self.max_retries = 5\n        self.initial_backoff = 1.0  # seconds\n    \n    def list_connections(\n        self,\n        page_size: int = 100,\n        sync_token: Optional[str] = None,\n    ) -\u003e Iterator[Dict[str, Any]]:\n        \"\"\"List all connections with pagination.\n        \n        Args:\n            page_size: Number of contacts per page (max 1000)\n            sync_token: Token for incremental sync (if available)\n            \n        Yields:\n            Dictionary containing 'connections' list and 'syncToken'\n            \n        Raises:\n            HttpError: If API request fails after retries\n        \"\"\"\n        page_token = None\n        request_count = 0\n        \n        while True:\n            try:\n                # Build request\n                request_params = {\n                    'resourceName': 'people/me',\n                    'pageSize': page_size,\n                    'personFields': ','.join(PERSON_FIELDS),\n                }\n                \n                if sync_token:\n                    request_params['syncToken'] = sync_token\n                    request_params['requestSyncToken'] = True\n                else:\n                    request_params['requestSyncToken'] = True\n                \n                if page_token:\n                    request_params['pageToken'] = page_token\n                \n                # Make request with retry logic\n                response = self._make_request_with_retry(\n                    lambda: self.service.people().connections().list(**request_params).execute()\n                )\n                \n                request_count += 1\n                logger.info(f\"Retrieved page {request_count} ({len(response.get('connections', []))} contacts)\")\n                \n                yield response\n                \n                # Check if there are more pages\n                page_token = response.get('nextPageToken')\n                if not page_token:\n                    break\n                \n                # Small delay between requests (sequential, as recommended by Google)\n                time.sleep(0.1)\n                \n            except HttpError as e:\n                if e.resp.status == 410:\n                    # Sync token expired\n                    logger.warning(\"Sync token expired, need to do full sync\")\n                    raise\n                else:\n                    logger.error(f\"Error listing connections: {e}\")\n                    raise\n    \n    def get_person(self, resource_name: str) -\u003e Dict[str, Any]:\n        \"\"\"Get a single person by resource name.\n        \n        Args:\n            resource_name: Person's resource name (e.g., 'people/12345')\n            \n        Returns:\n            Person data dictionary\n            \n        Raises:\n            HttpError: If API request fails\n        \"\"\"\n        try:\n            person = self._make_request_with_retry(\n                lambda: self.service.people().get(\n                    resourceName=resource_name,\n                    personFields=','.join(PERSON_FIELDS)\n                ).execute()\n            )\n            return person\n        except HttpError as e:\n            logger.error(f\"Error getting person {resource_name}: {e}\")\n            raise\n    \n    def test_connection(self) -\u003e bool:\n        \"\"\"Test connection to Google People API.\n        \n        Returns:\n            True if connection successful\n            \n        Raises:\n            Exception: If connection fails\n        \"\"\"\n        try:\n            # Try to get just one contact\n            result = self.service.people().connections().list(\n                resourceName='people/me',\n                pageSize=1,\n                personFields='names'\n            ).execute()\n            \n            logger.info(\"Successfully connected to Google People API\")\n            return True\n        except HttpError as e:\n            logger.error(f\"Connection test failed: {e}\")\n            raise\n    \n    def _make_request_with_retry(self, request_func, retry_count: int = 0):\n        \"\"\"Make API request with retry logic.\n        \n        Args:\n            request_func: Function that makes the API request\n            retry_count: Current retry attempt\n            \n        Returns:\n            API response\n            \n        Raises:\n            HttpError: If request fails after all retries\n        \"\"\"\n        try:\n            return request_func()\n        except HttpError as e:\n            if e.resp.status == 429:  # Rate limit\n                if retry_count \u003c self.max_retries:\n                    backoff = self.initial_backoff * (2 ** retry_count)\n                    logger.warning(f\"Rate limit hit, backing off for {backoff} seconds\")\n                    time.sleep(backoff)\n                    return self._make_request_with_retry(request_func, retry_count + 1)\n                else:\n                    logger.error(\"Max retries exceeded for rate limit\")\n                    raise\n            elif e.resp.status \u003e= 500:  # Server error\n                if retry_count \u003c self.max_retries:\n                    backoff = self.initial_backoff * (2 ** retry_count)\n                    logger.warning(f\"Server error {e.resp.status}, retrying in {backoff} seconds\")\n                    time.sleep(backoff)\n                    return self._make_request_with_retry(request_func, retry_count + 1)\n                else:\n                    logger.error(\"Max retries exceeded for server error\")\n                    raise\n            elif e.resp.status == 401:  # Unauthorized\n                logger.error(\"Unauthorized - credentials may have expired\")\n                raise\n            else:\n                # Other errors, don't retry\n                raise\n\n\ndef get_google_client(credentials: Optional[Credentials] = None) -\u003e GoogleContactsClient:\n    \"\"\"Get Google Contacts client instance.\n    \n    Args:\n        credentials: OAuth credentials (if None, loads from storage)\n        \n    Returns:\n        GoogleContactsClient instance\n    \"\"\"\n    return GoogleContactsClient(credentials)\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Test Connection**:\n   ```bash\n   # Start app\n   uvicorn google_contacts_cisco.main:app --reload\n   \n   # Authenticate first\n   curl http://localhost:8000/auth/google\n   \n   # Test connection\n   curl http://localhost:8000/api/test-connection\n   # Should return success\n   ```\n\n2. **Run Tests**:\n   ```bash\n   pytest tests/test_google_client.py -v\n   ```\n\n3. **Manual API Test** (with Python):\n   ```python\n   from google_contacts_cisco.services.google_client import get_google_client\n   \n   client = get_google_client()\n   \n   # Test connection\n   client.test_connection()\n   \n   # Get first page of contacts\n   for response in client.list_connections(page_size=10):\n       print(f\"Got {len(response['connections'])} contacts\")\n       break\n   ```\n\n## Notes\n\n- **Sequential Requests**: Google recommends sequential (not parallel) requests to avoid rate limits\n- **Pagination**: Use `nextPageToken` to get subsequent pages\n- **Sync Token**: Store and use for incremental updates (Task 3.2)\n- **Person Fields**: Only request fields you need to reduce response size\n- **Rate Limits**: Implement exponential backoff for 429 errors\n- **Error Logging**: Log all errors with context for debugging\n\n## Common Issues\n\n1. **401 Unauthorized**: Credentials expired, need to re-authenticate\n2. **429 Rate Limit**: Sending requests too fast, increase delays\n3. **410 Sync Token Expired**: Need to do full sync, can't use incremental\n4. **500 Server Errors**: Google's temporary issue, retry with backoff\n\n## Related Documentation\n\n- Google People API: https://developers.google.com/people\n- People API Reference: https://developers.google.com/people/api/rest/v1/people.connections/list\n- API Quotas: https://developers.google.com/people/v1/how-tos/quota\n- Error Handling: https://developers.google.com/people/v1/how-tos/errors\n\n## Estimated Time\n\n4-5 hours","acceptance_criteria":"☑ Client successfully connects to Google People API\n☑ Client retrieves person fields correctly\n☑ Pagination handles multiple pages of contacts\n☑ Pagination stops when no more pages exist\n☑ Rate limit errors (429) trigger exponential backoff\n☑ Server errors (500+) trigger retries\n☑ Auth errors (401) are handled properly\n☑ Client respects Google's sequential request recommendation\n☑ Connection can be tested without syncing data\n☑ All API errors are logged with context","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.138691068Z","created_by":"vscode","updated_at":"2026-01-08T03:26:32.059669684Z","closed_at":"2026-01-08T03:11:16.453601425Z","close_reason":"Closed","labels":["P0","backend","google-api"]}
{"id":"google-contacts-cisco-456","title":"Full Sync Implementation","description":"# Unknown\n\n\n## Overview\n\nImplement the initial full synchronization of contacts from Google to the local database. This includes downloading all contacts, parsing them, and storing them in the database with proper error handling.\n\n## Priority\n\n**P0 (Critical)** - Required for MVP\n\n## Dependencies\n\n- Task 2.2: Google API Client\n- Task 2.3: Contact Data Models\n- Task 1.2: Database Setup\n\n## Objectives\n\n1. Implement full contact download from Google\n2. Handle pagination for large contact lists\n3. Parse and transform contact data\n4. Store contacts in database\n5. Store sync token for future incremental syncs\n6. Handle errors gracefully\n7. Track sync progress and status\n8. Test with real Google account\n\n## Technical Context\n\n### Full Sync Process\n1. Request all contacts from Google People API\n2. Iterate through pages (pagination)\n3. Transform each contact from Google format to internal format\n4. Insert/update contacts in database\n5. Store sync token from last page\n6. Mark sync as complete\n\n## Implementation Steps\n\n### 1. Create Contact Repository\n\nCreate `google_contacts_cisco/repositories/contact_repository.py`:\n\n```python\n\"\"\"Contact repository for database operations.\"\"\"\nfrom typing import List, Optional\nfrom datetime import datetime\nfrom uuid import UUID\n\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import or_\n\nfrom ..models.contact import Contact\nfrom ..models.phone_number import PhoneNumber\nfrom ..schemas.contact import ContactCreateSchema, PhoneNumberSchema\n\n\nclass ContactRepository:\n    \"\"\"Repository for contact database operations.\"\"\"\n    \n    def __init__(self, db: Session):\n        \"\"\"Initialize repository.\n        \n        Args:\n            db: Database session\n        \"\"\"\n        self.db = db\n    \n    def create_contact(self, contact_data: ContactCreateSchema) -\u003e Contact:\n        \"\"\"Create a new contact.\n        \n        Args:\n            contact_data: Contact data to create\n            \n        Returns:\n            Created contact\n        \"\"\"\n        # Create contact\n        contact = Contact(\n            resource_name=contact_data.resource_name,\n            etag=contact_data.etag,\n            given_name=contact_data.given_name,\n            family_name=contact_data.family_name,\n            display_name=contact_data.display_name,\n            organization=contact_data.organization,\n            job_title=contact_data.job_title,\n            deleted=contact_data.deleted,\n            synced_at=datetime.utcnow()\n        )\n        \n        self.db.add(contact)\n        self.db.flush()  # Get contact ID\n        \n        # Add phone numbers\n        for phone_data in contact_data.phone_numbers:\n            phone = PhoneNumber(\n                contact_id=contact.id,\n                value=phone_data.value,\n                display_value=phone_data.display_value,\n                type=phone_data.type,\n                primary=phone_data.primary\n            )\n            self.db.add(phone)\n        \n        return contact\n    \n    def get_by_resource_name(self, resource_name: str) -\u003e Optional[Contact]:\n        \"\"\"Get contact by Google resource name.\n        \n        Args:\n            resource_name: Google resource name\n            \n        Returns:\n            Contact or None if not found\n        \"\"\"\n        return self.db.query(Contact).filter(\n            Contact.resource_name == resource_name\n        ).first()\n    \n    def upsert_contact(self, contact_data: ContactCreateSchema) -\u003e Contact:\n        \"\"\"Insert or update contact.\n        \n        Args:\n            contact_data: Contact data\n            \n        Returns:\n            Created or updated contact\n        \"\"\"\n        existing = self.get_by_resource_name(contact_data.resource_name)\n        \n        if existing:\n            # Update existing contact\n            existing.etag = contact_data.etag\n            existing.given_name = contact_data.given_name\n            existing.family_name = contact_data.family_name\n            existing.display_name = contact_data.display_name\n            existing.organization = contact_data.organization\n            existing.job_title = contact_data.job_title\n            existing.deleted = contact_data.deleted\n            existing.synced_at = datetime.utcnow()\n            existing.updated_at = datetime.utcnow()\n            \n            # Delete old phone numbers\n            self.db.query(PhoneNumber).filter(\n                PhoneNumber.contact_id == existing.id\n            ).delete()\n            \n            # Add new phone numbers\n            for phone_data in contact_data.phone_numbers:\n                phone = PhoneNumber(\n                    contact_id=existing.id,\n                    value=phone_data.value,\n                    display_value=phone_data.display_value,\n                    type=phone_data.type,\n                    primary=phone_data.primary\n                )\n                self.db.add(phone)\n            \n            return existing\n        else:\n            # Create new contact\n            return self.create_contact(contact_data)\n    \n    def get_all_active(self) -\u003e List[Contact]:\n        \"\"\"Get all non-deleted contacts.\n        \n        Returns:\n            List of active contacts\n        \"\"\"\n        return self.db.query(Contact).filter(\n            Contact.deleted == False\n        ).all()\n    \n    def count_all(self) -\u003e int:\n        \"\"\"Count all contacts.\n        \n        Returns:\n            Total contact count\n        \"\"\"\n        return self.db.query(Contact).count()\n    \n    def count_active(self) -\u003e int:\n        \"\"\"Count active (non-deleted) contacts.\n        \n        Returns:\n            Active contact count\n        \"\"\"\n        return self.db.query(Contact).filter(\n            Contact.deleted == False\n        ).count()\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Trigger Full Sync**:\n   ```bash\n   # Via API\n   curl -X POST http://localhost:8000/api/sync/full\n   \n   # Should return success with statistics\n   ```\n\n2. **Check Sync Status**:\n   ```bash\n   curl http://localhost:8000/api/sync/status\n   \n   # Should show contact count and last sync time\n   ```\n\n3. **Verify Database**:\n   ```bash\n   sqlite3 data/contacts.db\n   SELECT COUNT(*) FROM contacts;\n   SELECT COUNT(*) FROM phone_numbers;\n   SELECT * FROM sync_states ORDER BY last_sync_at DESC LIMIT 1;\n   ```\n\n4. **Run Tests**:\n   ```bash\n   pytest tests/test_full_sync.py -v\n   ```\n\n## Notes\n\n- **Batch Commits**: Commits every 100 contacts to avoid memory issues\n- **Sequential Requests**: Small delays between API requests\n- **Upsert Logic**: Updates existing contacts, inserts new ones\n- **Sync Token**: Stored for future incremental syncs\n- **Error Handling**: Individual contact errors don't stop entire sync\n- **Progress Tracking**: Logs progress every batch\n\n## Common Issues\n\n1. **Memory Issues**: Reduce batch size if syncing many contacts\n2. **Rate Limits**: Increase delay between requests if hitting limits\n3. **Duplicate Phone Numbers**: Handled by deleting old, inserting new\n4. **Large Contacts**: Some contacts have many phone numbers/emails\n\n## Related Documentation\n\n- Google People API Sync: https://developers.google.com/people/v1/contacts#sync\n- SQLAlchemy Bulk Operations: https://docs.sqlalchemy.org/en/20/orm/session_api.html\n\n## Estimated Time\n\n4-6 hours","acceptance_criteria":"☐ Full sync downloads all contacts successfully\n☐ Pagination handles multiple pages correctly\n☐ Contacts are transformed and stored properly\n☐ Phone numbers are normalized and stored\n☐ Sync token is stored for future incremental syncs\n☐ Progress is tracked and can be queried\n☐ Errors during sync are logged and recoverable\n☐ Duplicate contacts are handled (upsert logic)\n☐ Sync can be interrupted and resumed\n☐ Tests verify sync logic with mock data","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.204498398Z","created_by":"vscode","updated_at":"2026-01-08T03:26:32.602533217Z","closed_at":"2026-01-08T03:11:16.460795395Z","close_reason":"Closed","labels":["P0","backend","sync"]}
{"id":"google-contacts-cisco-5bv","title":"Search Service Implementation","description":"# Unknown\n\n\n## Overview\n\nImplement a search service that provides full-text search across contact names and phone numbers. This service will support searching by name (partial matches), phone number, and combined queries.\n\n## Priority\n\n**P1 (High)** - Required for both Cisco phone and web interface search\n\n## Dependencies\n\n- Task 1.2: Database Setup\n- Task 2.1: Contact Data Models\n- Task 5.1: Phone Number Normalization\n\n## Objectives\n\n1. Implement full-text search for contact names\n2. Implement phone number search using normalization\n3. Support partial name matching\n4. Combine name and phone search results\n5. Rank search results by relevance\n6. Optimize for performance (sub-250ms response time)\n7. Handle edge cases (empty queries, special characters)\n8. Add comprehensive tests\n\n## Technical Context\n\n### Search Requirements\n- **Name Search**: Case-insensitive, partial matching, prefix and substring\n- **Phone Search**: Normalized comparison, partial matching (last N digits)\n- **Performance**: \u003c 250ms for 10,000 contacts\n- **Ranking**: Exact matches first, then prefix matches, then substring\n\n## Implementation Steps\n\n### 1. Create Search Service\n\nCreate `google_contacts_cisco/services/search_service.py`:\n\n```python\n\"\"\"Contact search service.\"\"\"\nfrom typing import List, Optional, Dict, Any\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import or_, func\n\nfrom ..models.contact import Contact\nfrom ..models.phone_number import PhoneNumber\nfrom ..repositories.contact_repository import ContactRepository\nfrom ..utils.phone_utils import get_phone_normalizer\nfrom ..utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass SearchResult:\n    \"\"\"Search result container.\"\"\"\n    \n    def __init__(self, contact: Contact, match_type: str, match_field: str = \"\"):\n        \"\"\"Initialize search result.\n        \n        Args:\n            contact: Matched contact\n            match_type: Type of match (exact, prefix, substring, phone)\n            match_field: Field that matched (name, phone)\n        \"\"\"\n        self.contact = contact\n        self.match_type = match_type\n        self.match_field = match_field\n        self.relevance_score = self._calculate_score()\n    \n    def _calculate_score(self) -\u003e int:\n        \"\"\"Calculate relevance score for ranking.\n        \n        Returns:\n            Score (higher is more relevant)\n        \"\"\"\n        scores = {\n            \"exact\": 100,\n            \"prefix\": 50,\n            \"substring\": 25,\n            \"phone\": 75,\n        }\n        return scores.get(self.match_type, 0)\n    \n    def to_dict(self) -\u003e Dict[str, Any]:\n        \"\"\"Convert to dictionary.\n        \n        Returns:\n            Dictionary representation\n        \"\"\"\n        return {\n            \"id\": str(self.contact.id),\n            \"display_name\": self.contact.display_name,\n            \"given_name\": self.contact.given_name,\n            \"family_name\": self.contact.family_name,\n            \"phone_numbers\": [\n                {\n                    \"value\": phone.value,\n                    \"display_value\": phone.display_value,\n                    \"type\": phone.type,\n                    \"primary\": phone.primary,\n                }\n                for phone in self.contact.phone_numbers\n            ],\n            \"email_addresses\": [\n                {\n                    \"value\": email.value,\n                    \"type\": email.type,\n                    \"primary\": email.primary,\n                }\n                for email in self.contact.email_addresses\n            ],\n            \"match_type\": self.match_type,\n            \"match_field\": self.match_field,\n        }\n\n\nclass SearchService:\n    \"\"\"Service for searching contacts.\"\"\"\n    \n    def __init__(self, db: Session):\n        \"\"\"Initialize search service.\n        \n        Args:\n            db: Database session\n        \"\"\"\n        self.db = db\n        self.repository = ContactRepository(db)\n        self.phone_normalizer = get_phone_normalizer()\n    \n    def search(\n        self,\n        query: str,\n        max_results: int = 50\n    ) -\u003e List[SearchResult]:\n        \"\"\"Search contacts by name or phone number.\n        \n        Args:\n            query: Search query\n            max_results: Maximum results to return\n            \n        Returns:\n            List of search results, ranked by relevance\n        \"\"\"\n        if not query or not query.strip():\n            return []\n        \n        query = query.strip()\n        logger.info(f\"Searching for: {query}\")\n        \n        results = []\n        seen_ids = set()\n        \n        # Try phone search first (if query looks like a phone number)\n        if self._looks_like_phone(query):\n            phone_results = self._search_by_phone(query)\n            for contact in phone_results:\n                if contact.id not in seen_ids:\n                    results.append(SearchResult(contact, \"phone\", \"phone_number\"))\n                    seen_ids.add(contact.id)\n        \n        # Name search\n        name_results = self._search_by_name(query)\n        for contact, match_type in name_results:\n            if contact.id not in seen_ids:\n                results.append(SearchResult(contact, match_type, \"display_name\"))\n                seen_ids.add(contact.id)\n        \n        # Sort by relevance\n        results.sort(key=lambda r: r.relevance_score, reverse=True)\n        \n        logger.info(f\"Found {len(results)} results for query: {query}\")\n        return results[:max_results]\n    \n    def search_by_name(\n        self,\n        name: str,\n        max_results: int = 50\n    ) -\u003e List[SearchResult]:\n        \"\"\"Search contacts by name only.\n        \n        Args:\n            name: Name to search\n            max_results: Maximum results to return\n            \n        Returns:\n            List of search results\n        \"\"\"\n        if not name or not name.strip():\n            return []\n        \n        name = name.strip()\n        logger.info(f\"Searching by name: {name}\")\n        \n        results = []\n        seen_ids = set()\n        \n        name_results = self._search_by_name(name)\n        for contact, match_type in name_results:\n            if contact.id not in seen_ids:\n                results.append(SearchResult(contact, match_type, \"display_name\"))\n                seen_ids.add(contact.id)\n        \n        results.sort(key=lambda r: r.relevance_score, reverse=True)\n        return results[:max_results]\n    \n    def search_by_phone(\n        self,\n        phone: str,\n        max_results: int = 50\n    ) -\u003e List[SearchResult]:\n        \"\"\"Search contacts by phone number only.\n        \n        Args:\n            phone: Phone number to search\n            max_results: Maximum results to return\n            \n        Returns:\n            List of search results\n        \"\"\"\n        if not phone or not phone.strip():\n            return []\n        \n        phone = phone.strip()\n        logger.info(f\"Searching by phone: {phone}\")\n        \n        results = []\n        contacts = self._search_by_phone(phone)\n        \n        for contact in contacts:\n            results.append(SearchResult(contact, \"phone\", \"phone_number\"))\n        \n        return results[:max_results]\n    \n    def _search_by_name(self, name: str) -\u003e List[tuple[Contact, str]]:\n        \"\"\"Internal name search with match type.\n        \n        Args:\n            name: Name to search\n            \n        Returns:\n            List of (Contact, match_type) tuples\n        \"\"\"\n        results = []\n        name_lower = name.lower()\n        \n        # Exact match on display name\n        exact_matches = (\n            self.db.query(Contact)\n            .filter(\n                Contact.deleted == False,\n                func.lower(Contact.display_name) == name_lower\n            )\n            .all()\n        )\n        results.extend((c, \"exact\") for c in exact_matches)\n        \n        # Get IDs we've already matched\n        matched_ids = {c.id for c, _ in results}\n        \n        # Prefix match on display name\n        prefix_matches = (\n            self.db.query(Contact)\n            .filter(\n                Contact.deleted == False,\n                Contact.id.notin_(matched_ids) if matched_ids else True,\n                func.lower(Contact.display_name).like(f\"{name_lower}%\")\n            )\n            .all()\n        )\n        results.extend((c, \"prefix\") for c in prefix_matches)\n        matched_ids.update(c.id for c in prefix_matches)\n        \n        # Substring match on display name, given name, or family name\n        substring_matches = (\n            self.db.query(Contact)\n            .filter(\n                Contact.deleted == False,\n                Contact.id.notin_(matched_ids) if matched_ids else True,\n                or_(\n                    func.lower(Contact.display_name).like(f\"%{name_lower}%\"),\n                    func.lower(Contact.given_name).like(f\"%{name_lower}%\"),\n                    func.lower(Contact.family_name).like(f\"%{name_lower}%\")\n                )\n            )\n            .all()\n        )\n        results.extend((c, \"substring\") for c in substring_matches)\n        \n        return results\n    \n    def _search_by_phone(self, phone: str) -\u003e List[Contact]:\n        \"\"\"Internal phone search.\n        \n        Args:\n            phone: Phone number to search\n            \n        Returns:\n            List of matching contacts\n        \"\"\"\n        return self.repository.search_by_phone(phone)\n    \n    def _looks_like_phone(self, query: str) -\u003e bool:\n        \"\"\"Check if query looks like a phone number.\n        \n        Args:\n            query: Search query\n            \n        Returns:\n            True if query appears to be a phone number\n        \"\"\"\n        # Remove common phone separators\n        digits = ''.join(c for c in query if c.isdigit())\n        \n        # If mostly digits and has at least 7 digits, treat as phone\n        if len(digits) \u003e= 7 and len(digits) \u003e= len(query) * 0.5:\n            return True\n        \n        # Check for + prefix (international)\n        if query.startswith('+') and len(digits) \u003e= 10:\n            return True\n        \n        return False\n\n\ndef get_search_service(db: Session) -\u003e SearchService:\n    \"\"\"Get search service instance.\n    \n    Args:\n        db: Database session\n        \n    Returns:\n        SearchService instance\n    \"\"\"\n    return SearchService(db)\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Test Basic Search**:\n   ```python\n   from google_contacts_cisco.models import get_db\n   from google_contacts_cisco.services.search_service import get_search_service\n   \n   db = next(get_db())\n   search = get_search_service(db)\n   \n   # Search by name\n   results = search.search(\"John\")\n   for result in results:\n       print(f\"{result.contact.display_name} ({result.match_type})\")\n   \n   # Search by phone\n   results = search.search(\"555-123-4567\")\n   for result in results:\n       print(f\"{result.contact.display_name} - {result.match_field}\")\n   ```\n\n2. **Test Performance**:\n   ```python\n   import time\n   \n   start = time.time()\n   results = search.search(\"test query\")\n   elapsed = time.time() - start\n   print(f\"Search took {elapsed*1000:.2f}ms\")\n   # Should be \u003c 250ms\n   ```\n\n3. **Run Tests**:\n   ```bash\n   uv run pytest tests/test_search_service.py -v\n   ```\n\n## Notes\n\n- **Relevance Ranking**: Exact \u003e Prefix \u003e Substring\n- **Deduplication**: Contact appears once even if matched multiple ways\n- **Performance**: Optimized with proper indexes on name fields\n- **Case Sensitivity**: All searches are case-insensitive\n- **Partial Matching**: Supports both prefix and substring\n- **Phone Detection**: Heuristic-based (mostly digits, length check)\n- **Max Results**: Default 50, configurable\n- **Deleted Contacts**: Automatically filtered out\n\n## Common Issues\n\n1. **Slow Searches**: Add indexes on name fields\n2. **False Phone Matches**: Adjust `_looks_like_phone()` heuristic\n3. **Ranking Issues**: Tune relevance scores\n4. **Memory Usage**: Limit max_results for large datasets\n5. **Special Characters**: SQL LIKE escaping\n\n## Performance Optimization\n\nIf searches are slow:\n1. Add database indexes\n2. Consider SQLite FTS5 for full-text search\n3. Cache frequent queries\n4. Limit substring matching to queries \u003e 3 chars\n\n## Related Documentation\n\n- SQLite LIKE: https://www.sqlite.org/lang_expr.html#like\n- SQLite FTS5: https://www.sqlite.org/fts5.html\n- Full-Text Search: https://www.sqlite.org/fts3.html\n\n## Estimated Time\n\n5-6 hours","acceptance_criteria":"☐ Name search supports partial matches\n☐ Phone search handles various formats\n☐ Search results are ranked by relevance\n☐ Performance meets \u003c 250ms target\n☐ Empty queries return no results\n☐ Special characters are handled safely\n☐ Results include contact details and phone numbers\n☐ Tests cover all search scenarios\n☐ Deduplication of results","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":300,"created_at":"2026-01-08T03:10:59.422445291Z","created_by":"vscode","updated_at":"2026-01-08T04:57:55.124224813Z","closed_at":"2026-01-08T04:57:55.124224813Z","close_reason":"Closed","labels":["P0","backend","search"]}
{"id":"google-contacts-cisco-5s0","title":"Configuration Management","description":"# Unknown\n\n\n## Overview\n\nSet up configuration management system using Pydantic Settings for type-safe, environment-based configuration.\n\n## Priority\n\n**P0 (Critical)** - Required for MVP\n\n## Dependencies\n\n- Task 1.1: Environment Setup (must be completed first)\n\n## Objectives\n\n1. Set up environment variable handling with python-dotenv\n2. Create type-safe configuration schema with Pydantic\n3. Create `.env.example` template\n4. Document all configuration options\n5. Implement configuration validation\n\n## Technical Context\n\n### Configuration Sources (Priority Order)\n1. Environment variables\n2. `.env` file\n3. Default values\n\n## Implementation Steps\n\n### 1. Enhance config.py\n\nUpdate `google_contacts_cisco/config.py`:\n\n```python\n\"\"\"Application configuration.\"\"\"\nfrom pathlib import Path\nfrom typing import Optional\nfrom pydantic import Field, validator\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    \"\"\"Application settings loaded from environment variables or .env file.\"\"\"\n    \n    # Application Settings\n    app_name: str = \"Google Contacts Cisco Directory\"\n    debug: bool = False\n    log_level: str = \"INFO\"\n    host: str = \"0.0.0.0\"\n    port: int = 8000\n    \n    # Database Settings\n    database_url: str = \"sqlite:///./data/contacts.db\"\n    database_echo: bool = False  # Log SQL queries\n    \n    # Google OAuth Settings\n    google_client_id: Optional[str] = None\n    google_client_secret: Optional[str] = None\n    google_oauth_scopes: list[str] = Field(\n        default_factory=lambda: [\n            \"https://www.googleapis.com/auth/contacts.readonly\"\n        ]\n    )\n    google_redirect_uri: str = \"http://localhost:8000/auth/callback\"\n    google_token_file: str = \"./data/token.json\"\n    \n    # Application Security (Optional)\n    # Note: For this single-user application with file-based OAuth token storage,\n    # a secret key may not be necessary. Include it if you plan to add:\n    # - Multi-user sessions\n    # - Signed cookies\n    # - CSRF protection for forms\n    secret_key: Optional[str] = Field(\n        default=None,\n        description=\"Secret key for session management (optional for single-user app)\"\n    )\n    \n    # Cisco Directory Settings\n    directory_max_entries_per_page: int = 32  # Max entries per Cisco XML page\n    directory_title: str = \"Google Contacts\"\n    \n    # Sync Settings\n    sync_batch_size: int = 100  # Number of contacts to process per batch\n    sync_delay_seconds: float = 0.1  # Delay between API requests\n    \n    # Search Settings\n    search_results_limit: int = 50  # Max search results to return\n    \n    model_config = SettingsConfigDict(\n        env_file=\".env\",\n        env_file_encoding=\"utf-8\",\n        case_sensitive=False,\n        extra=\"ignore\"  # Ignore extra environment variables\n    )\n    \n    @validator(\"log_level\")\n    def validate_log_level(cls, v):\n        \"\"\"Validate log level.\"\"\"\n        valid_levels = [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n        v = v.upper()\n        if v not in valid_levels:\n            raise ValueError(f\"Log level must be one of: {', '.join(valid_levels)}\")\n        return v\n    \n    # Note: Removed secret_key validator since it's optional for this single-user application\n    # If you add session management later, uncomment and use this validator:\n    # @validator(\"secret_key\")\n    # def validate_secret_key(cls, v, values):\n    #     \"\"\"Validate secret key in production.\"\"\"\n    #     if not values.get(\"debug\", False) and (v is None or v == \"change-me-in-production-to-a-random-secret-key\"):\n    #         raise ValueError(\"Must set SECRET_KEY if using session management\")\n    #     return v\n    \n    @validator(\"google_client_id\", \"google_client_secret\")\n    def validate_google_credentials(cls, v, field):\n        \"\"\"Validate Google credentials are set.\"\"\"\n        if v is None or not v.strip():\n            raise ValueError(f\"{field.name} must be set for Google OAuth\")\n        return v\n    \n    @property\n    def database_path(self) -\u003e Path:\n        \"\"\"Get database file path.\"\"\"\n        if self.database_url.startswith(\"sqlite:///\"):\n            db_path = self.database_url.replace(\"sqlite:///\", \"\")\n            return Path(db_path)\n        return Path(\"data/contacts.db\")\n    \n    @property\n    def token_path(self) -\u003e Path:\n        \"\"\"Get token file path.\"\"\"\n        return Path(self.google_token_file)\n    \n    def ensure_directories(self):\n        \"\"\"Ensure required directories exist.\"\"\"\n        self.database_path.parent.mkdir(parents=True, exist_ok=True)\n        self.token_path.parent.mkdir(parents=True, exist_ok=True)\n\n\n# Global settings instance\nsettings = Settings()\n\n# Ensure required directories exist\nsettings.ensure_directories()\n```\n\n## Verification\n\nAfter completing this task:\n1. Copy `.env.example` to `.env` and set required values\n2. Run the application - should start without errors\n3. Configuration validation should work\n4. Tests should pass: `pytest tests/test_config.py`\n5. Configuration summary should print on startup\n\n## Notes\n\n- Never commit `.env` file to version control\n- Use `.env.example` as a template\n- Sensitive values should not be logged or printed\n- Configuration should be validated on startup\n- Use type hints for all configuration options\n\n## Related Documentation\n\n- Pydantic Settings: https://docs.pydantic.dev/latest/concepts/pydantic_settings/\n- python-dotenv: https://github.com/theskumar/python-dotenv\n- Twelve-Factor App Config: https://12factor.net/config\n\n## Estimated Time\n\n2-3 hours","acceptance_criteria":"☐ Pydantic Settings is configured\n☐ `.env.example` file is created with all configuration options\n☐ Configuration schema includes type hints and validation\n☐ Configuration can be loaded from environment variables\n☐ Configuration can be loaded from `.env` file\n☐ Invalid configuration raises clear validation errors\n☐ Sensitive values are not logged or displayed\n☐ Documentation explains each configuration option","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":120,"created_at":"2026-01-08T03:10:59.069192913Z","created_by":"vscode","updated_at":"2026-01-08T03:26:31.515357335Z","closed_at":"2026-01-08T03:11:16.448841443Z","close_reason":"Closed","labels":["P0","backend","config"]}
{"id":"google-contacts-cisco-627","title":"Search API Endpoints","description":"# Unknown\n\n\n## Overview\n\nCreate RESTful API endpoints for searching contacts by name and phone number. These endpoints will be used by both the Cisco phone search functionality and the web frontend.\n\n## Priority\n\n**P1 (High)** - Required for MVP\n\n## Dependencies\n\n- Task 1.1: Environment Setup\n- Task 5.1: Phone Number Normalization\n- Task 5.2: Search Service Implementation\n\n## Objectives\n\n1. Create search API endpoint (`GET /api/search`)\n2. Support query parameters for name and phone\n3. Return JSON responses with contact data\n4. Add pagination support\n5. Implement proper error handling\n6. Add request validation\n7. Include response time logging\n8. Test all endpoints\n\n## Technical Context\n\n### API Design\n- **Endpoint**: `GET /api/search`\n- **Query Parameters**:\n  - `q`: General search query (name or phone)\n  - `name`: Search by name only\n  - `phone`: Search by phone only\n  - `limit`: Max results (default 50, max 100)\n- **Response**: JSON array of contacts with match metadata\n\n## Implementation Steps\n\n### 1. Create Search Router\n\nCreate `google_contacts_cisco/api/search.py`:\n\n```python\n\"\"\"Search API endpoints.\"\"\"\nfrom typing import Optional, List\nfrom fastapi import APIRouter, Depends, Query, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel, Field\nimport time\n\nfrom ..models import get_db\nfrom ..services.search_service import get_search_service, SearchResult\nfrom ..utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\nrouter = APIRouter(prefix=\"/api/search\", tags=[\"search\"])\n\n\nclass PhoneNumberSchema(BaseModel):\n    \"\"\"Phone number schema.\"\"\"\n    value: str\n    display_value: str\n    type: str\n    primary: bool\n\n\nclass EmailAddressSchema(BaseModel):\n    \"\"\"Email address schema.\"\"\"\n    value: str\n    type: str\n    primary: bool\n\n\nclass SearchResultSchema(BaseModel):\n    \"\"\"Search result schema.\"\"\"\n    id: str\n    display_name: str\n    given_name: Optional[str] = None\n    family_name: Optional[str] = None\n    phone_numbers: List[PhoneNumberSchema] = Field(default_factory=list)\n    email_addresses: List[EmailAddressSchema] = Field(default_factory=list)\n    match_type: str\n    match_field: str\n    \n    class Config:\n        from_attributes = True\n\n\nclass SearchResponse(BaseModel):\n    \"\"\"Search response schema.\"\"\"\n    results: List[SearchResultSchema]\n    count: int\n    query: str\n    elapsed_ms: float\n\n\n@router.get(\"\", response_model=SearchResponse)\nasync def search_contacts(\n    q: Optional[str] = Query(None, description=\"General search query (name or phone)\"),\n    name: Optional[str] = Query(None, description=\"Search by name only\"),\n    phone: Optional[str] = Query(None, description=\"Search by phone number only\"),\n    limit: int = Query(50, ge=1, le=100, description=\"Maximum results to return\"),\n    db: Session = Depends(get_db)\n):\n    \"\"\"Search contacts by name or phone number.\n    \n    Query parameters:\n    - q: General search (searches both name and phone)\n    - name: Search by name only\n    - phone: Search by phone number only\n    - limit: Maximum results (1-100, default 50)\n    \n    Only one of q, name, or phone should be provided.\n    \n    Returns:\n        SearchResponse with matching contacts\n    \"\"\"\n    start_time = time.time()\n    \n    try:\n        # Validate: only one search parameter\n        search_params = [q, name, phone]\n        if sum(p is not None for p in search_params) != 1:\n            raise HTTPException(\n                status_code=400,\n                detail=\"Exactly one of 'q', 'name', or 'phone' must be provided\"\n            )\n        \n        # Get search service\n        search_service = get_search_service(db)\n        \n        # Perform search\n        results: List[SearchResult] = []\n        query_str = \"\"\n        \n        if q:\n            query_str = q\n            results = search_service.search(q, max_results=limit)\n            logger.info(f\"General search for '{q}': {len(results)} results\")\n        elif name:\n            query_str = name\n            results = search_service.search_by_name(name, max_results=limit)\n            logger.info(f\"Name search for '{name}': {len(results)} results\")\n        elif phone:\n            query_str = phone\n            results = search_service.search_by_phone(phone, max_results=limit)\n            logger.info(f\"Phone search for '{phone}': {len(results)} results\")\n        \n        # Convert to response schema\n        result_dicts = [r.to_dict() for r in results]\n        \n        elapsed = (time.time() - start_time) * 1000\n        logger.info(f\"Search completed in {elapsed:.2f}ms\")\n        \n        return SearchResponse(\n            results=result_dicts,\n            count=len(result_dicts),\n            query=query_str,\n            elapsed_ms=round(elapsed, 2)\n        )\n    \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Search error: {str(e)}\", exc_info=True)\n        raise HTTPException(\n            status_code=500,\n            detail=\"Internal server error during search\"\n        )\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Test Search Endpoint**:\n   ```bash\n   # General search\n   curl \"http://localhost:8000/api/search?q=John\"\n   \n   # Name search\n   curl \"http://localhost:8000/api/search?name=John\"\n   \n   # Phone search\n   curl \"http://localhost:8000/api/search?phone=555-123-4567\"\n   \n   # With limit\n   curl \"http://localhost:8000/api/search?q=test\u0026limit=10\"\n   ```\n\n2. **Check API Documentation**:\n   ```bash\n   # Open browser to http://localhost:8000/docs\n   # Interactive API documentation should show search endpoint\n   ```\n\n3. **Run Tests**:\n   ```bash\n   uv run pytest tests/test_search_api.py -v\n   ```\n\n4. **Test Performance**:\n   ```bash\n   # Use Apache Bench or similar\n   ab -n 100 -c 10 \"http://localhost:8000/api/search?q=test\"\n   ```\n\n## Notes\n\n- **Query Parameters**: Only one search parameter (q, name, or phone) allowed per request\n- **Response Format**: JSON with results array and metadata\n- **Performance Logging**: Response time included in response and logs\n- **Error Handling**: 400 for bad requests, 500 for server errors\n- **CORS**: Enabled for web frontend\n- **Pagination**: Limit parameter (1-100, default 50)\n- **Validation**: Pydantic models for request/response validation\n- **Documentation**: Auto-generated via FastAPI\n\n## Common Issues\n\n1. **CORS Errors**: Add frontend origin to `cors_origins` config\n2. **Slow Responses**: Check database indexes, optimize queries\n3. **Validation Errors**: Check query parameter types and ranges\n4. **Empty Results**: Verify contacts are synced and not deleted\n5. **Performance Issues**: Monitor with `elapsed_ms` in response\n\n## Related Documentation\n\n- FastAPI: https://fastapi.tiangolo.com/\n- Pydantic: https://docs.pydantic.dev/\n- OpenAPI: https://swagger.io/specification/\n\n## Estimated Time\n\n3-4 hours","acceptance_criteria":"☐ Search endpoint returns correct results\n☐ Supports name and phone search\n☐ Query parameters are validated\n☐ Pagination works correctly\n☐ Errors return appropriate HTTP codes\n☐ Response time is logged\n☐ JSON responses are properly formatted\n☐ Tests cover all scenarios\n☐ API documentation is generated","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"open","priority":0,"issue_type":"task","estimated_minutes":180,"created_at":"2026-01-08T03:10:59.439714026Z","created_by":"vscode","updated_at":"2026-01-08T03:26:34.759441687Z","labels":["P0","api","backend","search"]}
{"id":"google-contacts-cisco-6cm","title":"Deployment Preparation","description":"# Unknown\n\n\n## Overview\n\nPrepare the application for production deployment with Docker containerization, environment configuration, production optimizations, backup strategies, and deployment automation.\n\n## Priority\n\n**P1 (High)** - Required for production deployment\n\n## Dependencies\n\n- All implementation tasks (1-22)\n- Task 8.1: API Documentation\n\n## Objectives\n\n1. Create production Dockerfile with multi-stage build\n2. Create docker-compose for full stack\n3. Configure production environment variables\n4. Set up production logging and monitoring\n5. Implement database backup strategy\n6. Create deployment scripts\n7. Configure reverse proxy (nginx)\n8. Add health checks and readiness probes\n9. Document deployment procedures\n10. Test complete deployment process\n\n## Technical Context\n\n### Deployment Architecture\n```\n[Internet] → [Nginx Reverse Proxy] → [FastAPI + Vue (Container)]\n                                            ↓\n                                        [SQLite Volume]\n```\n\n## Implementation Steps\n\n### 1. Create Multi-Stage Dockerfile\n\nCreate `Dockerfile`:\n\n```dockerfile\n# Stage 1: Build frontend\nFROM node:18-alpine AS frontend-builder\n\nWORKDIR /frontend\n\n# Copy frontend files\nCOPY frontend/package*.json ./\nRUN npm ci\n\nCOPY frontend/ ./\nRUN npm run build\n\n# Stage 2: Build backend\nFROM python:3.10-slim AS backend-builder\n\nWORKDIR /app\n\n# Install uv\nCOPY --from=ghcr.io/astral-sh/uv:latest /uv /bin/uv\n\n# Copy dependency files\nCOPY pyproject.toml ./\nCOPY google_contacts_cisco/_version.py ./google_contacts_cisco/\n\n# Install dependencies\nRUN uv sync --frozen --no-dev\n\n# Stage 3: Production image\nFROM python:3.10-slim\n\nWORKDIR /app\n\n# Create non-root user\nRUN useradd -m -u 1000 appuser \u0026\u0026 \\\n    mkdir -p /app/data /app/logs \u0026\u0026 \\\n    chown -R appuser:appuser /app\n\n# Copy uv and dependencies from builder\nCOPY --from=backend-builder /root/.local /root/.local\nCOPY --from=ghcr.io/astral-sh/uv:latest /uv /bin/uv\n\n# Copy application code\nCOPY --chown=appuser:appuser google_contacts_cisco ./google_contacts_cisco\n\n# Copy frontend build\nCOPY --from=frontend-builder --chown=appuser:appuser /frontend/dist ./google_contacts_cisco/static/dist\n\n# Switch to non-root user\nUSER appuser\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \\\n  CMD python -c \"import requests; requests.get('http://localhost:8000/health')\" || exit 1\n\n# Expose port\nEXPOSE 8000\n\n# Set environment\nENV PYTHONUNBUFFERED=1 \\\n    PYTHONDONTWRITEBYTECODE=1 \\\n    PATH=\"/root/.local/bin:$PATH\"\n\n# Run application\nCMD [\"uv\", \"run\", \"uvicorn\", \"google_contacts_cisco.main:app\", \\\n     \"--host\", \"0.0.0.0\", \\\n     \"--port\", \"8000\", \\\n     \"--workers\", \"2\", \\\n     \"--log-config\", \"/app/logging.conf\"]\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Build Docker Image**:\n   ```bash\n   docker build -t contacts-app .\n   ```\n\n2. **Test Docker Compose**:\n   ```bash\n   docker-compose -f docker-compose.prod.yml up -d\n   docker-compose -f docker-compose.prod.yml ps\n   ```\n\n3. **Test Deployment Script**:\n   ```bash\n   ./scripts/deploy.sh\n   ```\n\n4. **Test Health Check**:\n   ```bash\n   curl http://localhost:8000/health\n   ```\n\n5. **Test Backup Script**:\n   ```bash\n   ./scripts/backup.sh\n   ls -lh backups/\n   ```\n\n## Estimated Time\n\n4-5 hours","acceptance_criteria":"☐ Multi-stage Dockerfile builds successfully\n☐ Docker compose orchestrates all services\n☐ Environment variables properly configured\n☐ Production logging configured\n☐ Health checks working\n☐ Database backups automated\n☐ Nginx reverse proxy configured\n☐ HTTPS/TLS configured\n☐ Deployment scripts tested\n☐ Rollback procedure documented\n☐ Monitoring hooks in place","notes":"\n**Related Files:**\n\n- See `.ai/planning/tasks/` for complete implementation guide\n\n- Includes code examples, test suites, and verification steps","status":"open","priority":1,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.597537385Z","created_by":"vscode","updated_at":"2026-01-08T03:26:36.537548105Z","labels":["P1","deployment","infrastructure"]}
{"id":"google-contacts-cisco-86w","title":"Sync Management Interface","description":"# Unknown\n\n\n## Overview\n\nCreate a comprehensive web interface for managing contact synchronization, including manual sync triggers, real-time sync status display, sync history logs, and error handling.\n\n## Priority\n\n**P1 (High)** - Required for MVP\n\n## Dependencies\n\n- Task 3.3: Sync Service\n- Task 6.1: Frontend Framework Setup\n\n## Objectives\n\n1. Display current sync status (idle, running, completed, error)\n2. Show last sync time and statistics (contacts added/updated/deleted)\n3. Add manual sync button with loading state\n4. Display real-time sync progress\n5. Show sync history with timestamps\n6. Handle and display sync errors gracefully\n7. Add automatic sync information\n8. Test complete sync workflow\n\n## Technical Context\n\n### Sync States\n- **Idle**: No sync running, system ready\n- **Running**: Sync in progress\n- **Completed**: Last sync successful\n- **Error**: Last sync failed with error\n\n## Implementation Steps\n\n### 1. Create Sync Status API Endpoint\n\nCreate `google_contacts_cisco/api/sync.py`:\n\n```python\n\"\"\"Sync API endpoints.\"\"\"\nfrom typing import Optional\nfrom fastapi import APIRouter, Depends, HTTPException, BackgroundTasks\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nfrom ..models import get_db\nfrom ..services.sync_service import get_sync_service, SyncService\nfrom ..utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\nrouter = APIRouter(prefix=\"/api/sync\", tags=[\"sync\"])\n\n\n# Global sync state (in production, use Redis or database)\n_sync_state = {\n    \"status\": \"idle\",  # idle, running, completed, error\n    \"progress\": 0,\n    \"current_operation\": \"\",\n    \"stats\": {\n        \"added\": 0,\n        \"updated\": 0,\n        \"deleted\": 0\n    },\n    \"started_at\": None,\n    \"completed_at\": None,\n    \"error\": None\n}\n\n\nclass SyncStatusResponse(BaseModel):\n    \"\"\"Sync status response.\"\"\"\n    status: str\n    progress: int\n    current_operation: str\n    stats: dict\n    started_at: Optional[str]\n    completed_at: Optional[str]\n    error: Optional[str]\n\n\nclass SyncHistoryItem(BaseModel):\n    \"\"\"Sync history item.\"\"\"\n    id: int\n    started_at: str\n    completed_at: Optional[str]\n    status: str\n    contacts_added: int\n    contacts_updated: int\n    contacts_deleted: int\n    error: Optional[str]\n\n\nclass SyncHistoryResponse(BaseModel):\n    \"\"\"Sync history response.\"\"\"\n    history: list[SyncHistoryItem]\n    total: int\n\n\n@router.get(\"/status\", response_model=SyncStatusResponse)\nasync def get_sync_status():\n    \"\"\"Get current sync status.\n    \n    Returns:\n        Current sync status and progress\n    \"\"\"\n    return SyncStatusResponse(**_sync_state)\n\n\n@router.post(\"/trigger\")\nasync def trigger_sync(\n    background_tasks: BackgroundTasks,\n    force_full: bool = False,\n    db: Session = Depends(get_db)\n):\n    \"\"\"Trigger manual sync.\n    \n    Args:\n        force_full: Force full sync instead of incremental\n        \n    Returns:\n        Message indicating sync started\n    \"\"\"\n    global _sync_state\n    \n    if _sync_state[\"status\"] == \"running\":\n        raise HTTPException(status_code=409, detail=\"Sync already running\")\n    \n    try:\n        logger.info(f\"Triggering {'full' if force_full else 'incremental'} sync\")\n        \n        # Reset sync state\n        _sync_state = {\n            \"status\": \"running\",\n            \"progress\": 0,\n            \"current_operation\": \"Initializing sync...\",\n            \"stats\": {\"added\": 0, \"updated\": 0, \"deleted\": 0},\n            \"started_at\": datetime.utcnow().isoformat(),\n            \"completed_at\": None,\n            \"error\": None\n        }\n        \n        # Run sync in background\n        background_tasks.add_task(run_sync_task, db, force_full)\n        \n        return {\"message\": \"Sync started\", \"type\": \"full\" if force_full else \"incremental\"}\n    \n    except Exception as e:\n        logger.error(f\"Error triggering sync: {e}\", exc_info=True)\n        raise HTTPException(status_code=500, detail=\"Failed to start sync\")\n\n\nasync def run_sync_task(db: Session, force_full: bool):\n    \"\"\"Run sync task in background.\n    \n    Args:\n        db: Database session\n        force_full: Whether to force full sync\n    \"\"\"\n    global _sync_state\n    \n    try:\n        sync_service = get_sync_service(db)\n        \n        # Run sync\n        if force_full:\n            result = await sync_service.full_sync(\n                progress_callback=update_sync_progress\n            )\n        else:\n            result = await sync_service.incremental_sync(\n                progress_callback=update_sync_progress\n            )\n        \n        # Update state with results\n        _sync_state.update({\n            \"status\": \"completed\",\n            \"progress\": 100,\n            \"current_operation\": \"Sync completed\",\n            \"stats\": {\n                \"added\": result.contacts_added,\n                \"updated\": result.contacts_updated,\n                \"deleted\": result.contacts_deleted\n            },\n            \"completed_at\": datetime.utcnow().isoformat(),\n            \"error\": None\n        })\n        \n        logger.info(f\"Sync completed: {result}\")\n        \n        # Save to history\n        save_sync_history(result)\n        \n    except Exception as e:\n        logger.error(f\"Sync failed: {e}\", exc_info=True)\n        \n        _sync_state.update({\n            \"status\": \"error\",\n            \"current_operation\": \"Sync failed\",\n            \"completed_at\": datetime.utcnow().isoformat(),\n            \"error\": str(e)\n        })\n\n\ndef update_sync_progress(progress: int, operation: str):\n    \"\"\"Update sync progress.\n    \n    Args:\n        progress: Progress percentage (0-100)\n        operation: Current operation description\n    \"\"\"\n    global _sync_state\n    _sync_state[\"progress\"] = progress\n    _sync_state[\"current_operation\"] = operation\n\n\ndef save_sync_history(result):\n    \"\"\"Save sync result to history.\n    \n    Args:\n        result: Sync result object\n    \"\"\"\n    # In production, save to database\n    # For now, just log it\n    logger.info(f\"Saving sync history: {result}\")\n\n\n@router.get(\"/history\", response_model=SyncHistoryResponse)\nasync def get_sync_history(\n    limit: int = 10,\n    offset: int = 0,\n    db: Session = Depends(get_db)\n):\n    \"\"\"Get sync history.\n    \n    Args:\n        limit: Maximum number of records to return\n        offset: Number of records to skip\n        \n    Returns:\n        List of sync history records\n    \"\"\"\n    # In production, query from database\n    # For now, return empty list\n    return SyncHistoryResponse(history=[], total=0)\n\n\n@router.get(\"/info\")\nasync def get_sync_info(db: Session = Depends(get_db)):\n    \"\"\"Get general sync information.\n    \n    Returns:\n        Sync configuration and statistics\n    \"\"\"\n    from ..models.contact import Contact\n    \n    total_contacts = db.query(Contact).filter(Contact.deleted == False).count()\n    \n    return {\n        \"total_contacts\": total_contacts,\n        \"last_sync\": _sync_state.get(\"completed_at\"),\n        \"sync_type\": \"automatic\" if False else \"manual\",  # TODO: Get from config\n        \"sync_interval\": None  # TODO: Get from config if automatic\n    }\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Start Server**:\n   ```bash\n   uv run python -m google_contacts_cisco.main\n   ```\n\n2. **View Sync Page**:\n   - Open http://localhost:8000/sync\n   - Should see sync management interface\n\n3. **Test Manual Sync**:\n   - Click \"Sync Now\" button\n   - Status should change to \"Running\"\n   - Progress bar should appear and update\n   - Statistics should update when complete\n\n4. **Test Full Sync**:\n   - Click \"Full Sync\" button\n   - Should trigger full re-sync\n   - All contacts should be refreshed\n\n5. **Test Real-Time Updates**:\n   - Start a sync\n   - Watch progress bar update\n   - Status should update every 2 seconds\n\n6. **Test Error Handling**:\n   - Disconnect internet or stop Google API access\n   - Trigger sync\n   - Should show error message in red box\n\n7. **Test Polling**:\n   - Open browser dev tools (Network tab)\n   - Start a sync\n   - Should see polling requests every 2 seconds\n   - Polling should stop when sync completes\n\n8. **Test Button States**:\n   - During sync, buttons should be disabled\n   - After sync, buttons should re-enable\n\n9. **Run Tests**:\n   ```bash\n   uv run pytest tests/test_sync_api.py -v\n   ```\n\n## Notes\n\n- **Polling**: Uses 2-second interval to balance responsiveness and server load\n- **State Management**: Global state works for single instance; use Redis for multi-instance\n- **Progress**: Callback function updates progress from sync service\n- **History**: Should be persisted to database in production\n- **Error Handling**: Captures and displays sync errors gracefully\n- **Button States**: Disabled during sync to prevent multiple concurrent syncs\n- **Cleanup**: Polling stops when page is closed to prevent memory leaks\n\n## Common Issues\n\n1. **Polling Continues After Page Close**: Add `beforeunload` handler\n2. **Multiple Syncs**: Check sync status before allowing new sync\n3. **Stale Progress**: Ensure progress callback is called regularly\n4. **Memory Leaks**: Clear interval when component unmounts\n5. **Race Conditions**: Use locking mechanism for concurrent sync requests\n6. **State Persistence**: Store sync state in database for multi-instance deployments\n\n## Performance Optimization\n\n- Cache sync status for 1-2 seconds\n- Use WebSocket instead of polling for real-time updates\n- Batch status updates to reduce overhead\n- Add sync queue for multiple requests\n- Implement rate limiting\n\n## Future Enhancements\n\n- Add automatic scheduled syncs\n- Add sync configuration (frequency, time)\n- Add selective sync (only certain groups)\n- Add sync conflict resolution UI\n- Add sync preview (show what will change)\n- Add export sync logs\n- Add sync notifications\n\n## Related Documentation\n\n- Background Tasks: https://fastapi.tiangolo.com/tutorial/background-tasks/\n- Polling vs WebSocket: https://ably.com/topic/websockets-vs-polling\n- Progress Callbacks: https://realpython.com/python-progress-bar/\n\n## Estimated Time\n\n4-5 hours","acceptance_criteria":"☐ Sync status displays correctly (idle/running/completed/error)\n☐ Manual sync button works and shows loading state\n☐ Sync progress updates in real-time\n☐ Sync statistics are accurate\n☐ Sync history shows last 10 syncs\n☐ Error messages are user-friendly\n☐ Polling stops when sync completes\n☐ Tests cover all sync scenarios\n☐ Page is responsive on mobile","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"open","priority":1,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.495589134Z","created_by":"vscode","updated_at":"2026-01-08T03:26:35.58147084Z","labels":["P1","frontend","sync"]}
{"id":"google-contacts-cisco-8d2","title":"Sync Service Orchestration","description":"# Unknown\n\n\n## Overview\n\nCreate a unified sync service that orchestrates synchronization workflows, manages sync scheduling, tracks progress, and provides a clean API for sync operations.\n\n## Priority\n\n**P1 (High)** - Should have for production\n\n## Dependencies\n\n- Task 3.1: Full Sync Implementation\n- Task 3.2: Incremental Sync Implementation\n\n## Objectives\n\n1. Create unified sync service interface\n2. Add sync progress tracking\n3. Implement sync locking (prevent concurrent syncs)\n4. Add sync statistics and history\n5. Create sync management endpoints\n6. Optional: Add scheduled/automatic syncs\n7. Test sync service orchestration\n\n## Technical Context\n\n### Sync Service Responsibilities\n- Coordinate between full and incremental syncs\n- Track sync progress and status\n- Prevent concurrent syncs\n- Store sync history\n- Provide sync statistics\n- Handle sync errors gracefully\n\n## Implementation Steps\n\n### 1. Enhance Sync Service\n\nUpdate `google_contacts_cisco/services/sync_service.py`:\n\n```python\n# Add these methods and enhancements to SyncService class\n\nfrom threading import Lock\nfrom typing import List, Dict, Any\n\n# Class-level lock for preventing concurrent syncs\n_sync_lock = Lock()\n\nclass SyncService:\n    \"\"\"Enhanced sync service with orchestration.\"\"\"\n    \n    # ... existing methods ...\n    \n    def is_sync_in_progress(self) -\u003e bool:\n        \"\"\"Check if a sync is currently in progress.\n        \n        Returns:\n            True if sync is in progress\n        \"\"\"\n        sync_state = self.sync_repo.get_latest_sync_state()\n        return sync_state and sync_state.sync_status == \"syncing\"\n    \n    def safe_auto_sync(self, batch_size: int = 100) -\u003e dict:\n        \"\"\"Perform auto sync with locking to prevent concurrent syncs.\n        \n        Args:\n            batch_size: Number of contacts to commit per batch\n            \n        Returns:\n            Sync statistics or error message\n        \"\"\"\n        if not _sync_lock.acquire(blocking=False):\n            logger.warning(\"Sync already in progress, skipping\")\n            return {\n                \"status\": \"skipped\",\n                \"message\": \"Sync already in progress\",\n                \"statistics\": {}\n            }\n        \n        try:\n            return self.auto_sync(batch_size)\n        finally:\n            _sync_lock.release()\n    \n    def get_sync_history(self, limit: int = 10) -\u003e List[Dict[str, Any]]:\n        \"\"\"Get sync history.\n        \n        Args:\n            limit: Number of sync records to return\n            \n        Returns:\n            List of sync history records\n        \"\"\"\n        sync_states = self.db.query(SyncState).order_by(\n            SyncState.last_sync_at.desc()\n        ).limit(limit).all()\n        \n        history = []\n        for state in sync_states:\n            history.append({\n                \"id\": str(state.id),\n                \"status\": state.sync_status,\n                \"last_sync_at\": state.last_sync_at.isoformat() if state.last_sync_at else None,\n                \"has_sync_token\": state.sync_token is not None,\n                \"error_message\": state.error_message\n            })\n        \n        return history\n    \n    def get_sync_statistics(self) -\u003e Dict[str, Any]:\n        \"\"\"Get comprehensive sync statistics.\n        \n        Returns:\n            Sync statistics dictionary\n        \"\"\"\n        contact_count = self.contact_repo.count_active()\n        total_count = self.contact_repo.count_all()\n        deleted_count = total_count - contact_count\n        \n        # Get phone number count\n        phone_count = self.db.query(PhoneNumber).count()\n        \n        # Get latest sync\n        latest_sync = self.sync_repo.get_latest_sync_state()\n        \n        # Count syncs by status\n        from sqlalchemy import func\n        sync_counts = dict(\n            self.db.query(\n                SyncState.sync_status,\n                func.count(SyncState.id)\n            ).group_by(SyncState.sync_status).all()\n        )\n        \n        return {\n            \"contacts\": {\n                \"total\": total_count,\n                \"active\": contact_count,\n                \"deleted\": deleted_count\n            },\n            \"phone_numbers\": phone_count,\n            \"sync\": {\n                \"last_sync_at\": latest_sync.last_sync_at.isoformat() if latest_sync and latest_sync.last_sync_at else None,\n                \"status\": latest_sync.sync_status if latest_sync else \"never_synced\",\n                \"has_sync_token\": latest_sync.sync_token is not None if latest_sync else False,\n                \"error_message\": latest_sync.error_message if latest_sync else None\n            },\n            \"sync_history\": sync_counts\n        }\n    \n    def clear_sync_history(self, keep_latest: bool = True) -\u003e int:\n        \"\"\"Clear old sync history.\n        \n        Args:\n            keep_latest: If True, keep the most recent sync state\n            \n        Returns:\n            Number of sync states deleted\n        \"\"\"\n        if keep_latest:\n            # Keep only the latest sync state\n            latest = self.sync_repo.get_latest_sync_state()\n            if latest:\n                count = self.db.query(SyncState).filter(\n                    SyncState.id != latest.id\n                ).delete()\n            else:\n                count = 0\n        else:\n            # Delete all sync states\n            count = self.db.query(SyncState).delete()\n        \n        self.db.commit()\n        return count\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Test Safe Sync**:\n   ```bash\n   curl -X POST http://localhost:8000/api/sync/safe\n   # Returns success or 409 if already running\n   ```\n\n2. **Get Sync Statistics**:\n   ```bash\n   curl http://localhost:8000/api/sync/statistics\n   # Shows comprehensive sync stats\n   ```\n\n3. **Get Sync History**:\n   ```bash\n   curl http://localhost:8000/api/sync/history?limit=5\n   # Shows last 5 syncs\n   ```\n\n4. **Clear History**:\n   ```bash\n   curl -X DELETE http://localhost:8000/api/sync/history?keep_latest=true\n   ```\n\n5. **Run Tests**:\n   ```bash\n   pytest tests/test_sync_service.py -v\n   ```\n\n## Notes\n\n- **Concurrency Protection**: Lock prevents multiple simultaneous syncs\n- **Sync History**: Useful for debugging and monitoring\n- **Statistics**: Provides overview of sync health\n- **Background Scheduler**: Optional feature for automatic syncs\n- **Thread Safety**: Sync lock is thread-safe using Python's Lock\n\n## Common Issues\n\n1. **Concurrent Sync Attempts**: Lock prevents issues\n2. **Large Sync History**: Periodically clear old history\n3. **Scheduler Memory**: Daemon thread cleanup on shutdown\n4. **Lock Deadlock**: Lock is always released in finally block\n\n## Configuration Options\n\nAdd to `config.py`:\n\n```python\n# Sync scheduler settings (optional)\nsync_scheduler_enabled: bool = False\nsync_interval_minutes: int = 60  # Sync every hour\n```\n\n## Related Documentation\n\n- Python Threading: https://docs.python.org/3/library/threading.html\n- Schedule Library: https://schedule.readthedocs.io/\n- SQLAlchemy Aggregates: https://docs.sqlalchemy.org/en/20/orm/queryguide/select.html\n\n## Estimated Time\n\n3-4 hours","acceptance_criteria":"☑ Sync service prevents concurrent syncs\n☑ Sync progress can be queried in real-time\n☑ Sync history is maintained\n☑ Sync statistics are accurate\n☑ Manual sync trigger works\n☑ Sync errors are logged and reported\n☐ Sync can be cancelled (optional - not implemented)\n☑ Background sync scheduling works (optional)","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":1,"issue_type":"task","estimated_minutes":180,"created_at":"2026-01-08T03:10:59.272284743Z","created_by":"vscode","updated_at":"2026-01-08T03:26:33.136051942Z","closed_at":"2026-01-08T03:11:16.465876837Z","close_reason":"Closed","labels":["P1","backend","sync"]}
{"id":"google-contacts-cisco-a5l","title":"Phone Number Normalization","description":"# Unknown\n\n\n## Overview\n\nImplement phone number normalization and search functionality to enable searching contacts by phone number. This includes normalizing phone numbers to E.164 format for consistent storage and comparison, and implementing search logic.\n\n## Priority\n\n**P1 (High)** - Required for search functionality\n\n## Dependencies\n\n- Task 1.2: Database Setup\n- Task 2.1: Contact Data Models\n\n## Objectives\n\n1. Implement phone number normalization to E.164 format\n2. Handle various input formats (local, international, with/without formatting)\n3. Store normalized values in database for search\n4. Implement phone number comparison logic\n5. Handle invalid phone numbers gracefully\n6. Add support for country-specific formatting\n7. Test with various phone number formats\n8. Optimize for search performance\n\n## Technical Context\n\n### Phone Number Formats\n- **E.164**: International standard (+1234567890)\n- **National**: Local format without country code\n- **Formatted**: With parentheses, dashes, spaces\n- **Extensions**: Business numbers with extensions\n\n## Implementation Steps\n\n### 1. Add phonenumbers Dependency\n\nUpdate `pyproject.toml`:\n\n```toml\n[project]\ndependencies = [\n    \"fastapi\u003e=0.115.0\",\n    \"sqlalchemy\u003e=2.0.0\",\n    \"lxml\u003e=5.0.0\",\n    \"google-auth\u003e=2.35.0\",\n    \"google-auth-oauthlib\u003e=1.2.0\",\n    \"google-api-python-client\u003e=2.150.0\",\n    \"aiohttp\u003e=3.10.0\",\n    \"pydantic\u003e=2.9.0\",\n    \"pydantic-settings\u003e=2.6.0\",\n    \"phonenumbers\u003e=8.13.0\",  # Phone number parsing and validation\n]\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Test Normalization**:\n   ```python\n   from google_contacts_cisco.utils.phone_utils import get_phone_normalizer\n   \n   normalizer = get_phone_normalizer()\n   \n   # Test various formats\n   print(normalizer.normalize(\"555-123-4567\"))\n   # Output: ('+15551234567', '(555) 123-4567')\n   \n   print(normalizer.normalize(\"+44 20 7946 0958\"))\n   # Output: ('+442079460958', '+44 20 7946 0958')\n   ```\n\n2. **Test Search**:\n   ```python\n   from google_contacts_cisco.models import get_db\n   from google_contacts_cisco.repositories.contact_repository import ContactRepository\n   \n   db = next(get_db())\n   repo = ContactRepository(db)\n   \n   # Search by phone\n   results = repo.search_by_phone(\"555-123-4567\")\n   print(f\"Found {len(results)} contacts\")\n   ```\n\n3. **Run Tests**:\n   ```bash\n   uv run pytest tests/test_phone_utils.py -v\n   ```\n\n## Notes\n\n- **phonenumbers Library**: Industry-standard library by Google\n- **E.164 Format**: International standard (+[country][number])\n- **Display vs. Storage**: Store normalized, display original\n- **Search Flexibility**: Handle partial matches, various formats\n- **Performance**: Normalization is fast, but cache if needed\n- **Country Codes**: Default to US, but support international\n- **Extensions**: Strip for normalization, but could preserve in display\n- **Validation**: Invalid numbers are stored but flagged\n\n## Common Issues\n\n1. **Invalid Numbers**: Log warnings but don't fail sync\n2. **International Numbers**: Require + prefix or country code\n3. **Extensions**: Need special handling\n4. **Short Codes**: May not normalize (SMS services)\n5. **Performance**: Normalization is I/O bound, consider batching\n\n## Related Documentation\n\n- phonenumbers: https://github.com/daviddrysdale/python-phonenumbers\n- E.164 Format: https://en.wikipedia.org/wiki/E.164\n- libphonenumber: https://github.com/google/libphonenumber\n\n## Estimated Time\n\n4-5 hours","acceptance_criteria":"☐ Phone numbers are normalized to E.164 format\n☐ Handles US, international, and formatted numbers\n☐ Original display format is preserved\n☐ Search works with various input formats\n☐ Invalid numbers are handled without errors\n☐ Normalization is idempotent\n☐ Performance is acceptable for 10,000+ contacts\n☐ Tests cover edge cases (extensions, special characters, etc.)","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"in_progress","priority":0,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.403620333Z","created_by":"vscode","updated_at":"2026-01-08T05:14:26.270122996Z","labels":["P0","backend","search"]}
{"id":"google-contacts-cisco-ioj","title":"Contact Data Models","description":"# Unknown\n\n\n## Overview\n\nDefine Pydantic schemas for validating and transforming contact data from Google People API format to our internal database format. These schemas ensure type safety and data consistency throughout the application.\n\n## Priority\n\n**P0 (Critical)** - Required for MVP\n\n## Dependencies\n\n- Task 1.2: Database Setup\n- Task 2.2: Google API Client\n\n## Objectives\n\n1. Create Pydantic schemas for Google API response parsing\n2. Create schemas for internal contact representation\n3. Implement transformation logic from Google format to database format\n4. Handle missing or optional fields gracefully\n5. Validate phone numbers and email addresses\n6. Test schema validation and transformations\n\n## Technical Context\n\n### Google People API Person Resource Structure\n```json\n{\n  \"resourceName\": \"people/c1234567890\",\n  \"etag\": \"%EgcBARkE...\",\n  \"names\": [{\n    \"displayName\": \"John Doe\",\n    \"familyName\": \"Doe\",\n    \"givenName\": \"John\"\n  }],\n  \"phoneNumbers\": [{\n    \"value\": \"(555) 123-4567\",\n    \"type\": \"mobile\",\n    \"formattedType\": \"Mobile\"\n  }],\n  \"emailAddresses\": [{\n    \"value\": \"john@example.com\",\n    \"type\": \"work\"\n  }],\n  \"organizations\": [{\n    \"name\": \"Acme Corp\",\n    \"title\": \"Engineer\"\n  }],\n  \"metadata\": {\n    \"sources\": [{\n      \"type\": \"CONTACT\",\n      \"id\": \"1234567890\"\n    }]\n  }\n}\n```\n\n## Implementation Steps\n\n### 1. Create API Schemas (Google Format)\n\nCreate `google_contacts_cisco/api/schemas.py`:\n\n```python\n\"\"\"Pydantic schemas for API requests and responses.\"\"\"\nfrom typing import Optional, List\nfrom pydantic import BaseModel, Field, field_validator, EmailStr\n\n\nclass GoogleName(BaseModel):\n    \"\"\"Name from Google People API.\"\"\"\n    display_name: Optional[str] = Field(None, alias=\"displayName\")\n    given_name: Optional[str] = Field(None, alias=\"givenName\")\n    family_name: Optional[str] = Field(None, alias=\"familyName\")\n    \n    class Config:\n        populate_by_name = True\n\n\nclass GooglePhoneNumber(BaseModel):\n    \"\"\"Phone number from Google People API.\"\"\"\n    value: str\n    type: Optional[str] = None\n    formatted_type: Optional[str] = Field(None, alias=\"formattedType\")\n    \n    class Config:\n        populate_by_name = True\n\n\nclass GoogleEmailAddress(BaseModel):\n    \"\"\"Email address from Google People API.\"\"\"\n    value: EmailStr\n    type: Optional[str] = None\n    \n    class Config:\n        populate_by_name = True\n\n\nclass GoogleOrganization(BaseModel):\n    \"\"\"Organization from Google People API.\"\"\"\n    name: Optional[str] = None\n    title: Optional[str] = None\n    \n    class Config:\n        populate_by_name = True\n\n\nclass GoogleMetadataSource(BaseModel):\n    \"\"\"Metadata source from Google People API.\"\"\"\n    type: str\n    id: str\n    etag: Optional[str] = None\n    \n    class Config:\n        populate_by_name = True\n\n\nclass GoogleMetadata(BaseModel):\n    \"\"\"Metadata from Google People API.\"\"\"\n    sources: List[GoogleMetadataSource] = []\n    deleted: Optional[bool] = None\n    \n    class Config:\n        populate_by_name = True\n\n\nclass GooglePerson(BaseModel):\n    \"\"\"Person from Google People API.\"\"\"\n    resource_name: str = Field(..., alias=\"resourceName\")\n    etag: Optional[str] = None\n    names: List[GoogleName] = []\n    phone_numbers: List[GooglePhoneNumber] = Field(default_factory=list, alias=\"phoneNumbers\")\n    email_addresses: List[GoogleEmailAddress] = Field(default_factory=list, alias=\"emailAddresses\")\n    organizations: List[GoogleOrganization] = []\n    metadata: Optional[GoogleMetadata] = None\n    \n    class Config:\n        populate_by_name = True\n    \n    def get_display_name(self) -\u003e str:\n        \"\"\"Get display name for contact.\n        \n        Returns:\n            Display name, falling back to email or resource name\n        \"\"\"\n        # Try names array first\n        if self.names:\n            name = self.names[0]\n            if name.display_name:\n                return name.display_name\n            elif name.given_name and name.family_name:\n                return f\"{name.given_name} {name.family_name}\"\n            elif name.given_name:\n                return name.given_name\n            elif name.family_name:\n                return name.family_name\n        \n        # Fall back to email\n        if self.email_addresses:\n            return self.email_addresses[0].value\n        \n        # Last resort: resource name\n        return self.resource_name\n    \n    def is_deleted(self) -\u003e bool:\n        \"\"\"Check if contact is deleted.\n        \n        Returns:\n            True if contact is marked as deleted\n        \"\"\"\n        return self.metadata and self.metadata.deleted is True\n    \n    def get_primary_etag(self) -\u003e Optional[str]:\n        \"\"\"Get primary etag from metadata sources.\n        \n        Returns:\n            Etag string or None\n        \"\"\"\n        if self.etag:\n            return self.etag\n        \n        if self.metadata and self.metadata.sources:\n            for source in self.metadata.sources:\n                if source.type == \"CONTACT\" and source.etag:\n                    return source.etag\n        \n        return None\n\n\nclass GoogleConnectionsResponse(BaseModel):\n    \"\"\"Response from Google People API connections list.\"\"\"\n    connections: List[GooglePerson] = []\n    next_page_token: Optional[str] = Field(None, alias=\"nextPageToken\")\n    next_sync_token: Optional[str] = Field(None, alias=\"nextSyncToken\")\n    total_people: Optional[int] = Field(None, alias=\"totalPeople\")\n    total_items: Optional[int] = Field(None, alias=\"totalItems\")\n    \n    class Config:\n        populate_by_name = True\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Test Schema Parsing**:\n   ```python\n   from google_contacts_cisco.api.schemas import GooglePerson\n   \n   # Parse Google API response\n   data = {\n       \"resourceName\": \"people/c123\",\n       \"names\": [{\"displayName\": \"John Doe\"}],\n       \"phoneNumbers\": [{\"value\": \"(555) 123-4567\"}]\n   }\n   \n   person = GooglePerson(**data)\n   print(person.get_display_name())  # \"John Doe\"\n   ```\n\n2. **Test Transformation**:\n   ```python\n   from google_contacts_cisco.services.contact_transformer import transform_google_person_to_contact\n   \n   contact = transform_google_person_to_contact(person)\n   print(contact.display_name)  # \"John Doe\"\n   print(contact.phone_numbers[0].value)  # \"5551234567\"\n   ```\n\n3. **Run Tests**:\n   ```bash\n   pytest tests/test_schemas.py tests/test_contact_transformer.py -v\n   ```\n\n## Notes\n\n- **Pydantic V2**: Using Pydantic 2.x features (Config, validators)\n- **Alias Support**: Google uses camelCase, we use snake_case internally\n- **Phone Normalization**: Strips formatting for database storage, preserves original for display\n- **Display Name**: Multiple fallback strategies ensure every contact has a name\n- **Type Safety**: All schemas fully typed for mypy compliance\n- **Validation**: Pydantic validates data automatically\n\n## Common Issues\n\n1. **Missing Names**: Some contacts have no name - fallback to email or resource name\n2. **Multiple Phone Numbers**: Mark first as primary by default\n3. **Phone Formatting**: Google returns various formats - normalize for search\n4. **Deleted Contacts**: Check metadata.deleted flag\n5. **Missing Etag**: May be in metadata.sources instead of top level\n\n## Related Documentation\n\n- Pydantic: https://docs.pydantic.dev/\n- Google Person Resource: https://developers.google.com/people/api/rest/v1/people#Person\n- Phone Number Formats: https://en.wikipedia.org/wiki/National_conventions_for_writing_telephone_numbers\n\n## Estimated Time\n\n3-4 hours","acceptance_criteria":"☐ Pydantic schemas parse Google API responses correctly\n☐ Schemas handle missing optional fields\n☐ Phone number validation works\n☐ Email validation works\n☐ Display name generation handles various name configurations\n☐ Transformation from Google to database format is tested\n☐ Deleted contacts are marked properly\n☐ Metadata and etag are preserved\n☐ All schemas have proper type hints","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":180,"created_at":"2026-01-08T03:10:59.171710603Z","created_by":"vscode","updated_at":"2026-01-08T03:26:32.334727989Z","closed_at":"2026-01-08T03:11:16.456511253Z","close_reason":"Closed","labels":["P0","backend","models"]}
{"id":"google-contacts-cisco-jjm","title":"Contacts Directory with Integrated Search","description":"# Unknown\n\n\n## Overview\n\nCreate a comprehensive Vue 3 contact management interface with real-time integrated search, alphabetical filtering, grid/list views, and contact details modal. This combines traditional directory browsing with powerful search capabilities in a single, cohesive interface.\n\n## Priority\n\n**P1 (High)** - Required for MVP\n\n## Dependencies\n\n- Task 1.2: Database Setup\n- Task 2.1: Contact Data Models\n- Task 5.3: Search API Endpoints\n- Task 6.1: Frontend Framework Setup (Vue 3 + Vite + TypeScript)\n\n## Objectives\n\n1. Create contacts list page with real-time search integrated\n2. Display contacts in grid/list view toggle\n3. Show contact details in modal\n4. Implement alphabetical filtering (A-Z, #)\n5. Add sorting (by name, recently updated)\n6. Integrate real-time search with debouncing\n7. Add pagination for large contact lists\n8. Make fully responsive (mobile/tablet/desktop)\n9. Type-safe with full TypeScript coverage\n10. Test with various data sizes (1-10,000 contacts)\n\n## Technical Context\n\n### Integrated Search Architecture\n- **Single Page**: One `/contacts` route with search integrated\n- **Search Bar**: Prominent search input at top\n- **Dual Mode**: \n  - **Browse Mode**: Alphabetical filtering, pagination (default)\n  - **Search Mode**: Real-time search results (when typing)\n- **Smooth Transition**: Seamlessly switch between modes\n\n## Implementation Steps\n\n### 1. Define TypeScript Types\n\nCreate `frontend/src/types/contact.ts`:\n\n```typescript\n/**\n * Contact-related TypeScript types\n */\n\nexport interface PhoneNumber {\n  id: string;\n  value: string;\n  display_value: string;\n  type: string;\n  primary: boolean;\n}\n\nexport interface EmailAddress {\n  id: string;\n  value: string;\n  type: string;\n  primary: boolean;\n}\n\nexport interface Contact {\n  id: string;\n  display_name: string;\n  given_name?: string;\n  family_name?: string;\n  phone_numbers: PhoneNumber[];\n  email_addresses: EmailAddress[];\n  updated_at?: string;\n}\n\nexport interface ContactListResponse {\n  contacts: Contact[];\n  total: number;\n  offset: number;\n  limit: number;\n  has_more: boolean;\n}\n\nexport interface ContactStats {\n  total: number;\n  by_letter: Record\u003cstring, number\u003e;\n}\n\nexport interface SearchResult extends Contact {\n  match_type: 'exact' | 'prefix' | 'substring' | 'phone';\n  match_field?: string;\n  relevance_score?: number;\n}\n\nexport interface SearchResponse {\n  results: SearchResult[];\n  count: number;\n  query: string;\n  elapsed_ms: number;\n}\n\nexport type ViewMode = 'grid' | 'list';\nexport type SortOrder = 'name' | 'recent';\nexport type LetterGroup = 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '#' | '';\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Install Dependencies**:\n   ```bash\n   cd frontend\n   npm install\n   ```\n\n2. **Start Development Servers**:\n   ```bash\n   # Terminal 1: Backend\n   uv run python -m google_contacts_cisco.main\n\n   # Terminal 2: Frontend\n   cd frontend \u0026\u0026 npm run dev\n   ```\n\n3. **Test Contacts Page**:\n   - Visit http://localhost:5173/contacts\n   - Should show search bar and contact cards/list\n\n4. **Test Real-Time Search**:\n   - Type in search box\n   - Results should update after ~300ms\n   - Highlighting should work\n\n5. **Test Alphabetical Filtering**:\n   - Click letter buttons (A, B, C, etc.)\n   - Contacts should filter by first letter\n\n6. **Test View Toggle**:\n   - Switch between Grid and List views\n   - Layout should change\n   - Preference should persist (localStorage)\n\n7. **Test Contact Modal**:\n   - Click on any contact\n   - Modal should open with full details\n   - Click X or outside to close\n   - Press Escape to close\n\n8. **Test Pagination**:\n   - If \u003e30 contacts, pagination should appear\n   - Click Next/Previous\n   - Page should update\n\n9. **Test Responsive**:\n   - Resize browser\n   - Mobile: 1 column, tablet: 2 columns, desktop: 3 columns\n\n10. **Test TypeScript**:\n    ```bash\n    cd frontend\n    npm run type-check\n    ```\n\n11. **Run Tests**:\n    ```bash\n    cd frontend\n    npm run test:unit\n    ```\n\n## Notes\n\n- **Integrated Search**: Search seamlessly integrated into main contacts view\n- **Dual Mode**: Browse with filters OR search - smooth transition\n- **Real-Time**: Debounced search prevents excessive API calls\n- **Type-Safe**: Full TypeScript coverage\n- **Performance**: Client-side caching, lazy loading\n- **UX**: Loading states, empty states, error handling\n- **Responsive**: Mobile-first design\n- **Accessible**: Keyboard navigation, semantic HTML\n- **Persist Preferences**: View mode saved to localStorage\n\n## Common Issues\n\n1. **Search Lag**: Adjust debounce delay if needed\n2. **Type Errors**: Run `npm run type-check`\n3. **Highlight Issues**: Escape special regex characters\n4. **Modal Not Closing**: Check z-index and event handling\n5. **CORS**: Ensure backend allows frontend origin\n\n## Performance Optimization\n\nFor large contact lists (\u003e1000):\n1. Implement virtual scrolling (vue-virtual-scroller)\n2. Add request cancellation for abandoned searches\n3. Cache search results client-side\n4. Lazy load images if added\n5. Use Web Workers for filtering\n\n## Related Documentation\n\n- Vue 3 Composition API: https://vuejs.org/guide/extras/composition-api-faq.html\n- TypeScript with Vue: https://vuejs.org/guide/typescript/overview.html\n- Tailwind CSS: https://tailwindcss.com/docs\n- Vitest: https://vitest.dev/\n\n## Estimated Time\n\n8-10 hours (combines old tasks 17 + 18)","acceptance_criteria":"☐ Search bar is prominent and functional\n☐ Real-time search works with debouncing\n☐ Alphabetical filtering works alongside search\n☐ Grid and list views toggle correctly\n☐ Sorting by name and recent works\n☐ Pagination handles 100+ contacts\n☐ Contact detail modal shows full information\n☐ Responsive on mobile, tablet, desktop\n☐ Loading states shown appropriately\n☐ Empty states handled gracefully\n☐ TypeScript types cover all components\n☐ Tests cover search and filtering\n☐ Performance acceptable with 1000+ contacts","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"open","priority":1,"issue_type":"task","estimated_minutes":480,"created_at":"2026-01-08T03:10:59.476392545Z","created_by":"vscode","updated_at":"2026-01-08T03:26:35.304569622Z","labels":["P1","contacts","frontend","search"]}
{"id":"google-contacts-cisco-jut","title":"Frontend Framework Setup","description":"# Unknown\n\n\n## Overview\n\nSet up a modern frontend framework using Vue 3 with Vite and TypeScript, integrated with FastAPI backend. This provides reactive data binding, component architecture, and type safety for building a maintainable web interface.\n\n## Priority\n\n**P1 (High)** - Required for MVP web interface\n\n## Dependencies\n\n- Task 1.1: Environment Setup\n\n## Objectives\n\n1. Set up Vite with Vue 3 and TypeScript\n2. Configure Tailwind CSS with PostCSS\n3. Set up Vue Router for client-side routing\n4. Create base layout and components\n5. Configure API client with TypeScript types\n6. Set up development and production builds\n7. Integrate with FastAPI static file serving\n8. Test hot module replacement (HMR)\n\n## Technical Context\n\n### Technology Stack\n- **Vue 3**: Composition API with `\u003cscript setup\u003e` syntax\n- **Vite**: Fast dev server and optimized builds\n- **TypeScript**: Type safety and better DX\n- **Vue Router**: Client-side routing\n- **Tailwind CSS**: Utility-first CSS framework\n- **Pinia** (optional): State management if needed\n\n## Implementation Steps\n\n### 1. Create Frontend Project Structure\n\n```bash\n# Create frontend directory\nmkdir -p frontend\ncd frontend\n\n# Initialize Vite project with Vue + TypeScript\nnpm create vite@latest . -- --template vue-ts\n\n# Install dependencies\nnpm install\n\n# Install additional dependencies\nnpm install -D tailwindcss postcss autoprefixer\nnpm install vue-router@4\nnpm install axios\n\n# Initialize Tailwind\nnpx tailwindcss init -p\n```\n\n## Verification\n\nAfter completing this task:\n\n## Notes\n\n- **Vite Proxy**: Development proxy forwards API calls to FastAPI backend\n- **TypeScript**: Provides type safety for API responses and props\n- **Vue Router**: Uses HTML5 history mode for clean URLs\n- **Production Build**: Vite builds to `static/dist/` for FastAPI to serve\n- **Hot Module Replacement**: Vite provides instant feedback during development\n- **Composition API**: Modern Vue 3 approach with `\u003cscript setup\u003e`\n- **Path Aliases**: `@/` maps to `src/` for cleaner imports\n\n## Common Issues\n\n1. **Port Conflicts**: Change Vite port in `vite.config.ts` if 5173 is taken\n2. **CORS Errors**: Ensure proxy is configured correctly in development\n3. **Type Errors**: Run `npm run type-check` to find TypeScript issues\n4. **Build Failures**: Check that all imports are correct and types are defined\n5. **Routing Issues**: Ensure FastAPI serves `index.html` for SPA routes\n6. **API 404s**: Verify proxy configuration matches FastAPI routes\n\n## Performance Optimization\n\n- Vite automatically code-splits routes\n- Tree-shaking removes unused code\n- Tailwind purges unused CSS in production\n- Use `defineAsyncComponent` for lazy loading\n- Enable Vite build compression plugin\n\n## Future Enhancements\n\n- Add Pinia for centralized state management\n- Add Vue DevTools integration\n- Add unit tests with Vitest\n- Add E2E tests with Playwright\n- Add PWA support with vite-plugin-pwa\n- Add i18n for internationalization\n- Add component library (Headless UI)\n\n## Related Documentation\n\n- Vue 3: https://vuejs.org/\n- Vite: https://vitejs.dev/\n- Vue Router: https://router.vuejs.org/\n- TypeScript: https://www.typescriptlang.org/\n- Tailwind CSS: https://tailwindcss.com/\n- Composition API: https://vuejs.org/guide/extras/composition-api-faq.html\n\n## Estimated Time\n\n5-6 hours","acceptance_criteria":"☐ Vite dev server runs with HMR\n☐ TypeScript compilation works without errors\n☐ Tailwind CSS is configured and working\n☐ Vue Router handles navigation\n☐ API client connects to FastAPI backend\n☐ Production build generates optimized files\n☐ FastAPI serves the Vue app\n☐ Types are defined for API responses\n☐ Components are properly typed\n☐ Tests run successfully","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":300,"created_at":"2026-01-08T03:10:59.371292962Z","created_by":"vscode","updated_at":"2026-01-08T03:26:33.948203554Z","closed_at":"2026-01-08T03:11:16.473965261Z","close_reason":"Closed","labels":["P0","frontend","infrastructure"]}
{"id":"google-contacts-cisco-nlw","title":"OAuth Setup Interface","description":"# Unknown\n\n\n## Overview\n\nCreate a Vue 3 component for setting up Google OAuth authentication. This interface will guide users through the OAuth flow, handle the callback, and display the current authentication status using modern reactive patterns with TypeScript.\n\n## Priority\n\n**P0 (Critical)** - Required for initial setup\n\n## Dependencies\n\n- Task 1.3: Configuration Management\n- Task 2.2: OAuth Implementation  \n- Task 6.1: Frontend Framework Setup (Vue 3 + Vite + TypeScript)\n\n## Objectives\n\n1. Create OAuth setup Vue component\n2. Display current OAuth status reactively\n3. Implement \"Connect Google\" button with proper UX\n4. Handle OAuth callback with Vue Router\n5. Show token expiry information with auto-refresh\n6. Add token refresh functionality\n7. Handle errors gracefully with user-friendly messages\n8. Type-safe API integration with TypeScript\n9. Test OAuth flow end-to-end\n\n## Technical Context\n\n### OAuth Flow with Vue\n1. User clicks \"Connect Google\" button in Vue component\n2. Redirected to Google OAuth consent screen (external)\n3. User authorizes application\n4. Redirected back to Vue app callback route\n5. Vue component processes callback, saves OAuth tokens\n6. Reactive state updates show success\n\n## Implementation Steps\n\n### 1. Define TypeScript Types\n\nCreate `frontend/src/types/oauth.ts`:\n\n```typescript\n/**\n * OAuth-related TypeScript types\n */\n\nexport interface OAuthTokenInfo {\n  valid: boolean;\n  expired: boolean;\n  expiry: string | null;\n  scopes: string[];\n}\n\nexport interface OAuthStatus {\n  authenticated: boolean;\n  token_info: OAuthTokenInfo | null;\n}\n\nexport interface OAuthStatusResponse {\n  authenticated: boolean;\n  token_info?: OAuthTokenInfo;\n}\n\nexport interface ApiResponse\u003cT = unknown\u003e {\n  message?: string;\n  detail?: string;\n  data?: T;\n}\n\nexport interface ApiError {\n  detail: string;\n  status?: number;\n}\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Install Dependencies**:\n   ```bash\n   cd frontend\n   npm install\n   ```\n\n2. **Start Development Servers**:\n   ```bash\n   # Terminal 1: Backend\n   uv run python -m google_contacts_cisco.main\n\n   # Terminal 2: Frontend\n   cd frontend \u0026\u0026 npm run dev\n   ```\n\n3. **Test OAuth Setup Page**:\n   - Visit http://localhost:5173/oauth/setup\n   - Should show \"Setup Instructions\" if not authenticated\n   - Should show \"Connected\" status if authenticated\n\n4. **Test OAuth Flow**:\n   - Click \"Connect Google Account\"\n   - Should redirect to Google consent screen\n   - After authorization, redirected to callback page\n   - Should show success message\n\n5. **Test Token Refresh**:\n   - After connecting, click \"Refresh Token\"\n   - Should show loading spinner\n   - Should update token info\n\n6. **Test Disconnect**:\n   - Click \"Disconnect\"\n   - Should show confirmation dialog\n   - After confirmation, status should change\n\n7. **Test TypeScript Compilation**:\n   ```bash\n   cd frontend\n   npm run type-check\n   # Should complete without errors\n   ```\n\n8. **Run Component Tests**:\n   ```bash\n   cd frontend\n   npm run test:unit\n   ```\n\n## Notes\n\n- **Reactive**: Uses Vue 3 Composition API with `ref` and `computed`\n- **Type-Safe**: Full TypeScript coverage for API calls and component props\n- **Error Handling**: Comprehensive error states with user-friendly messages\n- **Loading States**: Loading spinners and disabled buttons during async operations\n- **Vue Router**: Proper integration with client-side routing\n- **Composables**: Could extract OAuth logic into a composable for reuse\n- **No Jinja2**: Pure Vue SFC, no server-side templates needed\n\n## Common Issues\n\n1. **CORS Errors**: Ensure backend CORS allows frontend origin\n2. **Type Errors**: Run `npm run type-check` to catch TypeScript issues\n3. **API URL**: Check `VITE_API_URL` in `.env` file\n4. **Router Issues**: Ensure routes are registered in router/index.ts\n5. **Redirect URI**: Must match Google Console configuration\n\n## Related Documentation\n\n- Vue 3 Composition API: https://vuejs.org/guide/extras/composition-api-faq.html\n- Vue Router: https://router.vuejs.org/\n- TypeScript with Vue: https://vuejs.org/guide/typescript/overview.html\n- Vitest: https://vitest.dev/\n\n## Estimated Time\n\n4-5 hours","acceptance_criteria":"☐ OAuth setup page displays current status reactively\n☐ \"Connect Google\" button initiates OAuth flow\n☐ Callback route displays success/error message\n☐ Token expiry is shown and updates\n☐ Refresh button works and shows loading state\n☐ Error messages are user-friendly with retry options\n☐ TypeScript types cover all API responses\n☐ Component tests cover OAuth flow\n☐ Works with real Google consent screen","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"in_progress","priority":0,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.459438485Z","created_by":"vscode","updated_at":"2026-01-08T05:15:28.268653918Z","labels":["P0","auth","frontend"]}
{"id":"google-contacts-cisco-r7t","title":"XML Formatter Service","description":"# Unknown\n\n\n## Overview\n\nCreate a service to format contact data into Cisco IP Phone XML format. This includes generating main directory menus, group menus, and individual contact directories with proper XML structure.\n\n## Priority\n\n**P0 (Critical)** - Required for MVP\n\n## Dependencies\n\n- Task 1.2: Database Setup\n- Task 3.1: Full Sync Implementation\n\n## Objectives\n\n1. Implement main directory menu generation (group selection)\n2. Implement group directory menu generation (contact list)\n3. Implement individual contact directory generation (phone numbers)\n4. Implement contact name to group mapping logic\n5. Handle XML escaping and special characters\n6. Generate proper Cisco XML structure\n7. Build RESTful URLs for navigation\n8. Test XML output with various contact data\n\n## Technical Context\n\n### Cisco XML Object Types\n1. **CiscoIPPhoneMenu**: For menus with selectable items\n2. **CiscoIPPhoneDirectory**: For contact phone numbers\n\n## Implementation Steps\n\n### 1. Create XML Formatter Service\n\nCreate `google_contacts_cisco/services/xml_formatter.py`:\n\n```python\n\"\"\"XML formatter for Cisco IP Phone directory.\"\"\"\nimport xml.etree.ElementTree as ET\nfrom typing import List, Dict\nfrom lxml import etree\nfrom html import escape\n\nfrom ..models.contact import Contact\nfrom ..models.phone_number import PhoneNumber\nfrom ..config import settings\nfrom ..utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\n\n# Group mapping for phone keypad\nGROUP_MAPPINGS = {\n    \"1\": [\"1\"],\n    \"2ABC\": [\"2\", \"A\", \"B\", \"C\"],\n    \"3DEF\": [\"3\", \"D\", \"E\", \"F\"],\n    \"4GHI\": [\"4\", \"G\", \"H\", \"I\"],\n    \"5JKL\": [\"5\", \"J\", \"K\", \"L\"],\n    \"6MNO\": [\"6\", \"M\", \"N\", \"O\"],\n    \"7PRQS\": [\"7\", \"P\", \"Q\", \"R\", \"S\"],\n    \"8TUV\": [\"8\", \"T\", \"U\", \"V\"],\n    \"9WXYZ\": [\"9\", \"W\", \"X\", \"Y\", \"Z\"],\n    \"0\": [\"0\"]\n}\n\n\nclass CiscoXMLFormatter:\n    \"\"\"Format contacts into Cisco IP Phone XML.\"\"\"\n    \n    def __init__(self, base_url: str = \"http://localhost:8000\"):\n        \"\"\"Initialize formatter.\n        \n        Args:\n            base_url: Base URL for generating links\n        \"\"\"\n        self.base_url = base_url.rstrip('/')\n    \n    def generate_main_directory(self) -\u003e str:\n        \"\"\"Generate main directory menu with group options.\n        \n        Returns:\n            XML string for main directory\n        \"\"\"\n        root = etree.Element(\"CiscoIPPhoneMenu\")\n        \n        # Title\n        title = etree.SubElement(root, \"Title\")\n        title.text = settings.directory_title\n        \n        # Add menu items for each group\n        for group_name in GROUP_MAPPINGS.keys():\n            item = etree.SubElement(root, \"MenuItem\")\n            \n            name = etree.SubElement(item, \"Name\")\n            name.text = group_name\n            \n            url = etree.SubElement(item, \"URL\")\n            url.text = f\"{self.base_url}/directory/groups/{group_name}\"\n        \n        # Add soft keys\n        self._add_softkeys(root, show_help=True, help_context=\"main\")\n        \n        return self._to_xml_string(root)\n    \n    def generate_group_directory(self, group: str, contacts: List[Contact]) -\u003e str:\n        \"\"\"Generate directory menu for a specific group.\n        \n        Args:\n            group: Group identifier (e.g., \"2ABC\")\n            contacts: List of contacts in this group\n            \n        Returns:\n            XML string for group directory\n        \"\"\"\n        root = etree.Element(\"CiscoIPPhoneMenu\")\n        \n        # Title\n        title = etree.SubElement(root, \"Title\")\n        title.text = group\n        \n        # Add menu items for each contact\n        for contact in contacts:\n            item = etree.SubElement(root, \"MenuItem\")\n            \n            name = etree.SubElement(item, \"Name\")\n            name.text = self._escape_xml(contact.display_name)\n            \n            url = etree.SubElement(item, \"URL\")\n            url.text = f\"{self.base_url}/directory/contacts/{contact.id}\"\n        \n        # Add soft keys\n        self._add_softkeys(root, show_help=True, help_context=f\"group/{group}\")\n        \n        return self._to_xml_string(root)\n    \n    def generate_contact_directory(self, contact: Contact) -\u003e str:\n        \"\"\"Generate directory for individual contact with phone numbers.\n        \n        Args:\n            contact: Contact with phone numbers\n            \n        Returns:\n            XML string for contact directory\n        \"\"\"\n        root = etree.Element(\"CiscoIPPhoneDirectory\")\n        \n        # Title\n        title = etree.SubElement(root, \"Title\")\n        title.text = self._escape_xml(contact.display_name)\n        \n        # Add phone numbers\n        if contact.phone_numbers:\n            for phone in sorted(contact.phone_numbers, key=lambda p: not p.primary):\n                entry = etree.SubElement(root, \"DirectoryEntry\")\n                \n                name = etree.SubElement(entry, \"Name\")\n                # Use type as label (Mobile, Work, etc.)\n                phone_label = phone.type.capitalize() if phone.type else \"Phone\"\n                if phone.primary:\n                    phone_label += \" (Primary)\"\n                name.text = phone_label\n                \n                telephone = etree.SubElement(entry, \"Telephone\")\n                telephone.text = phone.display_value\n        else:\n            # No phone numbers\n            entry = etree.SubElement(root, \"DirectoryEntry\")\n            name = etree.SubElement(entry, \"Name\")\n            name.text = \"No phone numbers\"\n            telephone = etree.SubElement(entry, \"Telephone\")\n            telephone.text = \"\"\n        \n        # Add soft keys for contact view\n        # Position 1: Exit (go to home directory)\n        exit_key = etree.SubElement(root, \"SoftKeyItem\")\n        exit_name = etree.SubElement(exit_key, \"Name\")\n        exit_name.text = \"Exit\"\n        exit_position = etree.SubElement(exit_key, \"Position\")\n        exit_position.text = \"1\"\n        exit_url = etree.SubElement(exit_key, \"URL\")\n        exit_url.text = f\"{self.base_url}/directory\"\n        \n        # Position 2: Back (go back to group list)\n        back_key = etree.SubElement(root, \"SoftKeyItem\")\n        back_name = etree.SubElement(back_key, \"Name\")\n        back_name.text = \"Back\"\n        back_position = etree.SubElement(back_key, \"Position\")\n        back_position.text = \"2\"\n        back_url = etree.SubElement(back_key, \"URL\")\n        back_url.text = \"SoftKey:Back\"\n        \n        # Position 3: Call\n        call_key = etree.SubElement(root, \"SoftKeyItem\")\n        call_name = etree.SubElement(call_key, \"Name\")\n        call_name.text = \"Call\"\n        call_position = etree.SubElement(call_key, \"Position\")\n        call_position.text = \"3\"\n        call_url = etree.SubElement(call_key, \"URL\")\n        call_url.text = \"SoftKey:Select\"\n        \n        return self._to_xml_string(root)\n    \n    def map_contact_to_group(self, contact: Contact) -\u003e str:\n        \"\"\"Map contact to appropriate group based on first character.\n        \n        Args:\n            contact: Contact to map\n            \n        Returns:\n            Group identifier (e.g., \"2ABC\")\n        \"\"\"\n        if not contact.display_name:\n            return \"0\"\n        \n        first_char = contact.display_name[0].upper()\n        \n        for group, chars in GROUP_MAPPINGS.items():\n            if first_char in chars:\n                return group\n        \n        # Default to \"0\" for special characters\n        return \"0\"\n    \n    def generate_help(self, context: str = \"main\") -\u003e str:\n        \"\"\"Generate help text for different contexts.\n        \n        Args:\n            context: Help context (main, group/\u003cgroup\u003e, contact)\n            \n        Returns:\n            XML string for help text\n        \"\"\"\n        root = etree.Element(\"CiscoIPPhoneText\")\n        \n        # Title\n        title = etree.SubElement(root, \"Title\")\n        title.text = \"Help\"\n        \n        # Help text based on context\n        text = etree.SubElement(root, \"Text\")\n        if context == \"main\":\n            text.text = (\n                \"Directory Help:\\n\\n\"\n                \"Select a group (e.g., 2ABC) to view contacts starting with those letters.\\n\\n\"\n                \"Use the keypad to quickly jump to a group.\\n\\n\"\n                \"Press Exit to return to main menu.\"\n            )\n        elif context.startswith(\"group/\"):\n            group = context.split(\"/\", 1)[1] if \"/\" in context else \"\"\n            text.text = (\n                f\"Group {group} Help:\\n\\n\"\n                \"Select a contact to view their phone numbers.\\n\\n\"\n                \"Use View button to open contact details.\\n\\n\"\n                \"Press Exit to return to directory home.\"\n            )\n        elif context == \"contact\":\n            text.text = (\n                \"Contact Help:\\n\\n\"\n                \"Select a phone number and press Call to dial.\\n\\n\"\n                \"Press Back to return to contact list.\\n\\n\"\n                \"Press Exit to return to directory home.\"\n            )\n        else:\n            text.text = \"Use the menu to navigate the directory. Press Exit to return to main menu.\"\n        \n        # Soft key to go back\n        soft_key = etree.SubElement(root, \"SoftKeyItem\")\n        key_name = etree.SubElement(soft_key, \"Name\")\n        key_name.text = \"Back\"\n        key_position = etree.SubElement(soft_key, \"Position\")\n        key_position.text = \"1\"\n        key_url = etree.SubElement(soft_key, \"URL\")\n        key_url.text = \"SoftKey:Back\"\n        \n        return self._to_xml_string(root)\n    \n    def _add_softkeys(self, root: etree.Element, show_help: bool = False, help_context: str = \"main\"):\n        \"\"\"Add standard soft keys to menu.\n        \n        Args:\n            root: XML root element\n            show_help: Whether to include help button\n            help_context: Context for help (main, group/\u003cgroup\u003e, contact)\n        \"\"\"\n        # Exit key\n        exit_key = etree.SubElement(root, \"SoftKeyItem\")\n        exit_name = etree.SubElement(exit_key, \"Name\")\n        exit_name.text = \"Exit\"\n        exit_position = etree.SubElement(exit_key, \"Position\")\n        exit_position.text = \"1\"\n        exit_url = etree.SubElement(exit_key, \"URL\")\n        exit_url.text = \"Init:Directories\"\n        \n        # View/Select key\n        view_key = etree.SubElement(root, \"SoftKeyItem\")\n        view_name = etree.SubElement(view_key, \"Name\")\n        view_name.text = \"View\"\n        view_position = etree.SubElement(view_key, \"Position\")\n        view_position.text = \"2\"\n        view_url = etree.SubElement(view_key, \"URL\")\n        view_url.text = \"SoftKey:Select\"\n        \n        # Optional help key\n        if show_help:\n            help_key = etree.SubElement(root, \"SoftKeyItem\")\n            help_name = etree.SubElement(help_key, \"Name\")\n            help_name.text = \"Help\"\n            help_position = etree.SubElement(help_key, \"Position\")\n            help_position.text = \"4\"\n            help_url = etree.SubElement(help_key, \"URL\")\n            help_url.text = f\"{self.base_url}/directory/help?context={help_context}\"\n    \n    def _escape_xml(self, text: str) -\u003e str:\n        \"\"\"Escape special XML characters.\n        \n        Args:\n            text: Text to escape\n            \n        Returns:\n            Escaped text\n        \"\"\"\n        if not text:\n            return \"\"\n        return escape(text, quote=True)\n    \n    def _to_xml_string(self, root: etree.Element) -\u003e str:\n        \"\"\"Convert XML element to string with proper formatting.\n        \n        Args:\n            root: XML root element\n            \n        Returns:\n            Formatted XML string\n        \"\"\"\n        xml_str = etree.tostring(\n            root,\n            encoding='UTF-8',\n            xml_declaration=True,\n            pretty_print=False\n        ).decode('utf-8')\n        \n        return xml_str\n\n\ndef get_xml_formatter(base_url: str = \"http://localhost:8000\") -\u003e CiscoXMLFormatter:\n    \"\"\"Get XML formatter instance.\n    \n    Args:\n        base_url: Base URL for generating links\n        \n    Returns:\n        CiscoXMLFormatter instance\n    \"\"\"\n    return CiscoXMLFormatter(base_url)\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Generate and View XML**:\n   ```python\n   from google_contacts_cisco.services.xml_formatter import get_xml_formatter\n   from google_contacts_cisco.models import get_db\n   from google_contacts_cisco.repositories.contact_repository import ContactRepository\n   \n   db = next(get_db())\n   formatter = get_xml_formatter()\n   \n   # Generate main directory\n   xml = formatter.generate_main_directory()\n   print(xml)\n   \n   # Generate group directory\n   repo = ContactRepository(db)\n   contacts = repo.get_all_active()\n   xml = formatter.generate_group_directory(\"2ABC\", contacts[:5])\n   print(xml)\n   ```\n\n2. **Validate XML**:\n   ```python\n   from lxml import etree\n   \n   # Parse XML to validate structure\n   root = etree.fromstring(xml.encode('utf-8'))\n   print(f\"Valid XML: {root.tag}\")\n   ```\n\n3. **Run Tests**:\n   ```bash\n   pytest tests/test_xml_formatter.py -v\n   ```\n\n## Notes\n\n- **lxml vs ElementTree**: Using lxml for better XML generation and pretty printing\n- **XML Escaping**: Critical for special characters in names\n- **URL Encoding**: URLs in XML must be properly escaped\n- **Group Mapping**: Case-insensitive matching\n- **SoftKeys**: Standard navigation buttons for Cisco phones\n- **Primary Phone**: Displayed first in contact directory\n\n## Common Issues\n\n1. **Special Characters**: Must escape \u0026, \u003c, \u003e, \", '\n2. **Empty Groups**: Handle gracefully with message\n3. **Long Names**: May be truncated by phone display\n4. **Multiple Numbers**: Sort by primary flag\n5. **URL Encoding**: Ampersands in URLs must be \u0026amp;\n\n## Related Documentation\n\n- lxml: https://lxml.de/\n- Cisco XML Objects: https://www.cisco.com/c/en/us/td/docs/voice_ip_comm/cuipph/all_models/xsi/\n- XML Entities: https://www.w3.org/TR/xml/#sec-predefined-ent\n\n## Estimated Time\n\n4-5 hours","acceptance_criteria":"☐ Main directory menu generates correctly with all groups\n☐ Group menu generates correctly with filtered contacts\n☐ Individual contact directory shows all phone numbers\n☐ Contact names are mapped to correct groups\n☐ Special characters are properly escaped\n☐ URLs are correctly formatted and escaped\n☐ Empty groups are handled gracefully\n☐ Phone number types are displayed (Mobile, Work, etc.)\n☐ Help messages are context-specific and useful\n☐ Help soft key appears in all menus\n☐ XML validates against Cisco format\n☐ Tests cover all XML generation scenarios","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.305374445Z","created_by":"vscode","updated_at":"2026-01-08T03:26:33.406757857Z","closed_at":"2026-01-08T03:11:16.468220678Z","close_reason":"Closed","labels":["P0","backend","cisco-xml"]}
{"id":"google-contacts-cisco-slh","title":"Monitoring and Logging","description":"# Unknown\n\n\n## Overview\n\nImplement comprehensive monitoring, logging, and observability infrastructure to track application health, performance metrics, errors, and usage patterns in production with Prometheus metrics, structured logging, and alerting.\n\n## Priority\n\n**P2 (Medium)** - Important for production operations and maintenance\n\n## Dependencies\n\n- Task 8.2: Deployment Preparation\n- All implementation tasks\n\n## Objectives\n\n1. Configure structured JSON logging with context\n2. Implement Prometheus metrics collection\n3. Create comprehensive health check endpoints\n4. Add request tracing with unique IDs\n5. Set up error tracking and notifications\n6. Create Grafana monitoring dashboard\n7. Configure log rotation and retention\n8. Set up alerting rules\n9. Add performance profiling\n10. Document monitoring procedures\n\n## Technical Context\n\n### Monitoring Architecture\n```\nApplication → Logs (JSON) → Log Aggregator (optional)\n           → Metrics (/metrics) → Prometheus → Grafana\n           → Health Checks → Monitoring System\n```\n\n## Implementation Steps\n\n### 1. Install Monitoring Dependencies\n\nUpdate `pyproject.toml`:\n\n```toml\n[project]\ndependencies = [\n    # ... existing dependencies ...\n    \"python-json-logger\u003e=2.0.7\",\n    \"prometheus-client\u003e=0.19.0\",\n]\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Check Logging Works**:\n   ```bash\n   # Start application\n   uv run python -m google_contacts_cisco.main\n   \n   # Check logs\n   tail -f logs/app.log\n   \n   # Make some requests\n   curl http://localhost:8000/api/contacts\n   \n   # Check logs show JSON format\n   tail -1 logs/app.log | jq\n   ```\n\n2. **Check Metrics Endpoint**:\n   ```bash\n   curl http://localhost:8000/metrics\n   \n   # Should see Prometheus metrics\n   # HELP http_requests_total Total HTTP requests\n   # TYPE http_requests_total counter\n   # http_requests_total{method=\"GET\",endpoint=\"/api/contacts\",status=\"200\"} 1.0\n   ```\n\n3. **Test Health Check**:\n   ```bash\n   curl http://localhost:8000/health | jq\n   \n   # Should return detailed health status\n   ```\n\n4. **Test Request Tracing**:\n   ```bash\n   curl -v http://localhost:8000/api/contacts\n   \n   # Check response headers\n   # X-Request-ID: 550e8400-e29b-41d4-a716-446655440000\n   # X-Response-Time: 45.23ms\n   ```\n\n5. **Set Up Prometheus** (optional):\n   ```yaml\n   # prometheus.yml\n   scrape_configs:\n     - job_name: 'contacts-app'\n       static_configs:\n         - targets: ['localhost:8000']\n       metrics_path: '/metrics'\n       scrape_interval: 15s\n   ```\n\n6. **Import Grafana Dashboard**:\n   - Open Grafana\n   - Import `monitoring/grafana/dashboard.json`\n   - Verify panels show data\n\n## Notes\n\n- **Structured Logging**: JSON format for easy parsing and aggregation\n- **Request IDs**: Unique UUID for tracing requests across logs\n- **Metrics**: Prometheus-compatible for standard monitoring tools\n- **Health Checks**: Multi-component status for orchestration\n- **Log Rotation**: Prevents logs from filling disk\n- **Performance**: Minimal overhead (\u003c1% typically)\n- **Privacy**: Don't log sensitive data (passwords, tokens)\n\n## Common Issues\n\n1. **Logs Not Appearing**: Check log level, verify handlers configured\n2. **Metrics Not Updating**: Ensure MetricsCollector called correctly\n3. **High Memory Usage**: Reduce metric cardinality (labels)\n4. **Log Disk Full**: Configure log rotation correctly\n5. **Prometheus Scrape Fails**: Check /metrics endpoint accessible\n\n## Best Practices\n\n### Logging\n- Use appropriate log levels\n- Include context (request_id, user_id)\n- Don't log sensitive data\n- Use structured logging (JSON)\n- Log errors with stack traces\n- Include timing information\n\n## Related Documentation\n\n- Prometheus: https://prometheus.io/docs/introduction/overview/\n- Grafana: https://grafana.com/docs/grafana/latest/\n- python-json-logger: https://github.com/madzak/python-json-logger\n- Prometheus Python Client: https://github.com/prometheus/client_python\n- Logging Best Practices: https://12factor.net/logs\n\n## Estimated Time\n\n4-5 hours","acceptance_criteria":"☐ Structured JSON logging configured\n☐ All requests logged with timing\n☐ Prometheus metrics exposed at `/metrics`\n☐ Health check returns component status\n☐ Request IDs track requests end-to-end\n☐ Errors logged with full context\n☐ Log rotation prevents disk filling\n☐ Grafana dashboard created\n☐ Alert rules configured\n☐ Documentation complete","notes":"- **Structured Logging**: JSON format for easy parsing and aggregation\n- **Request IDs**: Unique UUID for tracing requests across logs\n- **Metrics**: Prometheus-compatible for standard monitoring tools\n- **Health Checks**: Multi-component status for orchestration\n- **Log Rotation**: Prevents logs from filling disk\n- **Performance**: Minimal overhead (\u003c1% typically)\n- **Privacy**: Don't log sensitive data (passwords, tokens)\n\n\n**Related Files:**\n\n- See `.ai/planning/tasks/` for complete implementation guide\n\n- Includes code examples, test suites, and verification steps","status":"open","priority":2,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.617019408Z","created_by":"vscode","updated_at":"2026-01-08T03:26:36.727245393Z","labels":["P2","deployment","observability"]}
{"id":"google-contacts-cisco-u7z","title":"Integration Tests","description":"# Unknown\n\n\n## Overview\n\nCreate integration tests that verify components work together correctly across the entire stack, including API endpoints, database operations, service interactions, and external dependencies (with mocking).\n\n## Priority\n\n**P1 (High)** - Required for production readiness\n\n## Dependencies\n\n- Task 7.1: Unit Tests\n- All implementation tasks (1-19)\n\n## Objectives\n\n1. Test complete API endpoint workflows\n2. Test database transactions and rollbacks\n3. Test service integration (sync, search, XML)\n4. Test OAuth flow with mocked Google API\n5. Test error propagation across layers\n6. Test concurrent operations\n7. Test data persistence\n8. Verify request/response contracts\n\n## Technical Context\n\n### Integration Test Scope\nIntegration tests verify:\n- **API Layer**: HTTP requests/responses, routing, middleware\n- **Service Layer**: Business logic coordination\n- **Data Layer**: Database operations, transactions\n- **External Services**: Mocked Google API responses\n\n## Implementation Steps\n\n### 1. Create Integration Test Configuration\n\nUpdate `pyproject.toml`:\n\n```toml\n[tool.pytest.ini_options]\nmarkers = [\n    \"unit: Unit tests\",\n    \"integration: Integration tests\",\n    \"e2e: End-to-end tests\",\n    \"slow: Slow running tests\",\n]\n\n# Integration test specific settings\n[tool.pytest.integration]\ntimeout = 300  # 5 minutes max for integration tests\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Run Integration Tests**:\n   ```bash\n   uv run pytest tests/integration -v\n   ```\n\n2. **Run With Coverage**:\n   ```bash\n   uv run pytest tests/integration --cov=google_contacts_cisco --cov-report=term\n   ```\n\n3. **Run Specific Test File**:\n   ```bash\n   uv run pytest tests/integration/test_api_contacts.py -v\n   ```\n\n4. **Run Only Integration Tests**:\n   ```bash\n   uv run pytest -m integration -v\n   ```\n\n5. **Check Test Duration**:\n   ```bash\n   uv run pytest tests/integration --durations=10\n   # Shows slowest 10 tests\n   ```\n\n## Notes\n\n- **Test Database**: Use in-memory SQLite for speed\n- **Mocking**: Mock external APIs (Google), not internal code\n- **Transactions**: Each test runs in a transaction, rolled back after\n- **Fixtures**: Share fixtures via conftest.py\n- **Performance**: Integration tests should complete in \u003c2 minutes total\n- **Isolation**: Tests should not depend on each other\n- **Real HTTP**: Use TestClient for actual HTTP requests\n\n## Common Issues\n\n1. **Slow Tests**: Check database queries, add indexes\n2. **Flaky Tests**: Avoid time-dependent assertions\n3. **Mock Leaks**: Ensure mocks are cleaned up between tests\n4. **Database Locks**: Use separate connection pools\n5. **Port Conflicts**: Use random ports for test servers\n\n## Best Practices\n\n- Test happy path and error cases\n- Use realistic mock data\n- Test API contracts (request/response schemas)\n- Verify database state after operations\n- Test concurrent operations\n- Clean up resources after tests\n- Use descriptive test names\n- Group related tests in classes\n\n## Related Documentation\n\n- FastAPI Testing: https://fastapi.tiangolo.com/tutorial/testing/\n- pytest-asyncio: https://pytest-asyncio.readthedocs.io/\n- TestClient: https://www.starlette.io/testclient/\n\n## Estimated Time\n\n6-8 hours","acceptance_criteria":"☐ All API endpoints are tested end-to-end\n☐ Database transactions are verified\n☐ Service integration is tested\n☐ OAuth flow is tested with mocks\n☐ Error handling is verified across layers\n☐ Concurrent operations are tested\n☐ Data persistence is verified\n☐ Tests run in \u003c2 minutes\n☐ Tests are isolated and repeatable\n☐ Mock data matches real API responses","notes":"- **Test Database**: Use in-memory SQLite for speed\n- **Mocking**: Mock external APIs (Google), not internal code\n- **Transactions**: Each test runs in a transaction, rolled back after\n- **Fixtures**: Share fixtures via conftest.py\n- **Performance**: Integration tests should complete in \u003c2 minutes total\n- **Isolation**: Tests should not depend on each other\n- **Real HTTP**: Use TestClient for actual HTTP requests\n\n\n**Related Files:**\n\n- See `.ai/planning/tasks/` for complete implementation guide\n\n- Includes code examples, test suites, and verification steps","status":"open","priority":1,"issue_type":"task","estimated_minutes":360,"created_at":"2026-01-08T03:10:59.532630804Z","created_by":"vscode","updated_at":"2026-01-08T03:26:35.967243696Z","labels":["P1","integration","testing"]}
{"id":"google-contacts-cisco-wxy","title":"API Documentation","description":"# Unknown\n\n\n## Overview\n\nCreate comprehensive API documentation using FastAPI's automatic OpenAPI generation, add detailed descriptions, create usage guides, and provide Postman collections for testing and integration.\n\n## Priority\n\n**P1 (High)** - Required for maintainability and external integration\n\n## Dependencies\n\n- All API implementation tasks (1-19)\n\n## Objectives\n\n1. Enhance OpenAPI schema with descriptions\n2. Document all request/response models\n3. Add usage examples to endpoints\n4. Document error responses\n5. Create Postman collection\n6. Write setup and deployment guides\n7. Document Cisco phone configuration\n8. Create troubleshooting guide\n\n## Technical Context\n\n### FastAPI Auto-Documentation\nFastAPI automatically generates:\n- **OpenAPI 3.0** schema\n- **Swagger UI** at `/docs`\n- **ReDoc** at `/redoc`\n- **JSON Schema** for all models\n\n## Implementation Steps\n\n### 1. Enhance API Endpoint Documentation\n\nUpdate `google_contacts_cisco/api/contacts.py` with detailed docs:\n\n```python\n@router.get(\"\", response_model=ContactListResponse)\nasync def list_contacts(\n    limit: int = Query(\n        50,\n        ge=1,\n        le=100,\n        description=\"Maximum number of contacts to return (1-100)\"\n    ),\n    offset: int = Query(\n        0,\n        ge=0,\n        description=\"Number of contacts to skip for pagination\"\n    ),\n    sort: str = Query(\n        \"name\",\n        regex=\"^(name|recent)$\",\n        description=\"Sort order: 'name' for alphabetical, 'recent' for recently updated\"\n    ),\n    group: Optional[str] = Query(\n        None,\n        max_length=1,\n        description=\"Filter by first letter (A-Z) or '#' for numbers/special characters\"\n    ),\n    db: Session = Depends(get_db)\n):\n    \"\"\"\n    List all contacts with pagination, filtering, and sorting.\n    \n    This endpoint returns a paginated list of contacts from the database.\n    Use the `offset` and `limit` parameters to implement pagination in your client.\n    \n    **Filtering:**\n    - Use `group` parameter to filter by first letter of contact name\n    - Example: `?group=A` returns only contacts starting with 'A'\n    - Use `group=#` for contacts starting with numbers or special characters\n    \n    **Sorting:**\n    - `sort=name`: Alphabetical by display name (default)\n    - `sort=recent`: Most recently updated first\n    \n    **Performance:**\n    - Response time: \u003c100ms for typical queries\n    - Maximum 100 contacts per request\n    \n    **Example Usage:**\n    ```\n    GET /api/contacts?limit=20\u0026offset=0\u0026sort=name\u0026group=A\n    ```\n    \n    **Response includes:**\n    - `contacts`: Array of contact objects\n    - `total`: Total number of contacts (across all pages)\n    - `offset`: Current offset\n    - `limit`: Current limit\n    - `has_more`: Boolean indicating if more pages exist\n    \"\"\"\n    # Implementation...\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Check OpenAPI Docs**:\n   - Visit http://localhost:8000/docs\n   - Verify all endpoints are documented\n   - Test endpoints from Swagger UI\n\n2. **Check ReDoc**:\n   - Visit http://localhost:8000/redoc\n   - Verify clean documentation layout\n\n3. **Test Postman Collection**:\n   - Import `docs/postman/collection.json`\n   - Run all requests\n   - Verify responses\n\n4. **Review Documentation**:\n   - Check all docs/ files are complete\n   - Verify links work\n   - Test code examples\n\n## Estimated Time\n\n3-4 hours","acceptance_criteria":"☐ All endpoints have descriptions\n☐ Request/response schemas documented\n☐ Usage examples provided\n☐ Error codes documented\n☐ Postman collection created\n☐ Setup guide complete\n☐ Cisco phone guide complete\n☐ OAuth guide complete\n☐ Troubleshooting guide complete\n☐ OpenAPI schema validates","notes":"\n**Related Files:**\n\n- See `.ai/planning/tasks/` for complete implementation guide\n\n- Includes code examples, test suites, and verification steps","status":"open","priority":1,"issue_type":"task","estimated_minutes":180,"created_at":"2026-01-08T03:10:59.578541295Z","created_by":"vscode","updated_at":"2026-01-08T03:26:36.342958345Z","labels":["P1","api","documentation"]}
