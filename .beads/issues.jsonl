{"id":"google-contacts-cisco-0ly","title":"XML Directory Endpoints","description":"# Unknown\n\n\n## Overview\n\nCreate FastAPI endpoints to serve Cisco IP Phone XML directory. Implements the three-level hierarchy: main menu → group menu → individual contact.\n\n## Priority\n\n**P0 (Critical)** - Required for MVP\n\n## Dependencies\n\n- Task 4.1: XML Formatter Service\n- Task 3.1: Full Sync Implementation\n\n## Objectives\n\n1. Create main directory endpoint (`GET /directory`)\n2. Create group directory endpoint (`GET /directory/groups/\u003cgroup\u003e`)\n3. Create individual contact endpoint (`GET /directory/contacts/\u003cid\u003e`)\n4. Create help endpoint (`GET /directory/help`)\n5. Set proper XML content-type headers\n6. Handle errors gracefully with XML error responses\n7. Add request logging\n8. Test with Cisco IP Phone or simulator\n\n## Implementation Steps\n\n### 1. Create Directory Routes\n\nCreate `google_contacts_cisco/api/directory_routes.py`:\n\n```python\n\"\"\"Cisco IP Phone directory routes.\"\"\"\nfrom fastapi import APIRouter, Depends, HTTPException, Request\nfrom fastapi.responses import Response\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom uuid import UUID\n\nfrom ..models import get_db\nfrom ..models.contact import Contact\nfrom ..repositories.contact_repository import ContactRepository\nfrom ..services.xml_formatter import get_xml_formatter\nfrom ..utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\nrouter = APIRouter(prefix=\"/directory\", tags=[\"Cisco Directory\"])\n\n\ndef get_base_url(request: Request) -\u003e str:\n    \"\"\"Get base URL from request.\n    \n    Args:\n        request: FastAPI request\n        \n    Returns:\n        Base URL string\n    \"\"\"\n    return f\"{request.url.scheme}://{request.url.netloc}\"\n\n\n@router.get(\"\")\nasync def get_main_directory(\n    request: Request,\n    db: Session = Depends(get_db)\n):\n    \"\"\"Get main directory menu with group options.\n    \n    Returns XML menu for Cisco IP Phone main directory.\n    \"\"\"\n    try:\n        base_url = get_base_url(request)\n        formatter = get_xml_formatter(base_url)\n        \n        xml_content = formatter.generate_main_directory()\n        \n        logger.info(\"Generated main directory XML\")\n        \n        return Response(\n            content=xml_content,\n            media_type=\"text/xml; charset=utf-8\"\n        )\n    \n    except Exception as e:\n        logger.error(f\"Error generating main directory: {e}\")\n        return _error_response(\"Error loading directory\")\n\n\n@router.get(\"/groups/{group}\")\nasync def get_group_directory(\n    group: str,\n    request: Request,\n    db: Session = Depends(get_db)\n):\n    \"\"\"Get directory for specific group.\n    \n    Args:\n        group: Group identifier (e.g., \"2ABC\")\n        \n    Returns XML menu with contacts in the group.\n    \"\"\"\n    try:\n        base_url = get_base_url(request)\n        formatter = get_xml_formatter(base_url)\n        contact_repo = ContactRepository(db)\n        \n        # Get all active contacts\n        all_contacts = contact_repo.get_all_active()\n        \n        # Filter contacts by group\n        group_contacts = [\n            c for c in all_contacts\n            if formatter.map_contact_to_group(c) == group.upper()\n        ]\n        \n        # Sort by display name\n        group_contacts.sort(key=lambda c: c.display_name.lower())\n        \n        xml_content = formatter.generate_group_directory(group, group_contacts)\n        \n        logger.info(f\"Generated group directory for {group}: {len(group_contacts)} contacts\")\n        \n        return Response(\n            content=xml_content,\n            media_type=\"text/xml; charset=utf-8\"\n        )\n    \n    except Exception as e:\n        logger.error(f\"Error generating group directory for {group}: {e}\")\n        return _error_response(f\"Error loading group {group}\")\n\n\n@router.get(\"/contacts/{contact_id}\")\nasync def get_contact_directory(\n    contact_id: UUID,\n    request: Request,\n    db: Session = Depends(get_db)\n):\n    \"\"\"Get directory for individual contact.\n    \n    Args:\n        contact_id: Contact UUID\n        \n    Returns XML directory with contact's phone numbers.\n    \"\"\"\n    try:\n        base_url = get_base_url(request)\n        formatter = get_xml_formatter(base_url)\n        \n        # Get contact from database\n        contact = db.query(Contact).filter(Contact.id == contact_id).first()\n        \n        if not contact:\n            logger.warning(f\"Contact not found: {contact_id}\")\n            return _error_response(\"Contact not found\")\n        \n        if contact.deleted:\n            logger.warning(f\"Contact deleted: {contact_id}\")\n            return _error_response(\"Contact no longer available\")\n        \n        xml_content = formatter.generate_contact_directory(contact)\n        \n        logger.info(f\"Generated contact directory for {contact.display_name}\")\n        \n        return Response(\n            content=xml_content,\n            media_type=\"text/xml; charset=utf-8\"\n        )\n    \n    except ValueError as e:\n        logger.error(f\"Invalid contact ID: {contact_id}\")\n        return _error_response(\"Invalid contact\")\n    \n    except Exception as e:\n        logger.error(f\"Error generating contact directory for {contact_id}: {e}\")\n        return _error_response(\"Error loading contact\")\n\n\n@router.get(\"/help\")\nasync def get_help(\n    context: str = \"main\",\n    request: Request = None\n):\n    \"\"\"Get help text for directory.\n    \n    Args:\n        context: Help context (main, group/\u003cgroup\u003e, contact)\n        \n    Returns help text in Cisco XML format.\n    \"\"\"\n    try:\n        logger.info(f\"Generating help for context: {context}\")\n        \n        # Get formatter with base URL\n        base_url = get_base_url(request)\n        formatter = get_xml_formatter(base_url)\n        \n        # Generate help\n        xml = formatter.generate_help(context)\n        \n        logger.debug(f\"Help XML generated for context {context}\")\n        return Response(content=xml, media_type=\"text/xml; charset=utf-8\")\n        \n    except Exception as e:\n        logger.error(f\"Error generating help: {str(e)}\", exc_info=True)\n        return _error_response(\"Error loading help\")\n\n\ndef _error_response(message: str) -\u003e Response:\n    \"\"\"Generate error XML response.\n    \n    Args:\n        message: Error message to display\n        \n    Returns:\n        Response with error XML\n    \"\"\"\n    from lxml import etree\n    \n    root = etree.Element(\"CiscoIPPhoneText\")\n    \n    title = etree.SubElement(root, \"Title\")\n    title.text = \"Error\"\n    \n    text = etree.SubElement(root, \"Text\")\n    text.text = message\n    \n    # Add prompt\n    prompt = etree.SubElement(root, \"Prompt\")\n    prompt.text = \"Press Exit to return\"\n    \n    xml_str = etree.tostring(\n        root,\n        encoding='UTF-8',\n        xml_declaration=True\n    ).decode('utf-8')\n    \n    return Response(\n        content=xml_str,\n        media_type=\"text/xml; charset=utf-8\",\n        status_code=200  # Cisco phones expect 200 even for errors\n    )\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Test Main Directory**:\n   ```bash\n   curl http://localhost:8000/directory\n   # Should return XML menu\n   ```\n\n2. **Test Group Directory**:\n   ```bash\n   curl http://localhost:8000/directory/groups/2ABC\n   # Should return contacts starting with A, B, C\n   ```\n\n3. **Test Individual Contact**:\n   ```bash\n   # Get a contact ID from database first\n   curl http://localhost:8000/directory/contacts/\u003cuuid\u003e\n   # Should return phone numbers\n   ```\n\n4. **Test Help**:\n   ```bash\n   curl \"http://localhost:8000/directory/help?context=main\"\n   # Should return help text\n   ```\n\n4. **Test with Cisco Phone**:\n   - Configure phone to use: `http://your-server:8000/directory`\n   - Navigate through menu\n   - Verify all levels work\n\n5. **Run Tests**:\n   ```bash\n   pytest tests/test_directory_endpoints.py -v\n   ```\n\n## Notes\n\n- **Content-Type**: Must be `text/xml; charset=utf-8` for Cisco phones\n- **Error Handling**: Return XML errors, not JSON\n- **Status Codes**: Always return 200 even for errors (Cisco requirement)\n- **Base URL**: Dynamically generated from request\n- **Performance**: Query optimization for large contact lists\n- **Caching**: Consider adding caching for frequently accessed groups\n- **SoftKeys**: \n  - Menu soft keys (Main/Group directories):\n    - Position 1: Exit (return to phone's directory list)\n    - Position 2: View (select item)\n    - Position 4: Help (show help text)\n  - Contact directory soft keys:\n    - Position 1: Exit (go to home directory)\n    - Position 2: Back (go back one level)\n    - Position 3: Call (select phone number)\n- **Help Text**: Context-specific help available via Help soft key\n\n## Common Issues\n\n1. **Wrong Content-Type**: Phones show raw XML\n2. **Not HTTPS**: Some phones require SSL\n3. **Slow Response**: Add caching or pagination\n4. **Special Characters**: Ensure proper XML escaping\n5. **Empty Groups**: Display message, not empty menu\n\n## Performance Optimization\n\nFor large contact lists:\n- Add database indexes on display_name\n- Cache group mappings\n- Implement pagination if needed\n- Use SELECT with LIMIT for group queries\n\n## Related Documentation\n\n- FastAPI Responses: https://fastapi.tiangolo.com/advanced/custom-response/\n- Cisco XML Services: https://www.cisco.com/c/en/us/td/docs/voice_ip_comm/cuipph/all_models/xsi/\n\n## Estimated Time\n\n3-4 hours","acceptance_criteria":"☑ Main directory returns valid XML\n☑ Group directory filters contacts correctly\n☑ Individual contact shows all phone numbers\n☑ Content-Type is set to `text/xml; charset=utf-8`\n☑ Missing contacts return proper XML error\n☑ Invalid group returns empty or error XML\n☑ XML validates and displays on Cisco phone\n☑ Endpoints return in \u003c 100ms\n☑ Tests verify all endpoints","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":180,"created_at":"2026-01-08T03:10:59.338783386Z","created_by":"vscode","updated_at":"2026-01-08T03:26:33.684665405Z","closed_at":"2026-01-08T03:11:16.471291857Z","close_reason":"Closed","labels":["P0","api","backend","cisco-xml"]}
{"id":"google-contacts-cisco-1i0","title":"Database Setup","description":"# Unknown\n\n\n## Overview\n\nSet up SQLite database with SQLAlchemy ORM and Alembic migrations. Define the database schema for contacts, phone numbers, and sync state.\n\n## Priority\n\n**P0 (Critical)** - Required for MVP\n\n## Dependencies\n\n- Task 1.1: Environment Setup (must be completed first)\n\n## Objectives\n\n1. Configure SQLAlchemy with SQLite\n2. Define database models (Contact, PhoneNumber, SyncState)\n3. Set up Alembic for database migrations\n4. Create initial migration\n5. Test database connectivity and basic operations\n\n## Technical Context\n\n### Database: SQLite\n- File-based database: `data/contacts.db`\n- No separate server required\n- Sufficient for single-user application\n- ACID compliant\n\n## Data Model\n\n### Contact Entity\n- `id`: UUID (primary key)\n- `resource_name`: String (Google Contacts resource name)\n- `etag`: String (for conflict detection)\n- `given_name`: String (nullable)\n- `family_name`: String (nullable)\n- `display_name`: String (required, indexed)\n- `organization`: String (nullable)\n- `job_title`: String (nullable)\n- `created_at`: DateTime\n- `updated_at`: DateTime\n- `deleted`: Boolean (soft delete)\n- `synced_at`: DateTime (last sync timestamp)\n- **Relationship**: one-to-many with PhoneNumber\n\n## Implementation Steps\n\n### 1. Create Database Configuration\n\nCreate `google_contacts_cisco/config.py`:\n\n```python\n\"\"\"Application configuration.\"\"\"\nfrom pathlib import Path\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    \"\"\"Application settings.\"\"\"\n    \n    # Database\n    database_url: str = \"sqlite:///./data/contacts.db\"\n    \n    # Application\n    app_name: str = \"Google Contacts Cisco Directory\"\n    debug: bool = False\n    \n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n\n\nsettings = Settings()\n```\n\n## Verification\n\nAfter completing this task:\n1. Run `alembic upgrade head` - should complete without errors\n2. Check that `data/contacts.db` file exists\n3. Run `pytest tests/test_database.py` - all tests should pass\n4. Verify tables exist in database using SQLite browser or command line\n\n## Notes\n\n- UUID is used for primary keys for better distributed system support\n- Soft deletes are used (deleted flag) rather than hard deletes\n- Indexes are created on frequently queried fields\n- Relationships are properly defined for easy navigation\n\n## Related Documentation\n\n- SQLAlchemy 2.0: https://docs.sqlalchemy.org/en/20/\n- Alembic: https://alembic.sqlalchemy.org/\n- Pydantic Settings: https://docs.pydantic.dev/latest/concepts/pydantic_settings/\n\n## Estimated Time\n\n3-4 hours","acceptance_criteria":"☐ SQLAlchemy is configured with SQLite\n☐ Database file location is configurable\n☐ All three models are defined with proper types and relationships\n☐ Alembic is initialized and configured\n☐ Initial migration is created and applied\n☐ Database tables are created successfully\n☐ Indexes are created on display_name and phone number value\n☐ Basic CRUD operations work for all models\n☐ Tests verify database operations","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":180,"created_at":"2026-01-08T03:10:59.024373481Z","created_by":"vscode","updated_at":"2026-01-08T03:26:31.260935806Z","closed_at":"2026-01-08T03:11:16.431867347Z","close_reason":"Closed","labels":["P0","backend","database"]}
{"id":"google-contacts-cisco-1tp","title":"Remove standalone search page and enhance contacts directory search","description":"## Problem\n\nThe application has two search interfaces, creating confusion:\n1. **ContactsView** (`/contacts`) - Fully functional with integrated search bar\n2. **SearchView** (`/search`) - Non-functional placeholder page showing \"Search Coming Soon\"\n\nThe standalone search page serves no purpose since ContactsView already provides comprehensive search functionality. The duplicate route should be removed.\n\n**CRITICAL BUG**: Partial phone number search is broken. While \"Ro\" correctly matches \"Rohan Kapoor\", searching \"555\" does NOT match phone numbers containing \"555\". This is a major usability issue.\n\n## Current State\n\n### Frontend\n- `ContactsView.vue` has working real-time search with debouncing\n- `SearchView.vue` is just a placeholder with no value\n- Navigation includes \"Search\" link pointing to non-functional page\n- Router has `/search` route configured\n- API client has fully functional `search()` method\n\n### Backend - CRITICAL ISSUES\n- **Partial phone search broken**: `search_by_phone` requires ≥7 digits (line 268)\n- **Inconsistent thresholds**: `_build_phone_search_conditions` requires ≥4 digits (line 396)\n- **Name search works**: Partial matching works fine for names (e.g., \"Ro\" → \"Rohan\")\n- **Expected behavior**: \"555\" should match \"(555) 123-4567\", \"202\" should match \"+1-202-555-1234\"\n\n### Test Coverage Gaps\n- `test_search_phone_too_short` expects empty results for \"123\" - this is wrong!\n- No tests for 3-6 digit partial phone searches\n- Missing tests for common use cases like area code search\n\n## Solution\n\n### Part 1: Fix Critical Phone Search Bug (PRIORITY 1)\n\n**Problem Details:**\n```python\n# search_by_phone (line 268) - TOO RESTRICTIVE\nif digits and len(digits) \u003e= 7:\n    conditions.append(PhoneNumber.value.like(f\"%{digits[-7:]}\"))\n\n# _build_phone_search_conditions (line 396) - BETTER BUT STILL LIMITED\nif digits and len(digits) \u003e= 4:\n    digit_pattern = f\"%{digits}%\"\n    conditions.append(PhoneNumber.value.like(digit_pattern))\n```\n\n**Required Fixes:**\n1. **Lower minimum digit threshold to 3** (common use case: \"555\", \"202\", \"310\")\n2. **Use infix matching** (`%{digits}%`) not just suffix matching\n3. **Ensure consistency** between `search_by_phone` and `_build_phone_search_conditions`\n4. **Search both fields**: Check `PhoneNumber.value` AND `PhoneNumber.display_value`\n\n**Implementation:**\n```python\n# Updated _build_phone_search_conditions\ndef _build_phone_search_conditions(self, search_term: str) -\u003e List:\n    conditions = []\n    digits = ''.join(c for c in search_term if c.isdigit())\n    \n    # Support partial phone search with minimum 3 digits\n    if digits and len(digits) \u003e= 3:\n        # Infix pattern matching (find anywhere in phone number)\n        digit_pattern = f\"%{digits}%\"\n        conditions.append(PhoneNumber.value.like(digit_pattern))\n        conditions.append(PhoneNumber.display_value.like(digit_pattern))\n    \n    # Additional: Try normalized format for longer queries\n    if len(digits) \u003e= 7:\n        normalized = self.phone_normalizer.normalize_for_search(search_term)\n        if normalized:\n            conditions.append(PhoneNumber.value == normalized)\n            # Suffix match for last 7 digits\n            digits_only = ''.join(c for c in normalized if c.isdigit())\n            if len(digits_only) \u003e= 7:\n                suffix_pattern = f\"%{digits_only[-7:]}\"\n                conditions.append(PhoneNumber.value.like(suffix_pattern))\n    \n    return conditions\n```\n\n```python\n# Updated search_by_phone to use lower threshold\ndef search_by_phone(self, phone_number: str, limit: int = 50, offset: int = 0) -\u003e List[Contact]:\n    if not phone_number or not phone_number.strip():\n        return []\n    \n    digits = ''.join(c for c in phone_number if c.isdigit())\n    \n    # Minimum 3 digits for search (changed from 7)\n    if not digits or len(digits) \u003c 3:\n        logger.warning(\"Phone query too short: %s\", phone_number)\n        return []\n    \n    # Use the improved _build_phone_search_conditions\n    conditions = self._build_phone_search_conditions(phone_number)\n    \n    if not conditions:\n        return []\n    \n    # ... rest of query execution\n```\n\n### Part 2: Remove Duplicate Search Page (PRIORITY 2)\n\n- Remove \"Search\" from navigation in `BaseLayout.vue`\n- Remove or redirect `/search` route in router\n- Delete or archive `SearchView.vue` (mark as deprecated)\n\n## Files to Modify\n\n### CRITICAL - Backend Fixes (Priority 1)\n1. **google_contacts_cisco/services/search_service.py**\n   - Fix `_build_phone_search_conditions`: Change `\u003e= 4` to `\u003e= 3` (line 396)\n   - Add infix matching for both `value` and `display_value`\n   - Fix `search_by_phone`: Lower threshold from 7 to 3 (line 268)\n   - Ensure consistency between methods\n\n2. **tests/unit/services/test_search_service.py**\n   - Update `test_search_phone_too_short`: Should succeed for \"555\" (3 digits)\n   - Add test: `test_search_partial_phone_3_digits` → \"555\" matches \"(555) 123-4567\"\n   - Add test: `test_search_partial_phone_area_code` → \"202\" matches \"+1-202-555-1234\"\n   - Add test: `test_search_partial_phone_middle` → \"555\" matches \"202-555-1234\"\n   - Add test: `test_search_partial_phone_end` → \"234\" matches \"555-1234\"\n\n3. **tests/integration/api/test_api_search.py**\n   - Add integration tests for partial phone search via API\n   - Test: \"555\" query returns contacts with \"555\" in phone\n\n### Frontend Cleanup (Priority 2)\n4. **frontend/src/components/BaseLayout.vue**\n   - Remove \"Search\" from navigation array (line 18)\n   - Remove search icon SVG rendering (lines 91-94, 156-158)\n\n5. **frontend/src/router/index.ts**\n   - Redirect `/search` route to `/contacts`\n\n6. **frontend/src/views/SearchView.vue**\n   - Delete or add deprecation notice\n\n### Optional Enhancements\n7. **frontend/src/views/ContactsView.vue**\n   - Add search result count display\n   - Update search placeholder: \"Search by name or phone (min 3 digits)...\"\n\n## Acceptance Criteria\n\n### CRITICAL - Phone Search Fix\n- [ ] \"555\" matches contacts with phone numbers containing \"555\"\n- [ ] \"202\" matches contacts with area code 202\n- [ ] \"123\" matches phone numbers ending in \"123\"\n- [ ] \"5551234\" continues to work (backward compatibility)\n- [ ] Works with both normalized values and display values\n- [ ] Minimum 3 digits required (not 4 or 7)\n- [ ] Consistent behavior across all search methods\n\n### Functionality - Navigation Cleanup\n- [ ] Navigation no longer shows \"Search\" link\n- [ ] `/search` route redirects to `/contacts`\n- [ ] ContactsView search works correctly (no regressions)\n- [ ] All search features accessible from ContactsView\n\n### Technical\n- [ ] All existing tests pass (after updates)\n- [ ] New tests added for 3-6 digit phone searches\n- [ ] No console errors or warnings\n- [ ] Frontend builds successfully\n- [ ] Backend tests pass with new phone search logic\n\n### UI/UX\n- [ ] Search placeholder text indicates minimum digits\n- [ ] Partial phone search feels as natural as name search\n- [ ] Results are accurate and expected\n- [ ] Performance is acceptable (indexed properly)\n\n## Testing Checklist\n\n### PRIORITY 1: Phone Search Testing\n\n**Backend Tests:**\n1. Run `pytest tests/unit/services/test_search_service.py::TestSearchContactsByPhone -v`\n2. Add and verify new tests for 3-6 digit searches\n3. Test edge cases: \"555\", \"202\", \"123\", \"5551234\", \"202-555\"\n\n**Manual API Testing:**\n```bash\n# Add a contact with phone (555) 123-4567\n# Test partial searches\ncurl \"http://localhost:8000/api/search?q=555\u0026limit=10\"  # Should find contact\ncurl \"http://localhost:8000/api/search?q=123\u0026limit=10\"  # Should find contact\ncurl \"http://localhost:8000/api/search?q=202\u0026limit=10\"  # Should find contacts with 202 area code\n```\n\n**Frontend Testing:**\n5. Navigate to `/contacts`\n6. Type \"555\" in search → Should see contacts with 555 in phone\n7. Type \"202\" in search → Should see contacts with 202 area code\n8. Type \"Ro\" in search → Should see \"Rohan\" (name search still works)\n9. Clear search → Returns to browse mode\n\n### PRIORITY 2: Navigation Testing\n10. Open app - \"Search\" link not visible in navigation\n11. Try to access `/search` directly - redirects to `/contacts`\n12. Mobile navigation works correctly (no Search item)\n\n### Build \u0026 Tests\n13. Run `pytest tests/ -v` - all tests pass\n14. Run `npm run build` in frontend - build succeeds\n15. Check console - no errors or warnings\n\n## Implementation Plan\n\n### Phase 1: Fix Phone Search Bug (DO FIRST)\n1. Update `_build_phone_search_conditions`:\n   - Change threshold from `\u003e= 4` to `\u003e= 3`\n   - Use `%{digits}%` pattern for infix matching\n   - Search both `value` and `display_value` fields\n   \n2. Update `search_by_phone`:\n   - Change minimum from 7 to 3 digits\n   - Use improved `_build_phone_search_conditions`\n   \n3. Update/add tests:\n   - Fix `test_search_phone_too_short` to expect success for 3+ digits\n   - Add tests for 3-digit, 4-digit, 5-digit, 6-digit searches\n   - Test area code searches\n   - Test middle/end digit matching\n\n4. Run tests and verify:\n   ```bash\n   pytest tests/unit/services/test_search_service.py -v\n   pytest tests/integration/api/test_api_search.py -v\n   ```\n\n### Phase 2: Clean Up Navigation\n5. Remove Search from `BaseLayout.vue`\n6. Redirect `/search` route\n7. Delete/archive `SearchView.vue`\n8. Test frontend build\n\n## Success Criteria\n\n✅ **CRITICAL - Task is NOT complete unless:**\n- [ ] \"555\" successfully matches phone numbers containing \"555\"\n- [ ] \"202\" successfully matches area code 202\n- [ ] Minimum 3-digit phone search works\n- [ ] All new tests pass\n- [ ] No regressions in name search\n\n✅ **Task is complete when:**\n- [ ] Phone search works with 3+ digits (critical bug fixed)\n- [ ] All tests pass including new phone search tests\n- [ ] Navigation no longer shows \"Search\" link\n- [ ] `/search` route redirects to `/contacts`\n- [ ] Frontend builds without errors\n- [ ] ContactsView search works perfectly for both names and phones\n\n## Notes\n\n**This is a CRITICAL bug fix disguised as a cleanup task.** The phone search issue affects core functionality and must be fixed. Users expect \"555\" to find phone numbers just like \"Ro\" finds \"Rohan\". The current 7-digit requirement is too restrictive for real-world use cases.\n\nThe navigation cleanup is secondary but important for UX consistency.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T07:27:54.777179811Z","created_by":"vscode","updated_at":"2026-01-09T07:33:03.766996654Z"}
{"id":"google-contacts-cisco-1y9","title":"Incremental Sync Implementation","description":"# Unknown\n\n\n## Overview\n\nImplement incremental synchronization using sync tokens to efficiently update only changed contacts since the last sync. This reduces API calls and improves sync performance.\n\n## Priority\n\n**P1 (High)** - Should have for production\n\n## Dependencies\n\n- Task 3.1: Full Sync Implementation\n- Task 2.2: Google API Client\n\n## Objectives\n\n1. Implement incremental sync using sync tokens\n2. Handle contact updates (modified contacts)\n3. Handle contact deletions (soft delete)\n4. Handle sync token expiration (410 error)\n5. Implement fallback to full sync when needed\n6. Test incremental sync workflow\n\n## Technical Context\n\n### Incremental Sync Process\n1. Retrieve stored sync token from database\n2. Request changes since last sync using sync token\n3. Process returned contacts (updates and deletions)\n4. Update database accordingly\n5. Store new sync token\n\n## Implementation Steps\n\n### 1. Update Sync Service with Incremental Sync\n\nUpdate `google_contacts_cisco/services/sync_service.py`:\n\n```python\n# Add this method to SyncService class\n\ndef incremental_sync(self, batch_size: int = 100) -\u003e dict:\n    \"\"\"Perform incremental sync using sync token.\n    \n    Args:\n        batch_size: Number of contacts to commit per batch\n        \n    Returns:\n        Sync statistics\n    \"\"\"\n    logger.info(\"Starting incremental sync\")\n    \n    # Get latest sync state\n    sync_state = self.sync_repo.get_latest_sync_state()\n    \n    if not sync_state or not sync_state.sync_token:\n        logger.warning(\"No sync token available, performing full sync instead\")\n        return self.full_sync(batch_size)\n    \n    sync_token = sync_state.sync_token\n    logger.info(f\"Using sync token: {sync_token[:20]}...\")\n    \n    # Create new sync state\n    new_sync_state = self.sync_repo.create_sync_state(status=\"syncing\")\n    self.db.commit()\n    \n    stats = {\n        \"total_fetched\": 0,\n        \"updated\": 0,\n        \"deleted\": 0,\n        \"errors\": 0,\n        \"pages\": 0\n    }\n    \n    try:\n        # Fetch changes from Google\n        for response_data in self.google_client.list_connections(\n            page_size=100,\n            sync_token=sync_token\n        ):\n            stats[\"pages\"] += 1\n            \n            # Parse response\n            response = GoogleConnectionsResponse(**response_data)\n            \n            if not response.connections:\n                logger.info(f\"Page {stats['pages']}: No changes\")\n                continue\n            \n            logger.info(f\"Page {stats['pages']}: Processing {len(response.connections)} changes\")\n            \n            # Process each contact\n            for person in response.connections:\n                try:\n                    stats[\"total_fetched\"] += 1\n                    \n                    if person.is_deleted():\n                        # Handle deleted contact\n                        self._handle_deleted_contact(person.resource_name)\n                        stats[\"deleted\"] += 1\n                    else:\n                        # Handle updated contact\n                        from ..services.contact_transformer import transform_google_person_to_contact\n                        contact_data = transform_google_person_to_contact(person)\n                        self.contact_repo.upsert_contact(contact_data)\n                        stats[\"updated\"] += 1\n                    \n                    # Commit in batches\n                    if stats[\"total_fetched\"] % batch_size == 0:\n                        self.db.commit()\n                        logger.info(f\"Committed batch: {stats['total_fetched']} changes processed\")\n                \n                except Exception as e:\n                    logger.error(f\"Error processing contact {person.resource_name}: {e}\")\n                    stats[\"errors\"] += 1\n                    continue\n            \n            # Commit remaining changes in page\n            self.db.commit()\n            \n            # Store new sync token if this is the last page\n            if not response.next_page_token and response.next_sync_token:\n                self.sync_repo.update_sync_state(\n                    new_sync_state,\n                    sync_token=response.next_sync_token\n                )\n                self.db.commit()\n                logger.info(f\"Stored new sync token: {response.next_sync_token[:20]}...\")\n            \n            # Small delay between pages\n            time.sleep(0.1)\n        \n        # Mark sync as complete\n        self.sync_repo.update_sync_state(new_sync_state, status=\"idle\")\n        self.db.commit()\n        \n        logger.info(f\"Incremental sync completed: {stats}\")\n        return stats\n    \n    except HttpError as e:\n        if e.resp.status == 410:\n            # Sync token expired, perform full sync\n            logger.warning(\"Sync token expired (410), falling back to full sync\")\n            self.sync_repo.update_sync_state(\n                new_sync_state,\n                status=\"error\",\n                error_message=\"Sync token expired, performing full sync\"\n            )\n            self.db.commit()\n            return self.full_sync(batch_size)\n        else:\n            logger.error(f\"Incremental sync failed: {e}\")\n            self.sync_repo.update_sync_state(\n                new_sync_state,\n                status=\"error\",\n                error_message=str(e)\n            )\n            self.db.commit()\n            raise\n    \n    except Exception as e:\n        logger.error(f\"Incremental sync failed: {e}\")\n        self.sync_repo.update_sync_state(\n            new_sync_state,\n            status=\"error\",\n            error_message=str(e)\n        )\n        self.db.commit()\n        raise\n\ndef _handle_deleted_contact(self, resource_name: str):\n    \"\"\"Handle deleted contact by soft-deleting it.\n    \n    Args:\n        resource_name: Resource name of deleted contact\n    \"\"\"\n    contact = self.contact_repo.get_by_resource_name(resource_name)\n    if contact:\n        contact.deleted = True\n        contact.synced_at = datetime.utcnow()\n        logger.info(f\"Marked contact as deleted: {resource_name}\")\n    else:\n        logger.warning(f\"Deleted contact not found in database: {resource_name}\")\n\ndef auto_sync(self, batch_size: int = 100) -\u003e dict:\n    \"\"\"Automatically choose between full and incremental sync.\n    \n    Args:\n        batch_size: Number of contacts to commit per batch\n        \n    Returns:\n        Sync statistics\n    \"\"\"\n    sync_state = self.sync_repo.get_latest_sync_state()\n    \n    if sync_state and sync_state.sync_token:\n        logger.info(\"Sync token available, performing incremental sync\")\n        return self.incremental_sync(batch_size)\n    else:\n        logger.info(\"No sync token available, performing full sync\")\n        return self.full_sync(batch_size)\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Test Incremental Sync**:\n   ```bash\n   # First do a full sync\n   curl -X POST http://localhost:8000/api/sync/full\n   \n   # Update a contact in Google Contacts\n   \n   # Then do incremental sync\n   curl -X POST http://localhost:8000/api/sync/incremental\n   \n   # Should only sync changed contacts\n   ```\n\n2. **Test Auto Sync**:\n   ```bash\n   curl -X POST http://localhost:8000/api/sync\n   # Automatically chooses full or incremental\n   ```\n\n3. **Verify Sync Token**:\n   ```bash\n   sqlite3 data/contacts.db\n   SELECT sync_token FROM sync_states ORDER BY last_sync_at DESC LIMIT 1;\n   ```\n\n4. **Run Tests**:\n   ```bash\n   pytest tests/test_incremental_sync.py -v\n   ```\n\n## Notes\n\n- **Efficiency**: Incremental sync only processes changes, much faster than full sync\n- **Soft Delete**: Deleted contacts are marked, not physically deleted\n- **Token Expiration**: 410 error triggers automatic fallback to full sync\n- **Propagation Delay**: Google changes may take several minutes to appear in sync\n- **Auto Sync**: Recommended endpoint - automatically chooses best sync method\n\n## Common Issues\n\n1. **410 Sync Token Expired**: Normal after long periods, just triggers full sync\n2. **Missing Deleted Contacts**: Contact never synced, can't be deleted\n3. **Slow Incremental Sync**: May have many changes, consider full sync\n4. **Propagation Delay**: Changes may not appear immediately (several minutes)\n\n## Performance Comparison\n\n- **Full Sync**: O(n) where n is total contacts\n- **Incremental Sync**: O(m) where m is changed contacts\n- For 10,000 contacts with 10 changes: ~1000x faster\n\n## Related Documentation\n\n- Google Sync Tokens: https://developers.google.com/people/v1/contacts#sync\n- Incremental Sync Guide: https://developers.google.com/people/v1/how-tos/sync\n\n## Estimated Time\n\n3-4 hours","acceptance_criteria":"☑ Incremental sync uses stored sync token\n☑ Updated contacts are updated in database\n☑ Deleted contacts are soft-deleted (marked as deleted)\n☑ Sync token expiration triggers full sync\n☑ New sync token is stored after successful sync\n☑ Incremental sync is faster than full sync\n☑ No sync token triggers full sync\n☑ Tests verify incremental sync logic","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":1,"issue_type":"task","estimated_minutes":180,"created_at":"2026-01-08T03:10:59.237521748Z","created_by":"vscode","updated_at":"2026-01-08T03:26:32.870781026Z","closed_at":"2026-01-08T03:11:16.46356984Z","close_reason":"Closed","labels":["P1","backend","sync"]}
{"id":"google-contacts-cisco-24i","title":"Test Infrastructure \u0026 Coverage Verification","description":"# Unknown\n\n\n## Overview\n\nSet up comprehensive testing infrastructure, establish testing standards, verify overall test coverage across the codebase, and ensure all components have been properly tested according to the test plan. This task focuses on test infrastructure and verification, NOT writing individual unit tests (those should be written alongside each implementation task).\n\n## Priority\n\n**P1 (High)** - Required for production readiness\n\n## Dependencies\n\n- All implementation tasks (1-19) - Each should include their own tests\n- Task 1.1: Environment Setup\n\n## Objectives\n\n1. Set up pytest configuration and standards\n2. Create shared test fixtures and utilities\n3. Configure coverage reporting and thresholds\n4. Verify test coverage across all modules (\u003e80% target)\n5. Identify and document coverage gaps\n6. Set up CI/CD test integration\n7. Create test execution scripts\n8. Document testing patterns and best practices\n9. Verify test quality (not just quantity)\n10. Create test coverage dashboard\n\n## Technical Context\n\n### What This Task IS About\n- ✅ Setting up pytest configuration\n- ✅ Creating shared test fixtures (conftest.py)\n- ✅ Configuring coverage tools and reports\n- ✅ Verifying overall test coverage\n- ✅ Identifying gaps in test coverage\n- ✅ Documenting testing standards\n- ✅ Setting up CI/CD test integration\n\n## Implementation Steps\n\n### 1. Set Up pytest Configuration\n\nCreate `pyproject.toml` additions:\n\n```toml\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\npython_files = [\"test_*.py\"]\npython_classes = [\"Test*\"]\npython_functions = [\"test_*\"]\naddopts = [\n    \"-v\",\n    \"--strict-markers\",\n    \"--cov=google_contacts_cisco\",\n    \"--cov-report=term-missing\",\n    \"--cov-report=html\",\n    \"--cov-report=xml\",\n    \"--cov-fail-under=80\",\n]\nmarkers = [\n    \"unit: Unit tests\",\n    \"integration: Integration tests\",\n    \"e2e: End-to-end tests\",\n    \"slow: Slow running tests\",\n]\n\n[tool.coverage.run]\nsource = [\"google_contacts_cisco\"]\nomit = [\n    \"*/tests/*\",\n    \"*/conftest.py\",\n    \"*/__init__.py\",\n    \"*/main.py\",\n]\n\n[tool.coverage.report]\nexclude_lines = [\n    \"pragma: no cover\",\n    \"def __repr__\",\n    \"raise AssertionError\",\n    \"raise NotImplementedError\",\n    \"if __name__ == .__main__.:\",\n    \"if TYPE_CHECKING:\",\n    \"@abstractmethod\",\n]\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Verify pytest Configuration**:\n   ```bash\n   uv run pytest --collect-only\n   ```\n\n2. **Run All Tests**:\n   ```bash\n   ./scripts/test.sh\n   ```\n\n3. **Check Coverage**:\n   ```bash\n   python scripts/verify-coverage.py\n   ```\n\n4. **Generate Coverage Report**:\n   ```bash\n   ./scripts/coverage-report.sh\n   ```\n\n5. **Verify Coverage Thresholds**:\n   ```bash\n   uv run pytest --cov=google_contacts_cisco --cov-fail-under=80\n   ```\n\n6. **Check Test Quality**:\n   - Review tests for each module\n   - Ensure edge cases are covered\n   - Verify error paths are tested\n   - Check that mocks are used appropriately\n\n7. **Identify Coverage Gaps**:\n   ```bash\n   uv run pytest --cov=google_contacts_cisco --cov-report=term-missing\n   # Look for lines marked with \"!\" in the output\n   ```\n\n## Notes\n\n- **Not About Writing Tests**: This task sets up infrastructure and verifies coverage\n- **Tests Per Task**: Each implementation task (1-19) should include its own tests\n- **Quality Over Quantity**: 80% coverage with good tests \u003e 100% coverage with poor tests\n- **Critical Paths**: Focus extra effort on testing critical functionality\n- **Fast Execution**: All unit tests should run in \u003c30 seconds total\n- **CI/CD Ready**: Configuration should work in CI/CD pipelines\n\n## Common Issues\n\n1. **Low Coverage**: Review tasks 1-19, ensure tests were written for each\n2. **Slow Tests**: Check for unnecessary database operations or API calls\n3. **Flaky Tests**: Remove time-dependent assertions, ensure proper isolation\n4. **Import Errors**: Verify PYTHONPATH and package structure\n5. **Coverage Reporting Fails**: Ensure coverage.xml is generated correctly\n\n## Best Practices\n\n1. **One Test, One Concept**: Each test should verify one thing\n2. **Arrange-Act-Assert**: Structure tests clearly\n3. **Descriptive Names**: Test names should explain what is tested\n4. **Independent Tests**: Tests should not depend on each other\n5. **Fast Tests**: Unit tests should run in milliseconds\n6. **Use Fixtures**: Reuse test data via fixtures\n7. **Mock External Dependencies**: Don't call real APIs in unit tests\n\n## Related Documentation\n\n- pytest: https://docs.pytest.org/\n- pytest-cov: https://pytest-cov.readthedocs.io/\n- Coverage.py: https://coverage.readthedocs.io/\n- Testing Best Practices: https://docs.python-guide.org/writing/tests/\n\n## Estimated Time\n\n4-6 hours (infrastructure setup and verification only)\n\n**Note**: Time for writing individual unit tests is included in each implementation task (1-19).","acceptance_criteria":"☐ pytest configuration established with proper settings\n☐ Shared test fixtures created (conftest.py)\n☐ Coverage reporting configured (terminal, HTML, XML)\n☐ All modules have \u003e80% test coverage\n☐ Critical paths have \u003e95% coverage\n☐ Coverage gaps are identified and documented\n☐ Test execution scripts created\n☐ CI/CD integration configured\n☐ Testing best practices documented\n☐ Test quality verified (not just quantity)\n☐ Coverage reports generated and accessible","notes":"- **Not About Writing Tests**: This task sets up infrastructure and verifies coverage\n- **Tests Per Task**: Each implementation task (1-19) should include its own tests\n- **Quality Over Quantity**: 80% coverage with good tests \u003e 100% coverage with poor tests\n- **Critical Paths**: Focus extra effort on testing critical functionality\n- **Fast Execution**: All unit tests should run in \u003c30 seconds total\n- **CI/CD Ready**: Configuration should work in CI/CD pipelines\n\n\n**Related Files:**\n\n- See `.ai/planning/tasks/` for complete implementation guide\n\n- Includes code examples, test suites, and verification steps","status":"closed","priority":1,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.512832163Z","created_by":"vscode","updated_at":"2026-01-08T05:26:18.277467122Z","closed_at":"2026-01-08T05:26:18.277467122Z","close_reason":"Closed","labels":["P1","infrastructure","testing"]}
{"id":"google-contacts-cisco-278","title":"Bug: Timezone handling inconsistency causes timestamp display issues","description":"## Problem\nTimezone configuration exists but implementation is inconsistent:\n1. Config validates timezone (config.py lines 144-162) but not used consistently\n2. Some timestamps use UTC, others use local time\n3. No timezone info in API responses (datetime_utils.py)\n4. Database stores timestamps without timezone info\n5. Sync timestamps may show wrong time in UI\n\n## Affected Files\n- `config.py` lines 57, 144-162 - Timezone config\n- `utils/datetime_utils.py` - Format functions\n- `models/contact.py` lines 24-32 - DateTime columns\n- `services/sync_service.py` - Timestamp formatting\n\n## Examples\n```python\n# contact.py - Uses timezone.utc consistently\ncreated_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))\n\n# But format_timestamp_for_display may not handle TZ correctly\n# datetime_utils.py needs review\n```\n\n## Impact\n- **User Confusion**: Timestamps show wrong time\n- **Sync Issues**: Last sync time incorrect\n- **Audit Problems**: Cannot determine actual event times\n- **International Users**: Timezone-aware users see UTC always\n\n## Required Fix\n1. Store all timestamps with timezone in database (migrate to TIMESTAMP WITH TIME ZONE)\n2. Use timezone-aware datetime objects throughout\n3. Add timezone to all API responses\n4. Convert timestamps to user's configured timezone for display\n5. Add timezone tests with different TZ settings\n6. Document timezone handling in API docs","status":"open","priority":2,"issue_type":"bug","created_at":"2026-01-09T21:19:27.869467571-08:00","created_by":"rohan","updated_at":"2026-01-09T21:19:27.869467571-08:00","labels":["backend","bug","datetime","timezone"]}
{"id":"google-contacts-cisco-2e3","title":"Performance: N+1 query problem in contact listing","description":"## Problem\nContact repository loads phone_numbers with N+1 queries:\n1. `get_contacts()` doesn't use joinedload (contact_repository.py lines 302-328)\n2. API serializes phone_numbers causing N queries (api/contacts.py line 135)\n3. Same issue in search results (api/contacts.py lines 294)\n4. Each contact triggers separate query for relationships\n5. 100 contacts = 101 queries (1 for contacts + 100 for phones)\n\n## Affected Code\n```python\n# contact_repository.py lines 318-328\ndef get_contacts(self, limit=30, offset=0, sort_by_recent=False):\n    query = (\n        self.db.query(Contact)\n        .filter(Contact.deleted == False)\n        # Missing: .options(joinedload(Contact.phone_numbers))\n    )\n```\n\n## Performance Impact\n- **API Latency**: 100ms per extra query\n- **Database Load**: 100x more queries than needed\n- **Scalability**: Cannot handle many concurrent users\n- **Cost**: High database connection usage\n\n## Query Count Examples\n| Contacts | Current Queries | With Joinedload | Savings |\n|----------|----------------|-----------------|---------|\n| 10       | 11             | 1               | 90%     |\n| 100      | 101            | 1               | 99%     |\n| 1000     | 1001           | 1               | 99.9%   |\n\n## Required Fix\n1. Add joinedload to get_contacts()\n2. Add joinedload to get_contacts_by_letter_group()\n3. Add joinedload to get_contact_by_id()\n4. Add selectinload for email_addresses when added\n5. Add SQL query logging tests to catch N+1\n6. Benchmark API performance before/after\n7. Document eager loading strategy\n\n## Testing\nEnable SQL echo and count queries:\n```python\nsettings.database_echo = True\n# Should see 1 query with JOIN, not N+1 SELECTs\n```","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T21:20:33.398451088-08:00","created_by":"rohan","updated_at":"2026-01-09T21:20:33.398451088-08:00","labels":["backend","database","n-plus-one","performance"]}
{"id":"google-contacts-cisco-2ox","title":"OAuth 2.0 Implementation","description":"# Unknown\n\n\n## Overview\n\nImplement OAuth 2.0 authentication flow with Google to enable access to the user's Google Contacts. This includes handling authorization, token storage, and automatic token refresh.\n\n## Priority\n\n**P0 (Critical)** - Required for MVP\n\n## Dependencies\n\n- Task 1.1: Environment Setup\n- Task 1.3: Configuration Management\n\n## Objectives\n\n1. Implement OAuth 2.0 authorization flow with Google\n2. Handle OAuth callback and token exchange\n3. Store OAuth tokens securely in file system\n4. Implement automatic token refresh\n5. Handle token expiration gracefully\n6. Create web interface for OAuth setup\n\n## Technical Context\n\n### OAuth 2.0 Flow\n1. **Authorization Request**: Redirect user to Google's consent screen\n2. **Authorization Grant**: User approves access, Google redirects back with authorization code\n3. **Token Exchange**: Exchange authorization code for access token and refresh token\n4. **Token Storage**: Save tokens to file system\n5. **Token Usage**: Use access token to make API requests\n6. **Token Refresh**: Automatically refresh expired access tokens using refresh token\n\n## Implementation Steps\n\n### 1. Create OAuth Configuration\n\nUpdate `google_contacts_cisco/auth/__init__.py`:\n\n```python\n\"\"\"Authentication module.\"\"\"\nfrom .oauth import (\n    get_oauth_client,\n    get_credentials,\n    is_authenticated,\n    revoke_credentials,\n)\n\n__all__ = [\n    \"get_oauth_client\",\n    \"get_credentials\",\n    \"is_authenticated\",\n    \"revoke_credentials\",\n]\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Manual Testing**:\n   ```bash\n   # Start the application\n   uvicorn google_contacts_cisco.main:app --reload\n   \n   # Visit http://localhost:8000/auth/google\n   # - Should redirect to Google consent screen\n   # - Grant access\n   # - Should redirect back with success message\n   \n   # Check auth status\n   curl http://localhost:8000/auth/status\n   # Should return {\"authenticated\": true}\n   \n   # Check token file\n   ls -la data/token.json\n   # File should exist with 600 permissions\n   ```\n\n2. **Automated Tests**:\n   ```bash\n   pytest tests/test_oauth.py tests/test_oauth_api.py -v\n   ```\n\n3. **Token File Format**:\n   ```bash\n   cat data/token.json\n   # Should contain valid JSON with token, refresh_token, etc.\n   ```\n\n## Notes\n\n- **Refresh Token**: Google only provides refresh token on first authorization with `prompt=consent`\n- **Token Expiration**: Access tokens expire after 1 hour, refresh tokens are long-lived\n- **File Permissions**: Token file has 600 permissions (owner read/write only)\n- **Offline Access**: Using `access_type='offline'` to get refresh token\n- **Scope Changes**: If scopes change, user must re-authorize\n- **Error Handling**: Clear error messages guide users when OAuth fails\n\n## Security Best Practices\n\n1. Never log or expose tokens\n2. Store tokens with restricted file permissions (600)\n3. Validate redirect URI matches configuration\n4. Use HTTPS in production\n5. Handle token refresh before they expire\n6. Revoke tokens when no longer needed\n\n## Related Documentation\n\n- Google OAuth 2.0: https://developers.google.com/identity/protocols/oauth2\n- Google Python Auth Library: https://google-auth.readthedocs.io/\n- OAuth 2.0 RFC: https://tools.ietf.org/html/rfc6749\n- FastAPI OAuth: https://fastapi.tiangolo.com/advanced/security/\n\n## Estimated Time\n\n4-6 hours","acceptance_criteria":"☐ OAuth authorization flow redirects to Google correctly\n☐ Authorization callback handles the auth code properly\n☐ Tokens are exchanged successfully\n☐ Tokens are stored in file system with proper permissions\n☐ Token file is loaded on subsequent requests\n☐ Expired access tokens are refreshed automatically\n☐ Refresh token failures trigger re-authorization\n☐ Web page shows OAuth connection status\n☐ OAuth errors are handled gracefully with clear messages","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.105738785Z","created_by":"vscode","updated_at":"2026-01-08T03:26:31.785559819Z","closed_at":"2026-01-08T03:11:16.451329998Z","close_reason":"Closed","labels":["P0","auth","backend"]}
{"id":"google-contacts-cisco-31x","title":"End-to-End Tests","description":"# Unknown\n\n\n## Overview\n\nCreate end-to-end tests using Playwright to simulate real user workflows from the browser, testing the complete application stack including the Vue frontend, FastAPI backend, and database.\n\n## Priority\n\n**P2 (Medium)** - Important but not blocking for MVP\n\n## Dependencies\n\n- Task 7.2: Integration Tests\n- Task 6: Web Frontend (all tasks 15-19)\n\n## Objectives\n\n1. Set up Playwright for browser automation\n2. Test complete user workflows\n3. Test OAuth setup process\n4. Test contact browsing and filtering\n5. Test search functionality\n6. Test sync management\n7. Test on multiple browsers (Chromium, Firefox, WebKit)\n8. Create reusable page objects\n9. Generate test reports with screenshots\n\n## Technical Context\n\n### Playwright Features\n- Cross-browser testing (Chromium, Firefox, WebKit)\n- Auto-wait for elements\n- Screenshot and video recording\n- Network interception\n- Mobile device emulation\n\n## Implementation Steps\n\n### 1. Install Playwright\n\nUpdate `pyproject.toml`:\n\n```toml\n[project.optional-dependencies]\ndev = [\n    \"pytest\u003e=7.4.0\",\n    \"pytest-cov\u003e=4.1.0\",\n    \"pytest-asyncio\u003e=0.21.0\",\n    \"pytest-mock\u003e=3.12.0\",\n    \"playwright\u003e=1.40.0\",\n    \"pytest-playwright\u003e=0.4.3\",\n]\n```\n\nInstall and set up:\n\n```bash\nuv pip install playwright pytest-playwright\nuv run playwright install\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Install Playwright**:\n   ```bash\n   uv pip install playwright pytest-playwright\n   uv run playwright install\n   ```\n\n2. **Start Application**:\n   ```bash\n   # Terminal 1: Backend\n   uv run python -m google_contacts_cisco.main\n   \n   # Terminal 2: Frontend\n   cd frontend \u0026\u0026 npm run dev\n   ```\n\n3. **Run E2E Tests**:\n   ```bash\n   uv run pytest tests/e2e -v --headed\n   # Use --headed to see browser\n   ```\n\n4. **Run on Specific Browser**:\n   ```bash\n   uv run pytest tests/e2e --browser chromium\n   uv run pytest tests/e2e --browser firefox\n   uv run pytest tests/e2e --browser webkit\n   ```\n\n5. **Generate Test Report**:\n   ```bash\n   uv run pytest tests/e2e --html=test-results/report.html --self-contained-html\n   ```\n\n6. **Debug Mode**:\n   ```bash\n   PWDEBUG=1 uv run pytest tests/e2e -v\n   # Opens Playwright Inspector\n   ```\n\n## Notes\n\n- **Page Objects**: Reusable page abstractions\n- **Auto-wait**: Playwright waits automatically for elements\n- **Screenshots**: Captured on test failures\n- **Videos**: Recorded for failed tests\n- **Multi-browser**: Tests run on Chromium, Firefox, WebKit\n- **Headless**: Run without visible browser for CI/CD\n- **Debugging**: Use PWDEBUG=1 for step-through debugging\n\n## Common Issues\n\n1. **Timeouts**: Increase timeout for slow operations\n2. **Element Not Found**: Wait for element before interacting\n3. **Flaky Tests**: Add proper waits, avoid hardcoded sleeps\n4. **Browser Not Installed**: Run `playwright install`\n5. **Port Conflicts**: Ensure app is running on correct port\n\n## Best Practices\n\n- Use page objects for maintainability\n- Test user workflows, not implementation\n- Use descriptive test names\n- Take screenshots on failures\n- Avoid hardcoded waits\n- Test on multiple browsers\n- Use semantic selectors (data-testid)\n- Clean up after tests\n\n## Related Documentation\n\n- Playwright Python: https://playwright.dev/python/\n- pytest-playwright: https://github.com/microsoft/playwright-pytest\n- Page Object Pattern: https://playwright.dev/python/docs/pom\n\n## Estimated Time\n\n6-8 hours","acceptance_criteria":"☐ Playwright is configured and working\n☐ User workflows are tested end-to-end\n☐ OAuth flow is tested (with mocks)\n☐ Contact browsing works in browser\n☐ Search functionality works in browser\n☐ Sync management UI is tested\n☐ Tests run on multiple browsers\n☐ Screenshots captured on failures\n☐ Test reports generated\n☐ Tests are maintainable with page objects","notes":"- **Page Objects**: Reusable page abstractions\n- **Auto-wait**: Playwright waits automatically for elements\n- **Screenshots**: Captured on test failures\n- **Videos**: Recorded for failed tests\n- **Multi-browser**: Tests run on Chromium, Firefox, WebKit\n- **Headless**: Run without visible browser for CI/CD\n- **Debugging**: Use PWDEBUG=1 for step-through debugging\n\n\n**Related Files:**\n\n- See `.ai/planning/tasks/` for complete implementation guide\n\n- Includes code examples, test suites, and verification steps","status":"open","priority":2,"issue_type":"task","estimated_minutes":360,"created_at":"2026-01-08T03:10:59.551874113Z","created_by":"vscode","updated_at":"2026-01-08T03:26:36.157453832Z","labels":["P2","e2e","testing"]}
{"id":"google-contacts-cisco-44p","title":"Google API Client","description":"# Unknown\n\n\n## Overview\n\nCreate a wrapper around the Google People API client to handle contact retrieval, pagination, error handling, and rate limiting. This client will be used by the sync service to fetch contacts from Google.\n\n## Priority\n\n**P0 (Critical)** - Required for MVP\n\n## Dependencies\n\n- Task 2.1: OAuth 2.0 Implementation\n- Task 1.2: Database Setup (for testing)\n\n## Objectives\n\n1. Create Google People API client wrapper\n2. Implement contact list retrieval with pagination\n3. Implement error handling with retries and exponential backoff\n4. Implement rate limit handling\n5. Follow Google API best practices (sequential requests)\n6. Create connection testing functionality\n\n## Technical Context\n\n### Google People API v1\n- **Base URL**: `https://people.googleapis.com/v1`\n- **Endpoint**: `/people/me/connections`\n- **Person Fields**: names, emailAddresses, phoneNumbers, organizations, metadata\n- **Page Size**: Up to 1000 contacts per page (recommended: 100-500)\n- **Pagination**: Use `pageToken` from response\n- **Sync Token**: For incremental updates\n\n## Implementation Steps\n\n### 1. Create Google API Client Service\n\nCreate `google_contacts_cisco/services/google_client.py`:\n\n```python\n\"\"\"Google People API client.\"\"\"\nimport time\nfrom typing import Iterator, Optional, List, Dict, Any\n\nfrom googleapiclient.discovery import build\nfrom googleapiclient.errors import HttpError\nfrom google.oauth2.credentials import Credentials\n\nfrom ..auth.oauth import get_credentials\nfrom ..utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\n\n# Person fields to retrieve from Google Contacts\nPERSON_FIELDS = [\n    \"names\",\n    \"emailAddresses\",\n    \"phoneNumbers\",\n    \"organizations\",\n    \"metadata\",\n]\n\n\nclass GoogleContactsClient:\n    \"\"\"Client for Google People API.\"\"\"\n    \n    def __init__(self, credentials: Optional[Credentials] = None):\n        \"\"\"Initialize Google Contacts client.\n        \n        Args:\n            credentials: OAuth credentials (if None, loads from storage)\n        \"\"\"\n        self.credentials = credentials or get_credentials()\n        if not self.credentials:\n            raise ValueError(\"No valid credentials available. Please authenticate first.\")\n        \n        self.service = build('people', 'v1', credentials=self.credentials)\n        self.max_retries = 5\n        self.initial_backoff = 1.0  # seconds\n    \n    def list_connections(\n        self,\n        page_size: int = 100,\n        sync_token: Optional[str] = None,\n    ) -\u003e Iterator[Dict[str, Any]]:\n        \"\"\"List all connections with pagination.\n        \n        Args:\n            page_size: Number of contacts per page (max 1000)\n            sync_token: Token for incremental sync (if available)\n            \n        Yields:\n            Dictionary containing 'connections' list and 'syncToken'\n            \n        Raises:\n            HttpError: If API request fails after retries\n        \"\"\"\n        page_token = None\n        request_count = 0\n        \n        while True:\n            try:\n                # Build request\n                request_params = {\n                    'resourceName': 'people/me',\n                    'pageSize': page_size,\n                    'personFields': ','.join(PERSON_FIELDS),\n                }\n                \n                if sync_token:\n                    request_params['syncToken'] = sync_token\n                    request_params['requestSyncToken'] = True\n                else:\n                    request_params['requestSyncToken'] = True\n                \n                if page_token:\n                    request_params['pageToken'] = page_token\n                \n                # Make request with retry logic\n                response = self._make_request_with_retry(\n                    lambda: self.service.people().connections().list(**request_params).execute()\n                )\n                \n                request_count += 1\n                logger.info(f\"Retrieved page {request_count} ({len(response.get('connections', []))} contacts)\")\n                \n                yield response\n                \n                # Check if there are more pages\n                page_token = response.get('nextPageToken')\n                if not page_token:\n                    break\n                \n                # Small delay between requests (sequential, as recommended by Google)\n                time.sleep(0.1)\n                \n            except HttpError as e:\n                if e.resp.status == 410:\n                    # Sync token expired\n                    logger.warning(\"Sync token expired, need to do full sync\")\n                    raise\n                else:\n                    logger.error(f\"Error listing connections: {e}\")\n                    raise\n    \n    def get_person(self, resource_name: str) -\u003e Dict[str, Any]:\n        \"\"\"Get a single person by resource name.\n        \n        Args:\n            resource_name: Person's resource name (e.g., 'people/12345')\n            \n        Returns:\n            Person data dictionary\n            \n        Raises:\n            HttpError: If API request fails\n        \"\"\"\n        try:\n            person = self._make_request_with_retry(\n                lambda: self.service.people().get(\n                    resourceName=resource_name,\n                    personFields=','.join(PERSON_FIELDS)\n                ).execute()\n            )\n            return person\n        except HttpError as e:\n            logger.error(f\"Error getting person {resource_name}: {e}\")\n            raise\n    \n    def test_connection(self) -\u003e bool:\n        \"\"\"Test connection to Google People API.\n        \n        Returns:\n            True if connection successful\n            \n        Raises:\n            Exception: If connection fails\n        \"\"\"\n        try:\n            # Try to get just one contact\n            result = self.service.people().connections().list(\n                resourceName='people/me',\n                pageSize=1,\n                personFields='names'\n            ).execute()\n            \n            logger.info(\"Successfully connected to Google People API\")\n            return True\n        except HttpError as e:\n            logger.error(f\"Connection test failed: {e}\")\n            raise\n    \n    def _make_request_with_retry(self, request_func, retry_count: int = 0):\n        \"\"\"Make API request with retry logic.\n        \n        Args:\n            request_func: Function that makes the API request\n            retry_count: Current retry attempt\n            \n        Returns:\n            API response\n            \n        Raises:\n            HttpError: If request fails after all retries\n        \"\"\"\n        try:\n            return request_func()\n        except HttpError as e:\n            if e.resp.status == 429:  # Rate limit\n                if retry_count \u003c self.max_retries:\n                    backoff = self.initial_backoff * (2 ** retry_count)\n                    logger.warning(f\"Rate limit hit, backing off for {backoff} seconds\")\n                    time.sleep(backoff)\n                    return self._make_request_with_retry(request_func, retry_count + 1)\n                else:\n                    logger.error(\"Max retries exceeded for rate limit\")\n                    raise\n            elif e.resp.status \u003e= 500:  # Server error\n                if retry_count \u003c self.max_retries:\n                    backoff = self.initial_backoff * (2 ** retry_count)\n                    logger.warning(f\"Server error {e.resp.status}, retrying in {backoff} seconds\")\n                    time.sleep(backoff)\n                    return self._make_request_with_retry(request_func, retry_count + 1)\n                else:\n                    logger.error(\"Max retries exceeded for server error\")\n                    raise\n            elif e.resp.status == 401:  # Unauthorized\n                logger.error(\"Unauthorized - credentials may have expired\")\n                raise\n            else:\n                # Other errors, don't retry\n                raise\n\n\ndef get_google_client(credentials: Optional[Credentials] = None) -\u003e GoogleContactsClient:\n    \"\"\"Get Google Contacts client instance.\n    \n    Args:\n        credentials: OAuth credentials (if None, loads from storage)\n        \n    Returns:\n        GoogleContactsClient instance\n    \"\"\"\n    return GoogleContactsClient(credentials)\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Test Connection**:\n   ```bash\n   # Start app\n   uvicorn google_contacts_cisco.main:app --reload\n   \n   # Authenticate first\n   curl http://localhost:8000/auth/google\n   \n   # Test connection\n   curl http://localhost:8000/api/test-connection\n   # Should return success\n   ```\n\n2. **Run Tests**:\n   ```bash\n   pytest tests/test_google_client.py -v\n   ```\n\n3. **Manual API Test** (with Python):\n   ```python\n   from google_contacts_cisco.services.google_client import get_google_client\n   \n   client = get_google_client()\n   \n   # Test connection\n   client.test_connection()\n   \n   # Get first page of contacts\n   for response in client.list_connections(page_size=10):\n       print(f\"Got {len(response['connections'])} contacts\")\n       break\n   ```\n\n## Notes\n\n- **Sequential Requests**: Google recommends sequential (not parallel) requests to avoid rate limits\n- **Pagination**: Use `nextPageToken` to get subsequent pages\n- **Sync Token**: Store and use for incremental updates (Task 3.2)\n- **Person Fields**: Only request fields you need to reduce response size\n- **Rate Limits**: Implement exponential backoff for 429 errors\n- **Error Logging**: Log all errors with context for debugging\n\n## Common Issues\n\n1. **401 Unauthorized**: Credentials expired, need to re-authenticate\n2. **429 Rate Limit**: Sending requests too fast, increase delays\n3. **410 Sync Token Expired**: Need to do full sync, can't use incremental\n4. **500 Server Errors**: Google's temporary issue, retry with backoff\n\n## Related Documentation\n\n- Google People API: https://developers.google.com/people\n- People API Reference: https://developers.google.com/people/api/rest/v1/people.connections/list\n- API Quotas: https://developers.google.com/people/v1/how-tos/quota\n- Error Handling: https://developers.google.com/people/v1/how-tos/errors\n\n## Estimated Time\n\n4-5 hours","acceptance_criteria":"☑ Client successfully connects to Google People API\n☑ Client retrieves person fields correctly\n☑ Pagination handles multiple pages of contacts\n☑ Pagination stops when no more pages exist\n☑ Rate limit errors (429) trigger exponential backoff\n☑ Server errors (500+) trigger retries\n☑ Auth errors (401) are handled properly\n☑ Client respects Google's sequential request recommendation\n☑ Connection can be tested without syncing data\n☑ All API errors are logged with context","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.138691068Z","created_by":"vscode","updated_at":"2026-01-08T03:26:32.059669684Z","closed_at":"2026-01-08T03:11:16.453601425Z","close_reason":"Closed","labels":["P0","backend","google-api"]}
{"id":"google-contacts-cisco-456","title":"Full Sync Implementation","description":"# Unknown\n\n\n## Overview\n\nImplement the initial full synchronization of contacts from Google to the local database. This includes downloading all contacts, parsing them, and storing them in the database with proper error handling.\n\n## Priority\n\n**P0 (Critical)** - Required for MVP\n\n## Dependencies\n\n- Task 2.2: Google API Client\n- Task 2.3: Contact Data Models\n- Task 1.2: Database Setup\n\n## Objectives\n\n1. Implement full contact download from Google\n2. Handle pagination for large contact lists\n3. Parse and transform contact data\n4. Store contacts in database\n5. Store sync token for future incremental syncs\n6. Handle errors gracefully\n7. Track sync progress and status\n8. Test with real Google account\n\n## Technical Context\n\n### Full Sync Process\n1. Request all contacts from Google People API\n2. Iterate through pages (pagination)\n3. Transform each contact from Google format to internal format\n4. Insert/update contacts in database\n5. Store sync token from last page\n6. Mark sync as complete\n\n## Implementation Steps\n\n### 1. Create Contact Repository\n\nCreate `google_contacts_cisco/repositories/contact_repository.py`:\n\n```python\n\"\"\"Contact repository for database operations.\"\"\"\nfrom typing import List, Optional\nfrom datetime import datetime\nfrom uuid import UUID\n\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import or_\n\nfrom ..models.contact import Contact\nfrom ..models.phone_number import PhoneNumber\nfrom ..schemas.contact import ContactCreateSchema, PhoneNumberSchema\n\n\nclass ContactRepository:\n    \"\"\"Repository for contact database operations.\"\"\"\n    \n    def __init__(self, db: Session):\n        \"\"\"Initialize repository.\n        \n        Args:\n            db: Database session\n        \"\"\"\n        self.db = db\n    \n    def create_contact(self, contact_data: ContactCreateSchema) -\u003e Contact:\n        \"\"\"Create a new contact.\n        \n        Args:\n            contact_data: Contact data to create\n            \n        Returns:\n            Created contact\n        \"\"\"\n        # Create contact\n        contact = Contact(\n            resource_name=contact_data.resource_name,\n            etag=contact_data.etag,\n            given_name=contact_data.given_name,\n            family_name=contact_data.family_name,\n            display_name=contact_data.display_name,\n            organization=contact_data.organization,\n            job_title=contact_data.job_title,\n            deleted=contact_data.deleted,\n            synced_at=datetime.utcnow()\n        )\n        \n        self.db.add(contact)\n        self.db.flush()  # Get contact ID\n        \n        # Add phone numbers\n        for phone_data in contact_data.phone_numbers:\n            phone = PhoneNumber(\n                contact_id=contact.id,\n                value=phone_data.value,\n                display_value=phone_data.display_value,\n                type=phone_data.type,\n                primary=phone_data.primary\n            )\n            self.db.add(phone)\n        \n        return contact\n    \n    def get_by_resource_name(self, resource_name: str) -\u003e Optional[Contact]:\n        \"\"\"Get contact by Google resource name.\n        \n        Args:\n            resource_name: Google resource name\n            \n        Returns:\n            Contact or None if not found\n        \"\"\"\n        return self.db.query(Contact).filter(\n            Contact.resource_name == resource_name\n        ).first()\n    \n    def upsert_contact(self, contact_data: ContactCreateSchema) -\u003e Contact:\n        \"\"\"Insert or update contact.\n        \n        Args:\n            contact_data: Contact data\n            \n        Returns:\n            Created or updated contact\n        \"\"\"\n        existing = self.get_by_resource_name(contact_data.resource_name)\n        \n        if existing:\n            # Update existing contact\n            existing.etag = contact_data.etag\n            existing.given_name = contact_data.given_name\n            existing.family_name = contact_data.family_name\n            existing.display_name = contact_data.display_name\n            existing.organization = contact_data.organization\n            existing.job_title = contact_data.job_title\n            existing.deleted = contact_data.deleted\n            existing.synced_at = datetime.utcnow()\n            existing.updated_at = datetime.utcnow()\n            \n            # Delete old phone numbers\n            self.db.query(PhoneNumber).filter(\n                PhoneNumber.contact_id == existing.id\n            ).delete()\n            \n            # Add new phone numbers\n            for phone_data in contact_data.phone_numbers:\n                phone = PhoneNumber(\n                    contact_id=existing.id,\n                    value=phone_data.value,\n                    display_value=phone_data.display_value,\n                    type=phone_data.type,\n                    primary=phone_data.primary\n                )\n                self.db.add(phone)\n            \n            return existing\n        else:\n            # Create new contact\n            return self.create_contact(contact_data)\n    \n    def get_all_active(self) -\u003e List[Contact]:\n        \"\"\"Get all non-deleted contacts.\n        \n        Returns:\n            List of active contacts\n        \"\"\"\n        return self.db.query(Contact).filter(\n            Contact.deleted == False\n        ).all()\n    \n    def count_all(self) -\u003e int:\n        \"\"\"Count all contacts.\n        \n        Returns:\n            Total contact count\n        \"\"\"\n        return self.db.query(Contact).count()\n    \n    def count_active(self) -\u003e int:\n        \"\"\"Count active (non-deleted) contacts.\n        \n        Returns:\n            Active contact count\n        \"\"\"\n        return self.db.query(Contact).filter(\n            Contact.deleted == False\n        ).count()\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Trigger Full Sync**:\n   ```bash\n   # Via API\n   curl -X POST http://localhost:8000/api/sync/full\n   \n   # Should return success with statistics\n   ```\n\n2. **Check Sync Status**:\n   ```bash\n   curl http://localhost:8000/api/sync/status\n   \n   # Should show contact count and last sync time\n   ```\n\n3. **Verify Database**:\n   ```bash\n   sqlite3 data/contacts.db\n   SELECT COUNT(*) FROM contacts;\n   SELECT COUNT(*) FROM phone_numbers;\n   SELECT * FROM sync_states ORDER BY last_sync_at DESC LIMIT 1;\n   ```\n\n4. **Run Tests**:\n   ```bash\n   pytest tests/test_full_sync.py -v\n   ```\n\n## Notes\n\n- **Batch Commits**: Commits every 100 contacts to avoid memory issues\n- **Sequential Requests**: Small delays between API requests\n- **Upsert Logic**: Updates existing contacts, inserts new ones\n- **Sync Token**: Stored for future incremental syncs\n- **Error Handling**: Individual contact errors don't stop entire sync\n- **Progress Tracking**: Logs progress every batch\n\n## Common Issues\n\n1. **Memory Issues**: Reduce batch size if syncing many contacts\n2. **Rate Limits**: Increase delay between requests if hitting limits\n3. **Duplicate Phone Numbers**: Handled by deleting old, inserting new\n4. **Large Contacts**: Some contacts have many phone numbers/emails\n\n## Related Documentation\n\n- Google People API Sync: https://developers.google.com/people/v1/contacts#sync\n- SQLAlchemy Bulk Operations: https://docs.sqlalchemy.org/en/20/orm/session_api.html\n\n## Estimated Time\n\n4-6 hours","acceptance_criteria":"☐ Full sync downloads all contacts successfully\n☐ Pagination handles multiple pages correctly\n☐ Contacts are transformed and stored properly\n☐ Phone numbers are normalized and stored\n☐ Sync token is stored for future incremental syncs\n☐ Progress is tracked and can be queried\n☐ Errors during sync are logged and recoverable\n☐ Duplicate contacts are handled (upsert logic)\n☐ Sync can be interrupted and resumed\n☐ Tests verify sync logic with mock data","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.204498398Z","created_by":"vscode","updated_at":"2026-01-08T03:26:32.602533217Z","closed_at":"2026-01-08T03:11:16.460795395Z","close_reason":"Closed","labels":["P0","backend","sync"]}
{"id":"google-contacts-cisco-4j6","title":"Testing: No integration tests for sync error recovery","description":"## Problem\nSync service has complex error handling but no integration tests:\n1. No tests for partial sync failure recovery\n2. Missing tests for Google API rate limiting\n3. No tests for network timeout during sync\n4. Missing tests for database connection loss mid-sync\n5. No tests for sync token expiration handling\n\n## Untested Error Scenarios\n```python\n# sync_service.py error paths not tested:\n- Sync fails after 5000 contacts synced (partial success)\n- Google API returns 503 mid-sync\n- Database connection drops during batch commit\n- Sync token expires during incremental sync (410)\n- Rate limit hit during page 10 of 50\n```\n\n## Critical Gaps\n1. **Partial Failure**: What happens if sync fails halfway?\n2. **Data Consistency**: Are committed batches rolled back?\n3. **Resume Capability**: Can sync resume from failure point?\n4. **Error Reporting**: Are partial sync results reported?\n5. **State Corruption**: Does failure corrupt sync state?\n\n## Impact\n- **Production Failures**: Unknown behavior on errors\n- **Data Integrity**: Risk of partial/corrupted syncs\n- **User Experience**: No feedback on partial failures\n- **Debugging**: Hard to reproduce sync issues\n\n## Required Fix\n1. Create integration test suite for sync errors\n2. Mock Google API failures at various points\n3. Test database connection loss scenarios\n4. Test sync state consistency after failures\n5. Test resume/recovery after partial failure\n6. Add smoke tests for common error patterns\n7. Document error recovery behavior\n\n## Test Cases Needed\n```python\ndef test_sync_fails_after_partial_success():\ndef test_sync_handles_rate_limit_gracefully():\ndef test_sync_token_expiration_triggers_full_sync():\ndef test_database_connection_loss_during_sync():\ndef test_sync_state_consistent_after_failure():\ndef test_concurrent_sync_prevented():\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T21:21:19.561929519-08:00","created_by":"rohan","updated_at":"2026-01-09T21:21:19.561929519-08:00","labels":["backend","integration","sync","testing"]}
{"id":"google-contacts-cisco-5bv","title":"Search Service Implementation","description":"# Unknown\n\n\n## Overview\n\nImplement a search service that provides full-text search across contact names and phone numbers. This service will support searching by name (partial matches), phone number, and combined queries.\n\n## Priority\n\n**P1 (High)** - Required for both Cisco phone and web interface search\n\n## Dependencies\n\n- Task 1.2: Database Setup\n- Task 2.1: Contact Data Models\n- Task 5.1: Phone Number Normalization\n\n## Objectives\n\n1. Implement full-text search for contact names\n2. Implement phone number search using normalization\n3. Support partial name matching\n4. Combine name and phone search results\n5. Rank search results by relevance\n6. Optimize for performance (sub-250ms response time)\n7. Handle edge cases (empty queries, special characters)\n8. Add comprehensive tests\n\n## Technical Context\n\n### Search Requirements\n- **Name Search**: Case-insensitive, partial matching, prefix and substring\n- **Phone Search**: Normalized comparison, partial matching (last N digits)\n- **Performance**: \u003c 250ms for 10,000 contacts\n- **Ranking**: Exact matches first, then prefix matches, then substring\n\n## Implementation Steps\n\n### 1. Create Search Service\n\nCreate `google_contacts_cisco/services/search_service.py`:\n\n```python\n\"\"\"Contact search service.\"\"\"\nfrom typing import List, Optional, Dict, Any\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import or_, func\n\nfrom ..models.contact import Contact\nfrom ..models.phone_number import PhoneNumber\nfrom ..repositories.contact_repository import ContactRepository\nfrom ..utils.phone_utils import get_phone_normalizer\nfrom ..utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass SearchResult:\n    \"\"\"Search result container.\"\"\"\n    \n    def __init__(self, contact: Contact, match_type: str, match_field: str = \"\"):\n        \"\"\"Initialize search result.\n        \n        Args:\n            contact: Matched contact\n            match_type: Type of match (exact, prefix, substring, phone)\n            match_field: Field that matched (name, phone)\n        \"\"\"\n        self.contact = contact\n        self.match_type = match_type\n        self.match_field = match_field\n        self.relevance_score = self._calculate_score()\n    \n    def _calculate_score(self) -\u003e int:\n        \"\"\"Calculate relevance score for ranking.\n        \n        Returns:\n            Score (higher is more relevant)\n        \"\"\"\n        scores = {\n            \"exact\": 100,\n            \"prefix\": 50,\n            \"substring\": 25,\n            \"phone\": 75,\n        }\n        return scores.get(self.match_type, 0)\n    \n    def to_dict(self) -\u003e Dict[str, Any]:\n        \"\"\"Convert to dictionary.\n        \n        Returns:\n            Dictionary representation\n        \"\"\"\n        return {\n            \"id\": str(self.contact.id),\n            \"display_name\": self.contact.display_name,\n            \"given_name\": self.contact.given_name,\n            \"family_name\": self.contact.family_name,\n            \"phone_numbers\": [\n                {\n                    \"value\": phone.value,\n                    \"display_value\": phone.display_value,\n                    \"type\": phone.type,\n                    \"primary\": phone.primary,\n                }\n                for phone in self.contact.phone_numbers\n            ],\n            \"email_addresses\": [\n                {\n                    \"value\": email.value,\n                    \"type\": email.type,\n                    \"primary\": email.primary,\n                }\n                for email in self.contact.email_addresses\n            ],\n            \"match_type\": self.match_type,\n            \"match_field\": self.match_field,\n        }\n\n\nclass SearchService:\n    \"\"\"Service for searching contacts.\"\"\"\n    \n    def __init__(self, db: Session):\n        \"\"\"Initialize search service.\n        \n        Args:\n            db: Database session\n        \"\"\"\n        self.db = db\n        self.repository = ContactRepository(db)\n        self.phone_normalizer = get_phone_normalizer()\n    \n    def search(\n        self,\n        query: str,\n        max_results: int = 50\n    ) -\u003e List[SearchResult]:\n        \"\"\"Search contacts by name or phone number.\n        \n        Args:\n            query: Search query\n            max_results: Maximum results to return\n            \n        Returns:\n            List of search results, ranked by relevance\n        \"\"\"\n        if not query or not query.strip():\n            return []\n        \n        query = query.strip()\n        logger.info(f\"Searching for: {query}\")\n        \n        results = []\n        seen_ids = set()\n        \n        # Try phone search first (if query looks like a phone number)\n        if self._looks_like_phone(query):\n            phone_results = self._search_by_phone(query)\n            for contact in phone_results:\n                if contact.id not in seen_ids:\n                    results.append(SearchResult(contact, \"phone\", \"phone_number\"))\n                    seen_ids.add(contact.id)\n        \n        # Name search\n        name_results = self._search_by_name(query)\n        for contact, match_type in name_results:\n            if contact.id not in seen_ids:\n                results.append(SearchResult(contact, match_type, \"display_name\"))\n                seen_ids.add(contact.id)\n        \n        # Sort by relevance\n        results.sort(key=lambda r: r.relevance_score, reverse=True)\n        \n        logger.info(f\"Found {len(results)} results for query: {query}\")\n        return results[:max_results]\n    \n    def search_by_name(\n        self,\n        name: str,\n        max_results: int = 50\n    ) -\u003e List[SearchResult]:\n        \"\"\"Search contacts by name only.\n        \n        Args:\n            name: Name to search\n            max_results: Maximum results to return\n            \n        Returns:\n            List of search results\n        \"\"\"\n        if not name or not name.strip():\n            return []\n        \n        name = name.strip()\n        logger.info(f\"Searching by name: {name}\")\n        \n        results = []\n        seen_ids = set()\n        \n        name_results = self._search_by_name(name)\n        for contact, match_type in name_results:\n            if contact.id not in seen_ids:\n                results.append(SearchResult(contact, match_type, \"display_name\"))\n                seen_ids.add(contact.id)\n        \n        results.sort(key=lambda r: r.relevance_score, reverse=True)\n        return results[:max_results]\n    \n    def search_by_phone(\n        self,\n        phone: str,\n        max_results: int = 50\n    ) -\u003e List[SearchResult]:\n        \"\"\"Search contacts by phone number only.\n        \n        Args:\n            phone: Phone number to search\n            max_results: Maximum results to return\n            \n        Returns:\n            List of search results\n        \"\"\"\n        if not phone or not phone.strip():\n            return []\n        \n        phone = phone.strip()\n        logger.info(f\"Searching by phone: {phone}\")\n        \n        results = []\n        contacts = self._search_by_phone(phone)\n        \n        for contact in contacts:\n            results.append(SearchResult(contact, \"phone\", \"phone_number\"))\n        \n        return results[:max_results]\n    \n    def _search_by_name(self, name: str) -\u003e List[tuple[Contact, str]]:\n        \"\"\"Internal name search with match type.\n        \n        Args:\n            name: Name to search\n            \n        Returns:\n            List of (Contact, match_type) tuples\n        \"\"\"\n        results = []\n        name_lower = name.lower()\n        \n        # Exact match on display name\n        exact_matches = (\n            self.db.query(Contact)\n            .filter(\n                Contact.deleted == False,\n                func.lower(Contact.display_name) == name_lower\n            )\n            .all()\n        )\n        results.extend((c, \"exact\") for c in exact_matches)\n        \n        # Get IDs we've already matched\n        matched_ids = {c.id for c, _ in results}\n        \n        # Prefix match on display name\n        prefix_matches = (\n            self.db.query(Contact)\n            .filter(\n                Contact.deleted == False,\n                Contact.id.notin_(matched_ids) if matched_ids else True,\n                func.lower(Contact.display_name).like(f\"{name_lower}%\")\n            )\n            .all()\n        )\n        results.extend((c, \"prefix\") for c in prefix_matches)\n        matched_ids.update(c.id for c in prefix_matches)\n        \n        # Substring match on display name, given name, or family name\n        substring_matches = (\n            self.db.query(Contact)\n            .filter(\n                Contact.deleted == False,\n                Contact.id.notin_(matched_ids) if matched_ids else True,\n                or_(\n                    func.lower(Contact.display_name).like(f\"%{name_lower}%\"),\n                    func.lower(Contact.given_name).like(f\"%{name_lower}%\"),\n                    func.lower(Contact.family_name).like(f\"%{name_lower}%\")\n                )\n            )\n            .all()\n        )\n        results.extend((c, \"substring\") for c in substring_matches)\n        \n        return results\n    \n    def _search_by_phone(self, phone: str) -\u003e List[Contact]:\n        \"\"\"Internal phone search.\n        \n        Args:\n            phone: Phone number to search\n            \n        Returns:\n            List of matching contacts\n        \"\"\"\n        return self.repository.search_by_phone(phone)\n    \n    def _looks_like_phone(self, query: str) -\u003e bool:\n        \"\"\"Check if query looks like a phone number.\n        \n        Args:\n            query: Search query\n            \n        Returns:\n            True if query appears to be a phone number\n        \"\"\"\n        # Remove common phone separators\n        digits = ''.join(c for c in query if c.isdigit())\n        \n        # If mostly digits and has at least 7 digits, treat as phone\n        if len(digits) \u003e= 7 and len(digits) \u003e= len(query) * 0.5:\n            return True\n        \n        # Check for + prefix (international)\n        if query.startswith('+') and len(digits) \u003e= 10:\n            return True\n        \n        return False\n\n\ndef get_search_service(db: Session) -\u003e SearchService:\n    \"\"\"Get search service instance.\n    \n    Args:\n        db: Database session\n        \n    Returns:\n        SearchService instance\n    \"\"\"\n    return SearchService(db)\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Test Basic Search**:\n   ```python\n   from google_contacts_cisco.models import get_db\n   from google_contacts_cisco.services.search_service import get_search_service\n   \n   db = next(get_db())\n   search = get_search_service(db)\n   \n   # Search by name\n   results = search.search(\"John\")\n   for result in results:\n       print(f\"{result.contact.display_name} ({result.match_type})\")\n   \n   # Search by phone\n   results = search.search(\"555-123-4567\")\n   for result in results:\n       print(f\"{result.contact.display_name} - {result.match_field}\")\n   ```\n\n2. **Test Performance**:\n   ```python\n   import time\n   \n   start = time.time()\n   results = search.search(\"test query\")\n   elapsed = time.time() - start\n   print(f\"Search took {elapsed*1000:.2f}ms\")\n   # Should be \u003c 250ms\n   ```\n\n3. **Run Tests**:\n   ```bash\n   uv run pytest tests/test_search_service.py -v\n   ```\n\n## Notes\n\n- **Relevance Ranking**: Exact \u003e Prefix \u003e Substring\n- **Deduplication**: Contact appears once even if matched multiple ways\n- **Performance**: Optimized with proper indexes on name fields\n- **Case Sensitivity**: All searches are case-insensitive\n- **Partial Matching**: Supports both prefix and substring\n- **Phone Detection**: Heuristic-based (mostly digits, length check)\n- **Max Results**: Default 50, configurable\n- **Deleted Contacts**: Automatically filtered out\n\n## Common Issues\n\n1. **Slow Searches**: Add indexes on name fields\n2. **False Phone Matches**: Adjust `_looks_like_phone()` heuristic\n3. **Ranking Issues**: Tune relevance scores\n4. **Memory Usage**: Limit max_results for large datasets\n5. **Special Characters**: SQL LIKE escaping\n\n## Performance Optimization\n\nIf searches are slow:\n1. Add database indexes\n2. Consider SQLite FTS5 for full-text search\n3. Cache frequent queries\n4. Limit substring matching to queries \u003e 3 chars\n\n## Related Documentation\n\n- SQLite LIKE: https://www.sqlite.org/lang_expr.html#like\n- SQLite FTS5: https://www.sqlite.org/fts5.html\n- Full-Text Search: https://www.sqlite.org/fts3.html\n\n## Estimated Time\n\n5-6 hours","acceptance_criteria":"☐ Name search supports partial matches\n☐ Phone search handles various formats\n☐ Search results are ranked by relevance\n☐ Performance meets \u003c 250ms target\n☐ Empty queries return no results\n☐ Special characters are handled safely\n☐ Results include contact details and phone numbers\n☐ Tests cover all search scenarios\n☐ Deduplication of results","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":300,"created_at":"2026-01-08T03:10:59.422445291Z","created_by":"vscode","updated_at":"2026-01-08T04:57:55.124224813Z","closed_at":"2026-01-08T04:57:55.124224813Z","close_reason":"Closed","labels":["P0","backend","search"]}
{"id":"google-contacts-cisco-5s0","title":"Configuration Management","description":"# Unknown\n\n\n## Overview\n\nSet up configuration management system using Pydantic Settings for type-safe, environment-based configuration.\n\n## Priority\n\n**P0 (Critical)** - Required for MVP\n\n## Dependencies\n\n- Task 1.1: Environment Setup (must be completed first)\n\n## Objectives\n\n1. Set up environment variable handling with python-dotenv\n2. Create type-safe configuration schema with Pydantic\n3. Create `.env.example` template\n4. Document all configuration options\n5. Implement configuration validation\n\n## Technical Context\n\n### Configuration Sources (Priority Order)\n1. Environment variables\n2. `.env` file\n3. Default values\n\n## Implementation Steps\n\n### 1. Enhance config.py\n\nUpdate `google_contacts_cisco/config.py`:\n\n```python\n\"\"\"Application configuration.\"\"\"\nfrom pathlib import Path\nfrom typing import Optional\nfrom pydantic import Field, validator\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    \"\"\"Application settings loaded from environment variables or .env file.\"\"\"\n    \n    # Application Settings\n    app_name: str = \"Google Contacts Cisco Directory\"\n    debug: bool = False\n    log_level: str = \"INFO\"\n    host: str = \"0.0.0.0\"\n    port: int = 8000\n    \n    # Database Settings\n    database_url: str = \"sqlite:///./data/contacts.db\"\n    database_echo: bool = False  # Log SQL queries\n    \n    # Google OAuth Settings\n    google_client_id: Optional[str] = None\n    google_client_secret: Optional[str] = None\n    google_oauth_scopes: list[str] = Field(\n        default_factory=lambda: [\n            \"https://www.googleapis.com/auth/contacts.readonly\"\n        ]\n    )\n    google_redirect_uri: str = \"http://localhost:8000/auth/callback\"\n    google_token_file: str = \"./data/token.json\"\n    \n    # Application Security (Optional)\n    # Note: For this single-user application with file-based OAuth token storage,\n    # a secret key may not be necessary. Include it if you plan to add:\n    # - Multi-user sessions\n    # - Signed cookies\n    # - CSRF protection for forms\n    secret_key: Optional[str] = Field(\n        default=None,\n        description=\"Secret key for session management (optional for single-user app)\"\n    )\n    \n    # Cisco Directory Settings\n    directory_max_entries_per_page: int = 32  # Max entries per Cisco XML page\n    directory_title: str = \"Google Contacts\"\n    \n    # Sync Settings\n    sync_batch_size: int = 100  # Number of contacts to process per batch\n    sync_delay_seconds: float = 0.1  # Delay between API requests\n    \n    # Search Settings\n    search_results_limit: int = 50  # Max search results to return\n    \n    model_config = SettingsConfigDict(\n        env_file=\".env\",\n        env_file_encoding=\"utf-8\",\n        case_sensitive=False,\n        extra=\"ignore\"  # Ignore extra environment variables\n    )\n    \n    @validator(\"log_level\")\n    def validate_log_level(cls, v):\n        \"\"\"Validate log level.\"\"\"\n        valid_levels = [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n        v = v.upper()\n        if v not in valid_levels:\n            raise ValueError(f\"Log level must be one of: {', '.join(valid_levels)}\")\n        return v\n    \n    # Note: Removed secret_key validator since it's optional for this single-user application\n    # If you add session management later, uncomment and use this validator:\n    # @validator(\"secret_key\")\n    # def validate_secret_key(cls, v, values):\n    #     \"\"\"Validate secret key in production.\"\"\"\n    #     if not values.get(\"debug\", False) and (v is None or v == \"change-me-in-production-to-a-random-secret-key\"):\n    #         raise ValueError(\"Must set SECRET_KEY if using session management\")\n    #     return v\n    \n    @validator(\"google_client_id\", \"google_client_secret\")\n    def validate_google_credentials(cls, v, field):\n        \"\"\"Validate Google credentials are set.\"\"\"\n        if v is None or not v.strip():\n            raise ValueError(f\"{field.name} must be set for Google OAuth\")\n        return v\n    \n    @property\n    def database_path(self) -\u003e Path:\n        \"\"\"Get database file path.\"\"\"\n        if self.database_url.startswith(\"sqlite:///\"):\n            db_path = self.database_url.replace(\"sqlite:///\", \"\")\n            return Path(db_path)\n        return Path(\"data/contacts.db\")\n    \n    @property\n    def token_path(self) -\u003e Path:\n        \"\"\"Get token file path.\"\"\"\n        return Path(self.google_token_file)\n    \n    def ensure_directories(self):\n        \"\"\"Ensure required directories exist.\"\"\"\n        self.database_path.parent.mkdir(parents=True, exist_ok=True)\n        self.token_path.parent.mkdir(parents=True, exist_ok=True)\n\n\n# Global settings instance\nsettings = Settings()\n\n# Ensure required directories exist\nsettings.ensure_directories()\n```\n\n## Verification\n\nAfter completing this task:\n1. Copy `.env.example` to `.env` and set required values\n2. Run the application - should start without errors\n3. Configuration validation should work\n4. Tests should pass: `pytest tests/test_config.py`\n5. Configuration summary should print on startup\n\n## Notes\n\n- Never commit `.env` file to version control\n- Use `.env.example` as a template\n- Sensitive values should not be logged or printed\n- Configuration should be validated on startup\n- Use type hints for all configuration options\n\n## Related Documentation\n\n- Pydantic Settings: https://docs.pydantic.dev/latest/concepts/pydantic_settings/\n- python-dotenv: https://github.com/theskumar/python-dotenv\n- Twelve-Factor App Config: https://12factor.net/config\n\n## Estimated Time\n\n2-3 hours","acceptance_criteria":"☐ Pydantic Settings is configured\n☐ `.env.example` file is created with all configuration options\n☐ Configuration schema includes type hints and validation\n☐ Configuration can be loaded from environment variables\n☐ Configuration can be loaded from `.env` file\n☐ Invalid configuration raises clear validation errors\n☐ Sensitive values are not logged or displayed\n☐ Documentation explains each configuration option","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":120,"created_at":"2026-01-08T03:10:59.069192913Z","created_by":"vscode","updated_at":"2026-01-08T03:26:31.515357335Z","closed_at":"2026-01-08T03:11:16.448841443Z","close_reason":"Closed","labels":["P0","backend","config"]}
{"id":"google-contacts-cisco-5wo","title":"Frontend: No error boundaries for component crashes","description":"## Problem\nVue frontend has no error boundaries to catch component errors:\n1. Component errors crash entire app\n2. No error recovery or fallback UI\n3. Users see white screen on errors\n4. No error reporting to backend\n5. Development errors leak to production\n\n## Affected Components\n- All Vue components in `frontend/src/components/`\n- All views in `frontend/src/views/`\n- API client errors not handled at component level\n- No global error handler configured\n\n## Example Issues\n```typescript\n// ContactCard.vue - No error handling for props\n\u003ctemplate\u003e\n  \u003cdiv\u003e{{ contact.display_name }}\u003c/div\u003e\n  \u003c!-- Crashes if contact is null/undefined --\u003e\n\u003c/template\u003e\n\n// api/client.ts - Errors only logged in dev\nconsole.error('API Error:', ...)  // No user notification\n```\n\n## Impact\n- **Poor UX**: White screen of death\n- **No Recovery**: Users must refresh page\n- **No Diagnostics**: Errors not logged/reported\n- **Production Issues**: Crashes in production silent\n\n## Required Fix\n1. Add Vue error handler in main.ts\n2. Create ErrorBoundary component\n3. Add fallback UI for component errors\n4. Implement error reporting service\n5. Add error toast notifications\n6. Log errors to backend /api/errors endpoint\n7. Add error boundary tests\n\n## Implementation\n```typescript\n// main.ts\napp.config.errorHandler = (err, instance, info) =\u003e {\n  console.error('Vue error:', err, info)\n  // Report to backend\n  // Show user-friendly message\n}\n\n// ErrorBoundary.vue component\n// Fallback UI components\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T21:21:29.229378714-08:00","created_by":"rohan","updated_at":"2026-01-09T21:21:29.229378714-08:00","labels":["error-handling","frontend","ux","vue"]}
{"id":"google-contacts-cisco-627","title":"Search API Endpoints","description":"# Unknown\n\n\n## Overview\n\nCreate RESTful API endpoints for searching contacts by name and phone number. These endpoints will be used by both the Cisco phone search functionality and the web frontend.\n\n## Priority\n\n**P1 (High)** - Required for MVP\n\n## Dependencies\n\n- Task 1.1: Environment Setup\n- Task 5.1: Phone Number Normalization\n- Task 5.2: Search Service Implementation\n\n## Objectives\n\n1. Create search API endpoint (`GET /api/search`)\n2. Support query parameters for name and phone\n3. Return JSON responses with contact data\n4. Add pagination support\n5. Implement proper error handling\n6. Add request validation\n7. Include response time logging\n8. Test all endpoints\n\n## Technical Context\n\n### API Design\n- **Endpoint**: `GET /api/search`\n- **Query Parameters**:\n  - `q`: General search query (name or phone)\n  - `name`: Search by name only\n  - `phone`: Search by phone only\n  - `limit`: Max results (default 50, max 100)\n- **Response**: JSON array of contacts with match metadata\n\n## Implementation Steps\n\n### 1. Create Search Router\n\nCreate `google_contacts_cisco/api/search.py`:\n\n```python\n\"\"\"Search API endpoints.\"\"\"\nfrom typing import Optional, List\nfrom fastapi import APIRouter, Depends, Query, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel, Field\nimport time\n\nfrom ..models import get_db\nfrom ..services.search_service import get_search_service, SearchResult\nfrom ..utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\nrouter = APIRouter(prefix=\"/api/search\", tags=[\"search\"])\n\n\nclass PhoneNumberSchema(BaseModel):\n    \"\"\"Phone number schema.\"\"\"\n    value: str\n    display_value: str\n    type: str\n    primary: bool\n\n\nclass EmailAddressSchema(BaseModel):\n    \"\"\"Email address schema.\"\"\"\n    value: str\n    type: str\n    primary: bool\n\n\nclass SearchResultSchema(BaseModel):\n    \"\"\"Search result schema.\"\"\"\n    id: str\n    display_name: str\n    given_name: Optional[str] = None\n    family_name: Optional[str] = None\n    phone_numbers: List[PhoneNumberSchema] = Field(default_factory=list)\n    email_addresses: List[EmailAddressSchema] = Field(default_factory=list)\n    match_type: str\n    match_field: str\n    \n    class Config:\n        from_attributes = True\n\n\nclass SearchResponse(BaseModel):\n    \"\"\"Search response schema.\"\"\"\n    results: List[SearchResultSchema]\n    count: int\n    query: str\n    elapsed_ms: float\n\n\n@router.get(\"\", response_model=SearchResponse)\nasync def search_contacts(\n    q: Optional[str] = Query(None, description=\"General search query (name or phone)\"),\n    name: Optional[str] = Query(None, description=\"Search by name only\"),\n    phone: Optional[str] = Query(None, description=\"Search by phone number only\"),\n    limit: int = Query(50, ge=1, le=100, description=\"Maximum results to return\"),\n    db: Session = Depends(get_db)\n):\n    \"\"\"Search contacts by name or phone number.\n    \n    Query parameters:\n    - q: General search (searches both name and phone)\n    - name: Search by name only\n    - phone: Search by phone number only\n    - limit: Maximum results (1-100, default 50)\n    \n    Only one of q, name, or phone should be provided.\n    \n    Returns:\n        SearchResponse with matching contacts\n    \"\"\"\n    start_time = time.time()\n    \n    try:\n        # Validate: only one search parameter\n        search_params = [q, name, phone]\n        if sum(p is not None for p in search_params) != 1:\n            raise HTTPException(\n                status_code=400,\n                detail=\"Exactly one of 'q', 'name', or 'phone' must be provided\"\n            )\n        \n        # Get search service\n        search_service = get_search_service(db)\n        \n        # Perform search\n        results: List[SearchResult] = []\n        query_str = \"\"\n        \n        if q:\n            query_str = q\n            results = search_service.search(q, max_results=limit)\n            logger.info(f\"General search for '{q}': {len(results)} results\")\n        elif name:\n            query_str = name\n            results = search_service.search_by_name(name, max_results=limit)\n            logger.info(f\"Name search for '{name}': {len(results)} results\")\n        elif phone:\n            query_str = phone\n            results = search_service.search_by_phone(phone, max_results=limit)\n            logger.info(f\"Phone search for '{phone}': {len(results)} results\")\n        \n        # Convert to response schema\n        result_dicts = [r.to_dict() for r in results]\n        \n        elapsed = (time.time() - start_time) * 1000\n        logger.info(f\"Search completed in {elapsed:.2f}ms\")\n        \n        return SearchResponse(\n            results=result_dicts,\n            count=len(result_dicts),\n            query=query_str,\n            elapsed_ms=round(elapsed, 2)\n        )\n    \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Search error: {str(e)}\", exc_info=True)\n        raise HTTPException(\n            status_code=500,\n            detail=\"Internal server error during search\"\n        )\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Test Search Endpoint**:\n   ```bash\n   # General search\n   curl \"http://localhost:8000/api/search?q=John\"\n   \n   # Name search\n   curl \"http://localhost:8000/api/search?name=John\"\n   \n   # Phone search\n   curl \"http://localhost:8000/api/search?phone=555-123-4567\"\n   \n   # With limit\n   curl \"http://localhost:8000/api/search?q=test\u0026limit=10\"\n   ```\n\n2. **Check API Documentation**:\n   ```bash\n   # Open browser to http://localhost:8000/docs\n   # Interactive API documentation should show search endpoint\n   ```\n\n3. **Run Tests**:\n   ```bash\n   uv run pytest tests/test_search_api.py -v\n   ```\n\n4. **Test Performance**:\n   ```bash\n   # Use Apache Bench or similar\n   ab -n 100 -c 10 \"http://localhost:8000/api/search?q=test\"\n   ```\n\n## Notes\n\n- **Query Parameters**: Only one search parameter (q, name, or phone) allowed per request\n- **Response Format**: JSON with results array and metadata\n- **Performance Logging**: Response time included in response and logs\n- **Error Handling**: 400 for bad requests, 500 for server errors\n- **CORS**: Enabled for web frontend\n- **Pagination**: Limit parameter (1-100, default 50)\n- **Validation**: Pydantic models for request/response validation\n- **Documentation**: Auto-generated via FastAPI\n\n## Common Issues\n\n1. **CORS Errors**: Add frontend origin to `cors_origins` config\n2. **Slow Responses**: Check database indexes, optimize queries\n3. **Validation Errors**: Check query parameter types and ranges\n4. **Empty Results**: Verify contacts are synced and not deleted\n5. **Performance Issues**: Monitor with `elapsed_ms` in response\n\n## Related Documentation\n\n- FastAPI: https://fastapi.tiangolo.com/\n- Pydantic: https://docs.pydantic.dev/\n- OpenAPI: https://swagger.io/specification/\n\n## Estimated Time\n\n3-4 hours","acceptance_criteria":"☐ Search endpoint returns correct results\n☐ Supports name and phone search\n☐ Query parameters are validated\n☐ Pagination works correctly\n☐ Errors return appropriate HTTP codes\n☐ Response time is logged\n☐ JSON responses are properly formatted\n☐ Tests cover all scenarios\n☐ API documentation is generated","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":180,"created_at":"2026-01-08T03:10:59.439714026Z","created_by":"vscode","updated_at":"2026-01-08T05:20:12.858986743Z","closed_at":"2026-01-08T05:20:12.858986743Z","close_reason":"Closed","labels":["P0","api","backend","search"]}
{"id":"google-contacts-cisco-62j","title":"Comprehensive Code Review and Quality Audit","description":"Conduct a thorough code review of the entire codebase to identify:\n\n1. **Security Issues**: Authentication vulnerabilities, data exposure, injection risks, insecure dependencies\n2. **Bugs**: Logic errors, race conditions, error handling gaps, edge cases\n3. **Code Quality**: Code smells, poor abstractions, duplicated code, overly complex functions\n4. **Edge Cases**: Missing input validation, boundary conditions, null/undefined handling\n5. **Performance Issues**: N+1 queries, inefficient algorithms, memory leaks\n6. **Testing Gaps**: Missing test coverage, insufficient assertions, untested edge cases\n7. **Documentation**: Missing docstrings, unclear comments, outdated documentation\n\n## Scope\nReview all modules:\n- Authentication (OAuth flow, token management)\n- API endpoints (contacts, directory, search, sync)\n- Services (Google client, sync, search, XML formatter)\n- Database models and repositories\n- Frontend components and API client\n- Configuration and environment handling\n- Error handling and logging\n\n## Output\nCreate individual beads tasks for each identified issue with:\n- Clear description of the problem\n- Severity/priority (P0 for security/bugs, P1 for quality issues, P2 for improvements)\n- Appropriate labels (bug, security, improvement, refactor, edge-case, performance, testing)\n- Affected files and code references\n- Suggested fix or remediation approach\n\n## Acceptance Criteria\n- [ ] All Python backend code reviewed\n- [ ] All TypeScript frontend code reviewed\n- [ ] All test code reviewed\n- [ ] All configuration and infrastructure code reviewed\n- [ ] At least 10 actionable tasks created (if issues found)\n- [ ] Tasks properly prioritized and labeled\n- [ ] Each task includes specific code references and fix suggestions","status":"in_progress","priority":1,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T09:12:00.418636712Z","created_by":"vscode","updated_at":"2026-01-09T21:17:29.483970017-08:00","labels":["bugs","code-review","quality","security"]}
{"id":"google-contacts-cisco-62t","title":"Bug: Memory leak in sync service with large contact lists","description":"## Problem\nSync service loads all contacts into memory during pagination without cleanup:\n1. No memory limits on batch processing (sync_service.py lines 163-199)\n2. Contact objects accumulate in memory during large syncs\n3. Phone numbers loaded eagerly creating large object graphs\n4. No streaming or chunked processing for 10K+ contacts\n5. Database session not closed between batches\n\n## Affected Code\n```python\n# sync_service.py lines 219-280\ndef _process_contacts_page(self, connections, stats, batch_size):\n    for person in connections:\n        contact_data = transform_google_person_to_contact(person)\n        # Objects accumulate in session and memory\n        self.contact_repo.upsert_contact(contact_data)\n        # Commits every batch_size but objects stay in memory\n```\n\n## Impact\n- **OOM Errors**: Crashes with \u003e5K contacts\n- **Performance Degradation**: Sync gets slower over time\n- **Database Connection Exhaustion**: Sessions not properly released\n- **Production Outages**: Server crashes during sync\n\n## Memory Growth Pattern\n- 1K contacts: ~100MB\n- 5K contacts: ~500MB  \n- 10K contacts: ~1.5GB → OOM crash\n- Each contact: ~150KB in memory (with relationships)\n\n## Required Fix\n1. Implement session.expunge() after batch commits\n2. Add memory usage monitoring during sync\n3. Implement streaming/generator pattern for large datasets\n4. Add configurable memory limits with circuit breaker\n5. Clear SQLAlchemy identity map periodically\n6. Add integration test with 10K+ mock contacts\n7. Document memory requirements in README","status":"open","priority":1,"issue_type":"bug","created_at":"2026-01-09T21:19:17.790413858-08:00","created_by":"rohan","updated_at":"2026-01-09T21:19:17.790413858-08:00","labels":["backend","bug","memory-leak","performance"]}
{"id":"google-contacts-cisco-6cm","title":"Deployment Preparation","description":"# Unknown\n\n\n## Overview\n\nPrepare the application for production deployment with Docker containerization, environment configuration, production optimizations, backup strategies, and deployment automation.\n\n## Priority\n\n**P1 (High)** - Required for production deployment\n\n## Dependencies\n\n- All implementation tasks (1-22)\n- Task 8.1: API Documentation\n\n## Objectives\n\n1. Create production Dockerfile with multi-stage build\n2. Create docker-compose for full stack\n3. Configure production environment variables\n4. Set up production logging and monitoring\n5. Implement database backup strategy\n6. Create deployment scripts\n7. Configure reverse proxy (nginx)\n8. Add health checks and readiness probes\n9. Document deployment procedures\n10. Test complete deployment process\n\n## Technical Context\n\n### Deployment Architecture\n```\n[Internet] → [Nginx Reverse Proxy] → [FastAPI + Vue (Container)]\n                                            ↓\n                                        [SQLite Volume]\n```\n\n## Implementation Steps\n\n### 1. Create Multi-Stage Dockerfile\n\nCreate `Dockerfile`:\n\n```dockerfile\n# Stage 1: Build frontend\nFROM node:18-alpine AS frontend-builder\n\nWORKDIR /frontend\n\n# Copy frontend files\nCOPY frontend/package*.json ./\nRUN npm ci\n\nCOPY frontend/ ./\nRUN npm run build\n\n# Stage 2: Build backend\nFROM python:3.10-slim AS backend-builder\n\nWORKDIR /app\n\n# Install uv\nCOPY --from=ghcr.io/astral-sh/uv:latest /uv /bin/uv\n\n# Copy dependency files\nCOPY pyproject.toml ./\nCOPY google_contacts_cisco/_version.py ./google_contacts_cisco/\n\n# Install dependencies\nRUN uv sync --frozen --no-dev\n\n# Stage 3: Production image\nFROM python:3.10-slim\n\nWORKDIR /app\n\n# Create non-root user\nRUN useradd -m -u 1000 appuser \u0026\u0026 \\\n    mkdir -p /app/data /app/logs \u0026\u0026 \\\n    chown -R appuser:appuser /app\n\n# Copy uv and dependencies from builder\nCOPY --from=backend-builder /root/.local /root/.local\nCOPY --from=ghcr.io/astral-sh/uv:latest /uv /bin/uv\n\n# Copy application code\nCOPY --chown=appuser:appuser google_contacts_cisco ./google_contacts_cisco\n\n# Copy frontend build\nCOPY --from=frontend-builder --chown=appuser:appuser /frontend/dist ./google_contacts_cisco/static/dist\n\n# Switch to non-root user\nUSER appuser\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \\\n  CMD python -c \"import requests; requests.get('http://localhost:8000/health')\" || exit 1\n\n# Expose port\nEXPOSE 8000\n\n# Set environment\nENV PYTHONUNBUFFERED=1 \\\n    PYTHONDONTWRITEBYTECODE=1 \\\n    PATH=\"/root/.local/bin:$PATH\"\n\n# Run application\nCMD [\"uv\", \"run\", \"uvicorn\", \"google_contacts_cisco.main:app\", \\\n     \"--host\", \"0.0.0.0\", \\\n     \"--port\", \"8000\", \\\n     \"--workers\", \"2\", \\\n     \"--log-config\", \"/app/logging.conf\"]\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Build Docker Image**:\n   ```bash\n   docker build -t contacts-app .\n   ```\n\n2. **Test Docker Compose**:\n   ```bash\n   docker-compose -f docker-compose.prod.yml up -d\n   docker-compose -f docker-compose.prod.yml ps\n   ```\n\n3. **Test Deployment Script**:\n   ```bash\n   ./scripts/deploy.sh\n   ```\n\n4. **Test Health Check**:\n   ```bash\n   curl http://localhost:8000/health\n   ```\n\n5. **Test Backup Script**:\n   ```bash\n   ./scripts/backup.sh\n   ls -lh backups/\n   ```\n\n## Estimated Time\n\n4-5 hours","acceptance_criteria":"☐ Multi-stage Dockerfile builds successfully\n☐ Docker compose orchestrates all services\n☐ Environment variables properly configured\n☐ Production logging configured\n☐ Health checks working\n☐ Database backups automated\n☐ Nginx reverse proxy configured\n☐ HTTPS/TLS configured\n☐ Deployment scripts tested\n☐ Rollback procedure documented\n☐ Monitoring hooks in place","notes":"\n**Related Files:**\n\n- See `.ai/planning/tasks/` for complete implementation guide\n\n- Includes code examples, test suites, and verification steps","status":"closed","priority":1,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.597537385Z","created_by":"vscode","updated_at":"2026-01-09T05:05:26.62456158Z","closed_at":"2026-01-09T05:05:26.624565424Z","labels":["P1","deployment","infrastructure"]}
{"id":"google-contacts-cisco-6sk","title":"Security: Path traversal vulnerability in static file serving","description":"## Problem\nThe static file serving in `main.py` (lines 223-233) attempts to prevent path traversal but has weaknesses:\n1. Uses `.resolve()` which can be bypassed with symlinks\n2. Error handling raises generic HTTPException that could leak path information\n3. No logging of suspicious access attempts\n\n## Security Impact\n- **Path Traversal**: Attackers could read sensitive files outside STATIC_DIR\n- **Information Disclosure**: Error messages could reveal filesystem structure\n- **Medium-High Risk**: Production deployment vulnerability\n\n## Affected Code\n```python\n# main.py lines 223-233\nstatic_file = STATIC_DIR / full_path\nresolved = static_file.resolve()\ntry:\n    resolved.relative_to(STATIC_DIR)\nexcept ValueError:\n    # Path is outside STATIC_DIR, likely a path traversal attempt\n    raise HTTPException(status_code=403, detail=\"Forbidden\")\n```\n\n## Vulnerabilities\n1. Symlink bypass: symlink in STATIC_DIR pointing to /etc/passwd\n2. Case sensitivity issues on case-insensitive filesystems\n3. No audit logging of traversal attempts\n\n## Required Fix\n1. Use `.resolve(strict=True)` and handle FileNotFoundError\n2. Sanitize full_path before constructing path\n3. Add security logging for suspicious requests\n4. Add WAF rules or rate limiting for traversal attempts\n5. Add security tests for common traversal patterns","status":"open","priority":0,"issue_type":"bug","created_at":"2026-01-09T21:18:26.453667902-08:00","created_by":"rohan","updated_at":"2026-01-09T21:18:26.453667902-08:00","labels":["backend","path-traversal","security"]}
{"id":"google-contacts-cisco-7lp","title":"Support company name as display name for business contacts without names","description":"## Problem\n\nSome contacts in Google Contacts are businesses and don't have first and last names. Currently, these contacts fall back to using their email address or resource name as the display name, even though they have a company/organization name that would be more appropriate.\n\nThis results in poor UX where business contacts appear in the directory as email addresses or resource IDs instead of their company names.\n\n## Root Cause\n\nThe `get_display_name()` method in `google_contacts_cisco/api/schemas.py` (lines 90-121) follows this fallback order:\n\n1. displayName field from names array\n2. Constructed from givenName + familyName\n3. Just givenName\n4. Just familyName\n5. First email address ← **Falls back here for businesses**\n6. Resource name as last resort\n\nThe issue is that we skip over the organization name entirely, even though it's available in `person.organizations[0].name`.\n\n## Expected Behavior\n\nFor business contacts without personal names, the display name should be the organization/company name before falling back to email or resource name.\n\nUpdated fallback order should be:\n1. displayName field from names array\n2. Constructed from givenName + familyName\n3. Just givenName\n4. Just familyName\n5. **Organization name (NEW)** ← Insert here\n6. First email address\n7. Resource name as last resort\n\n## Example\n\n**Before:**\n- Business contact: \"Acme Corporation\" (organization)\n- No given/family name\n- Email: info@acme.com\n- Current display name: \"info@acme.com\" ❌\n\n**After:**\n- Same business contact\n- Expected display name: \"Acme Corporation\" ✅\n\n## Files to Modify\n\n1. **`google_contacts_cisco/api/schemas.py`**\n   - Modify `GooglePerson.get_display_name()` method (lines 90-121)\n   - Insert organization name check after family name fallback\n   - Before falling back to email, check if `self.organizations` exists and has a name\n\n2. **`tests/unit/api/test_schemas.py`**\n   - Add test: `test_get_display_name_fallback_to_organization`\n   - Add test: `test_get_display_name_organization_before_email`\n   - Ensure existing tests still pass\n\n3. **`tests/unit/services/test_contact_transformer.py`**\n   - Add test: `test_transform_business_contact_without_names`\n   - Verify transformer correctly handles business contacts\n   - Ensure display name uses organization name when no personal names exist\n\n## Implementation Details\n\n### Code Change (schemas.py)\n\nIn `GooglePerson.get_display_name()`, after the family_name check and before the email fallback:\n\n```python\n# After checking family_name (around line 114)\nelif name.family_name:\n    return name.family_name\n\n# NEW: Fall back to organization name\nif self.organizations and self.organizations[0].name:\n    return self.organizations[0].name\n\n# Then fall back to email\nif self.email_addresses:\n    return self.email_addresses[0].value\n```\n\n### Test Cases to Add\n\n**Test 1: Business contact with organization, no names**\n- Input: GooglePerson with organizations=[{name: \"Acme Corp\"}], no names\n- Expected: display_name = \"Acme Corp\"\n\n**Test 2: Organization used before email**\n- Input: GooglePerson with organizations=[{name: \"Acme Corp\"}], emailAddresses=[{value: \"info@acme.com\"}], no names\n- Expected: display_name = \"Acme Corp\" (NOT email)\n\n**Test 3: Personal name takes precedence over organization**\n- Input: GooglePerson with givenName=\"John\", organizations=[{name: \"Acme Corp\"}]\n- Expected: display_name = \"John\" (personal name still preferred)\n\n**Test 4: Empty organization name skipped**\n- Input: GooglePerson with organizations=[{name: None}], emailAddresses=[{value: \"test@test.com\"}]\n- Expected: display_name = \"test@test.com\" (skip empty org, use email)\n\n**Test 5: Transformer test for business contact**\n- Input: GooglePerson with only organization, no personal names\n- Expected: ContactCreateSchema.display_name uses organization name\n\n## Acceptance Criteria\n\n- [ ] `GooglePerson.get_display_name()` returns organization name when no personal names exist\n- [ ] Organization name is used before falling back to email or resource name\n- [ ] Personal names (given/family) still take precedence over organization name\n- [ ] Empty/None organization names are properly skipped\n- [ ] All existing tests continue to pass\n- [ ] New tests added for business contact scenarios (minimum 5 new test cases)\n- [ ] Transformer correctly handles business contacts without personal names\n- [ ] Contacts with organization names appear correctly in:\n  - Cisco IP Phone directory XML\n  - Search results\n  - Contact listings\n- [ ] Test coverage for the modified code remains at 100%\n- [ ] No linter errors introduced\n\n## Testing Instructions\n\nRun the test suite:\n```bash\ncd /workspaces/google-contacts-cisco\nuv run pytest tests/unit/api/test_schemas.py::TestGooglePerson -v\nuv run pytest tests/unit/services/test_contact_transformer.py -v\nuv run pytest --cov=google_contacts_cisco --cov-report=term-missing\n```\n\nVerify coverage:\n```bash\nuv run python scripts/verify-coverage.py\n```\n\n## Manual Testing\n\nCreate a test contact in Google Contacts:\n1. Add a new contact with only company name (no first/last name)\n2. Run sync: `bd ready`, then execute sync task\n3. Verify contact appears with company name in:\n   - `/directory` endpoint\n   - `/contacts` endpoint\n   - `/search?q=\u003ccompany\u003e` endpoint\n\n## Edge Cases to Consider\n\n1. Organization array exists but is empty: `organizations: []`\n2. Organization exists but name is None: `organizations: [{name: None}]`\n3. Organization exists but name is empty string: `organizations: [{name: \"\"}]`\n4. Multiple organizations (should use first one)\n5. Organization with only job title, no name\n\n## Related Code\n\n- Contact model: `google_contacts_cisco/models/contact.py` (display_name is non-nullable)\n- XML formatter: `google_contacts_cisco/services/xml_formatter.py` (uses display_name)\n- Search service: `google_contacts_cisco/services/search_service.py` (searches display_name)\n\n## Priority\n\n**Medium-High** - This affects user experience for business contacts, which are common in corporate environments where Cisco phones are used.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-09T08:57:58.012239975Z","created_by":"vscode","updated_at":"2026-01-09T21:18:50.365378047-08:00","closed_at":"2026-01-09T21:18:50.365378047-08:00","close_reason":"Closed","labels":["bug","contacts","display-name","ux"]}
{"id":"google-contacts-cisco-86w","title":"Sync Management Interface","description":"# Unknown\n\n\n## Overview\n\nCreate a comprehensive web interface for managing contact synchronization, including manual sync triggers, real-time sync status display, sync history logs, and error handling.\n\n## Priority\n\n**P1 (High)** - Required for MVP\n\n## Dependencies\n\n- Task 3.3: Sync Service\n- Task 6.1: Frontend Framework Setup\n\n## Objectives\n\n1. Display current sync status (idle, running, completed, error)\n2. Show last sync time and statistics (contacts added/updated/deleted)\n3. Add manual sync button with loading state\n4. Display real-time sync progress\n5. Show sync history with timestamps\n6. Handle and display sync errors gracefully\n7. Add automatic sync information\n8. Test complete sync workflow\n\n## Technical Context\n\n### Sync States\n- **Idle**: No sync running, system ready\n- **Running**: Sync in progress\n- **Completed**: Last sync successful\n- **Error**: Last sync failed with error\n\n## Implementation Steps\n\n### 1. Create Sync Status API Endpoint\n\nCreate `google_contacts_cisco/api/sync.py`:\n\n```python\n\"\"\"Sync API endpoints.\"\"\"\nfrom typing import Optional\nfrom fastapi import APIRouter, Depends, HTTPException, BackgroundTasks\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nfrom ..models import get_db\nfrom ..services.sync_service import get_sync_service, SyncService\nfrom ..utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\nrouter = APIRouter(prefix=\"/api/sync\", tags=[\"sync\"])\n\n\n# Global sync state (in production, use Redis or database)\n_sync_state = {\n    \"status\": \"idle\",  # idle, running, completed, error\n    \"progress\": 0,\n    \"current_operation\": \"\",\n    \"stats\": {\n        \"added\": 0,\n        \"updated\": 0,\n        \"deleted\": 0\n    },\n    \"started_at\": None,\n    \"completed_at\": None,\n    \"error\": None\n}\n\n\nclass SyncStatusResponse(BaseModel):\n    \"\"\"Sync status response.\"\"\"\n    status: str\n    progress: int\n    current_operation: str\n    stats: dict\n    started_at: Optional[str]\n    completed_at: Optional[str]\n    error: Optional[str]\n\n\nclass SyncHistoryItem(BaseModel):\n    \"\"\"Sync history item.\"\"\"\n    id: int\n    started_at: str\n    completed_at: Optional[str]\n    status: str\n    contacts_added: int\n    contacts_updated: int\n    contacts_deleted: int\n    error: Optional[str]\n\n\nclass SyncHistoryResponse(BaseModel):\n    \"\"\"Sync history response.\"\"\"\n    history: list[SyncHistoryItem]\n    total: int\n\n\n@router.get(\"/status\", response_model=SyncStatusResponse)\nasync def get_sync_status():\n    \"\"\"Get current sync status.\n    \n    Returns:\n        Current sync status and progress\n    \"\"\"\n    return SyncStatusResponse(**_sync_state)\n\n\n@router.post(\"/trigger\")\nasync def trigger_sync(\n    background_tasks: BackgroundTasks,\n    force_full: bool = False,\n    db: Session = Depends(get_db)\n):\n    \"\"\"Trigger manual sync.\n    \n    Args:\n        force_full: Force full sync instead of incremental\n        \n    Returns:\n        Message indicating sync started\n    \"\"\"\n    global _sync_state\n    \n    if _sync_state[\"status\"] == \"running\":\n        raise HTTPException(status_code=409, detail=\"Sync already running\")\n    \n    try:\n        logger.info(f\"Triggering {'full' if force_full else 'incremental'} sync\")\n        \n        # Reset sync state\n        _sync_state = {\n            \"status\": \"running\",\n            \"progress\": 0,\n            \"current_operation\": \"Initializing sync...\",\n            \"stats\": {\"added\": 0, \"updated\": 0, \"deleted\": 0},\n            \"started_at\": datetime.utcnow().isoformat(),\n            \"completed_at\": None,\n            \"error\": None\n        }\n        \n        # Run sync in background\n        background_tasks.add_task(run_sync_task, db, force_full)\n        \n        return {\"message\": \"Sync started\", \"type\": \"full\" if force_full else \"incremental\"}\n    \n    except Exception as e:\n        logger.error(f\"Error triggering sync: {e}\", exc_info=True)\n        raise HTTPException(status_code=500, detail=\"Failed to start sync\")\n\n\nasync def run_sync_task(db: Session, force_full: bool):\n    \"\"\"Run sync task in background.\n    \n    Args:\n        db: Database session\n        force_full: Whether to force full sync\n    \"\"\"\n    global _sync_state\n    \n    try:\n        sync_service = get_sync_service(db)\n        \n        # Run sync\n        if force_full:\n            result = await sync_service.full_sync(\n                progress_callback=update_sync_progress\n            )\n        else:\n            result = await sync_service.incremental_sync(\n                progress_callback=update_sync_progress\n            )\n        \n        # Update state with results\n        _sync_state.update({\n            \"status\": \"completed\",\n            \"progress\": 100,\n            \"current_operation\": \"Sync completed\",\n            \"stats\": {\n                \"added\": result.contacts_added,\n                \"updated\": result.contacts_updated,\n                \"deleted\": result.contacts_deleted\n            },\n            \"completed_at\": datetime.utcnow().isoformat(),\n            \"error\": None\n        })\n        \n        logger.info(f\"Sync completed: {result}\")\n        \n        # Save to history\n        save_sync_history(result)\n        \n    except Exception as e:\n        logger.error(f\"Sync failed: {e}\", exc_info=True)\n        \n        _sync_state.update({\n            \"status\": \"error\",\n            \"current_operation\": \"Sync failed\",\n            \"completed_at\": datetime.utcnow().isoformat(),\n            \"error\": str(e)\n        })\n\n\ndef update_sync_progress(progress: int, operation: str):\n    \"\"\"Update sync progress.\n    \n    Args:\n        progress: Progress percentage (0-100)\n        operation: Current operation description\n    \"\"\"\n    global _sync_state\n    _sync_state[\"progress\"] = progress\n    _sync_state[\"current_operation\"] = operation\n\n\ndef save_sync_history(result):\n    \"\"\"Save sync result to history.\n    \n    Args:\n        result: Sync result object\n    \"\"\"\n    # In production, save to database\n    # For now, just log it\n    logger.info(f\"Saving sync history: {result}\")\n\n\n@router.get(\"/history\", response_model=SyncHistoryResponse)\nasync def get_sync_history(\n    limit: int = 10,\n    offset: int = 0,\n    db: Session = Depends(get_db)\n):\n    \"\"\"Get sync history.\n    \n    Args:\n        limit: Maximum number of records to return\n        offset: Number of records to skip\n        \n    Returns:\n        List of sync history records\n    \"\"\"\n    # In production, query from database\n    # For now, return empty list\n    return SyncHistoryResponse(history=[], total=0)\n\n\n@router.get(\"/info\")\nasync def get_sync_info(db: Session = Depends(get_db)):\n    \"\"\"Get general sync information.\n    \n    Returns:\n        Sync configuration and statistics\n    \"\"\"\n    from ..models.contact import Contact\n    \n    total_contacts = db.query(Contact).filter(Contact.deleted == False).count()\n    \n    return {\n        \"total_contacts\": total_contacts,\n        \"last_sync\": _sync_state.get(\"completed_at\"),\n        \"sync_type\": \"automatic\" if False else \"manual\",  # TODO: Get from config\n        \"sync_interval\": None  # TODO: Get from config if automatic\n    }\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Start Server**:\n   ```bash\n   uv run python -m google_contacts_cisco.main\n   ```\n\n2. **View Sync Page**:\n   - Open http://localhost:8000/sync\n   - Should see sync management interface\n\n3. **Test Manual Sync**:\n   - Click \"Sync Now\" button\n   - Status should change to \"Running\"\n   - Progress bar should appear and update\n   - Statistics should update when complete\n\n4. **Test Full Sync**:\n   - Click \"Full Sync\" button\n   - Should trigger full re-sync\n   - All contacts should be refreshed\n\n5. **Test Real-Time Updates**:\n   - Start a sync\n   - Watch progress bar update\n   - Status should update every 2 seconds\n\n6. **Test Error Handling**:\n   - Disconnect internet or stop Google API access\n   - Trigger sync\n   - Should show error message in red box\n\n7. **Test Polling**:\n   - Open browser dev tools (Network tab)\n   - Start a sync\n   - Should see polling requests every 2 seconds\n   - Polling should stop when sync completes\n\n8. **Test Button States**:\n   - During sync, buttons should be disabled\n   - After sync, buttons should re-enable\n\n9. **Run Tests**:\n   ```bash\n   uv run pytest tests/test_sync_api.py -v\n   ```\n\n## Notes\n\n- **Polling**: Uses 2-second interval to balance responsiveness and server load\n- **State Management**: Global state works for single instance; use Redis for multi-instance\n- **Progress**: Callback function updates progress from sync service\n- **History**: Should be persisted to database in production\n- **Error Handling**: Captures and displays sync errors gracefully\n- **Button States**: Disabled during sync to prevent multiple concurrent syncs\n- **Cleanup**: Polling stops when page is closed to prevent memory leaks\n\n## Common Issues\n\n1. **Polling Continues After Page Close**: Add `beforeunload` handler\n2. **Multiple Syncs**: Check sync status before allowing new sync\n3. **Stale Progress**: Ensure progress callback is called regularly\n4. **Memory Leaks**: Clear interval when component unmounts\n5. **Race Conditions**: Use locking mechanism for concurrent sync requests\n6. **State Persistence**: Store sync state in database for multi-instance deployments\n\n## Performance Optimization\n\n- Cache sync status for 1-2 seconds\n- Use WebSocket instead of polling for real-time updates\n- Batch status updates to reduce overhead\n- Add sync queue for multiple requests\n- Implement rate limiting\n\n## Future Enhancements\n\n- Add automatic scheduled syncs\n- Add sync configuration (frequency, time)\n- Add selective sync (only certain groups)\n- Add sync conflict resolution UI\n- Add sync preview (show what will change)\n- Add export sync logs\n- Add sync notifications\n\n## Related Documentation\n\n- Background Tasks: https://fastapi.tiangolo.com/tutorial/background-tasks/\n- Polling vs WebSocket: https://ably.com/topic/websockets-vs-polling\n- Progress Callbacks: https://realpython.com/python-progress-bar/\n\n## Estimated Time\n\n4-5 hours","acceptance_criteria":"☐ Sync status displays correctly (idle/running/completed/error)\n☐ Manual sync button works and shows loading state\n☐ Sync progress updates in real-time\n☐ Sync statistics are accurate\n☐ Sync history shows last 10 syncs\n☐ Error messages are user-friendly\n☐ Polling stops when sync completes\n☐ Tests cover all sync scenarios\n☐ Page is responsive on mobile","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":1,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.495589134Z","created_by":"vscode","updated_at":"2026-01-08T08:01:41.786435831Z","closed_at":"2026-01-08T08:01:41.786435831Z","close_reason":"Closed","labels":["P1","frontend","sync"]}
{"id":"google-contacts-cisco-87u","title":"GitHub Actions CI/CD: Automated Testing and Linting Pipeline","description":"## Objective\n\nSet up comprehensive GitHub Actions workflows to automatically run all tests and linting processes on every pull request, push to main, and on a regular schedule.\n\n## Context\n\nThe project currently has robust testing and linting tooling configured in pyproject.toml:\n- pytest with coverage (80% minimum)\n- ruff for linting\n- black for code formatting  \n- mypy for type checking\n\nHowever, there's no automated CI/CD pipeline to enforce these quality checks on every PR and code change.\n\n## Requirements\n\n### 1. Main CI Workflow (.github/workflows/ci.yml)\n\nCreate a comprehensive CI workflow that:\n\n**Triggers:**\n- On pull requests to main branch\n- On pushes to main branch\n- On schedule (daily at 6 AM UTC to catch dependency issues)\n- Manual workflow_dispatch for on-demand runs\n\n**Jobs:**\n\n#### Job 1: Lint\n- Run ruff linting: `ruff check .`\n- Run black format check: `black --check .`\n- Run mypy type checking: `mypy google_contacts_cisco`\n- Fail fast if any linting issues found\n\n#### Job 2: Test\n- Set up Python 3.10, 3.11, 3.12, 3.13 (matrix)\n- Install uv package manager\n- Install dependencies including dev group\n- Run pytest with coverage: `pytest --cov=google_contacts_cisco --cov-report=xml --cov-report=term`\n- Upload coverage to artifacts\n- Fail if coverage \u003c 80%\n\n#### Job 3: Frontend Tests (if applicable)\n- Set up Node.js\n- Install frontend dependencies\n- Run frontend linting/tests if configured\n\n**Additional Requirements:**\n- Use caching for pip/uv dependencies\n- Use caching for pytest cache\n- Display test results summary\n- Upload coverage reports as artifacts\n- Use latest stable versions of actions (actions/checkout@v4, actions/setup-python@v5)\n\n### 2. Pull Request Quality Gates\n\nEnsure CI workflow is required to pass before merging:\n- Document in README.md that PRs require passing CI\n- Consider adding branch protection rules documentation\n\n### 3. Coverage Reporting Enhancement\n\nOptional but recommended:\n- Consider codecov or coveralls integration for coverage tracking over time\n- Badge in README.md showing build status and coverage\n\n### 4. Script Enhancement\n\nUpdate existing test scripts to match CI behavior:\n- Ensure scripts/test.sh matches CI test job\n- Ensure local development experience mirrors CI\n\n### 5. Documentation\n\nUpdate docs/testing.md with:\n- CI/CD pipeline description\n- How to run tests locally to match CI\n- How to debug CI failures\n- Coverage requirements\n\n## Acceptance Criteria\n\n- [ ] .github/workflows/ci.yml created with lint and test jobs\n- [ ] Workflow triggers on PRs, main pushes, and daily schedule\n- [ ] Ruff linting runs and fails on violations\n- [ ] Black formatting check runs and fails on format issues\n- [ ] Mypy type checking runs and fails on type errors\n- [ ] Pytest runs with coverage reporting\n- [ ] Tests run on Python 3.10, 3.11, 3.12, 3.13 matrix\n- [ ] Coverage reports uploaded as artifacts\n- [ ] CI fails if test coverage \u003c 80%\n- [ ] Caching configured for dependencies and pytest cache\n- [ ] docs/testing.md updated with CI information\n- [ ] README.md updated with CI badge (optional but recommended)\n- [ ] All checks pass on a test PR\n\n## Technical Notes\n\n**Python Matrix Setup:**\n```yaml\nstrategy:\n  matrix:\n    python-version: ['3.10', '3.11', '3.12', '3.13']\n```\n\n**UV Package Manager:**\nProject uses uv for dependency management. Install with:\n```bash\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nuv sync --dev\n```\n\n**Pytest Configuration:**\nAlready configured in pyproject.toml with:\n- Coverage minimum 80%\n- XML and HTML reports\n- Async support\n\n## Dependencies\n\n- None (first workflow to be created)\n- Consider relationship with issue 89k (Docker/GHCR) which focuses on deployment\n\n## Estimated Effort\n\nMedium (2-3 hours)\n\n## Labels\n\nci-cd, testing, quality, automation","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T04:56:48.022891652Z","created_by":"vscode","updated_at":"2026-01-09T04:56:48.022891652Z"}
{"id":"google-contacts-cisco-89k","title":"Implement Docker containerization and GitHub Actions CI/CD for GHCR publishing","description":"## Objective\n\nCreate production-ready Docker containerization and automated GitHub Actions workflow to publish container images to GitHub Container Registry (GHCR) on every main branch update.\n\n## Context\n\nReference implementation: https://github.com/rohankapoorcom/tesiratomqtt\nInternal documentation: docs/deployment.md (lines 55-93)\n\n## Requirements\n\n### 1. Dockerfile Creation\n\nBased on docs/deployment.md and tesiratomqtt reference:\n\n- Use Python 3.11-slim base image\n- Install system dependencies (gcc, curl for healthcheck)\n- Set up /app working directory  \n- Copy project files (pyproject.toml, uv.lock, source code, alembic migrations)\n- Install uv and project dependencies\n- Create /app/data directory with proper permissions\n- Expose port 8000\n- Add HEALTHCHECK directive (curl http://localhost:8000/health)\n- CMD to run migrations and start uvicorn server\n\n### 2. .dockerignore File\n\nCreate .dockerignore to exclude:\n- .git/\n- .venv/\n- __pycache__/\n- *.pyc\n- .env\n- data/\n- tests/\n- docs/\n- .devcontainer/\n- frontend/node_modules/\n- *.md (except README.md)\n\n### 3. GitHub Actions Workflow\n\nCreate .github/workflows/docker-publish.yml:\n\n- Trigger on push to main branch\n- Trigger on release creation\n- Build multi-platform images (linux/amd64, linux/arm64)\n- Login to GitHub Container Registry\n- Extract metadata (tags, labels)\n- Build and push to ghcr.io/rohankapoorcom/google-contacts-cisco\n- Tag with latest, SHA-based tags, semantic version tags\n\nReference tesiratomqtt workflow structure for GHCR authentication and multi-platform builds.\n\n### 4. Documentation Updates\n\nUpdate README.md to include Docker installation instructions and link to ghcr.io package.\n\n### 5. Testing\n\n- Build Dockerfile locally and verify it runs\n- Test healthcheck endpoint works\n- Verify migrations run automatically\n\n## Acceptance Criteria\n\n- Dockerfile created and builds successfully\n- .dockerignore file created\n- GitHub Actions workflow created\n- Workflow successfully builds and pushes to GHCR on main branch commits\n- Container image runs successfully\n- Health check passes in running container\n- Database migrations run automatically on container startup\n- README.md updated with Docker usage instructions\n- Multi-platform builds working (amd64, arm64)\n\n## Dependencies\n\nRequires GITHUB_TOKEN (automatically available in Actions)\n\n## Estimated Effort\n\nMedium (2-3 hours)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T04:54:30.10898104Z","created_by":"vscode","updated_at":"2026-01-09T04:54:30.10898104Z"}
{"id":"google-contacts-cisco-8d2","title":"Sync Service Orchestration","description":"# Unknown\n\n\n## Overview\n\nCreate a unified sync service that orchestrates synchronization workflows, manages sync scheduling, tracks progress, and provides a clean API for sync operations.\n\n## Priority\n\n**P1 (High)** - Should have for production\n\n## Dependencies\n\n- Task 3.1: Full Sync Implementation\n- Task 3.2: Incremental Sync Implementation\n\n## Objectives\n\n1. Create unified sync service interface\n2. Add sync progress tracking\n3. Implement sync locking (prevent concurrent syncs)\n4. Add sync statistics and history\n5. Create sync management endpoints\n6. Optional: Add scheduled/automatic syncs\n7. Test sync service orchestration\n\n## Technical Context\n\n### Sync Service Responsibilities\n- Coordinate between full and incremental syncs\n- Track sync progress and status\n- Prevent concurrent syncs\n- Store sync history\n- Provide sync statistics\n- Handle sync errors gracefully\n\n## Implementation Steps\n\n### 1. Enhance Sync Service\n\nUpdate `google_contacts_cisco/services/sync_service.py`:\n\n```python\n# Add these methods and enhancements to SyncService class\n\nfrom threading import Lock\nfrom typing import List, Dict, Any\n\n# Class-level lock for preventing concurrent syncs\n_sync_lock = Lock()\n\nclass SyncService:\n    \"\"\"Enhanced sync service with orchestration.\"\"\"\n    \n    # ... existing methods ...\n    \n    def is_sync_in_progress(self) -\u003e bool:\n        \"\"\"Check if a sync is currently in progress.\n        \n        Returns:\n            True if sync is in progress\n        \"\"\"\n        sync_state = self.sync_repo.get_latest_sync_state()\n        return sync_state and sync_state.sync_status == \"syncing\"\n    \n    def safe_auto_sync(self, batch_size: int = 100) -\u003e dict:\n        \"\"\"Perform auto sync with locking to prevent concurrent syncs.\n        \n        Args:\n            batch_size: Number of contacts to commit per batch\n            \n        Returns:\n            Sync statistics or error message\n        \"\"\"\n        if not _sync_lock.acquire(blocking=False):\n            logger.warning(\"Sync already in progress, skipping\")\n            return {\n                \"status\": \"skipped\",\n                \"message\": \"Sync already in progress\",\n                \"statistics\": {}\n            }\n        \n        try:\n            return self.auto_sync(batch_size)\n        finally:\n            _sync_lock.release()\n    \n    def get_sync_history(self, limit: int = 10) -\u003e List[Dict[str, Any]]:\n        \"\"\"Get sync history.\n        \n        Args:\n            limit: Number of sync records to return\n            \n        Returns:\n            List of sync history records\n        \"\"\"\n        sync_states = self.db.query(SyncState).order_by(\n            SyncState.last_sync_at.desc()\n        ).limit(limit).all()\n        \n        history = []\n        for state in sync_states:\n            history.append({\n                \"id\": str(state.id),\n                \"status\": state.sync_status,\n                \"last_sync_at\": state.last_sync_at.isoformat() if state.last_sync_at else None,\n                \"has_sync_token\": state.sync_token is not None,\n                \"error_message\": state.error_message\n            })\n        \n        return history\n    \n    def get_sync_statistics(self) -\u003e Dict[str, Any]:\n        \"\"\"Get comprehensive sync statistics.\n        \n        Returns:\n            Sync statistics dictionary\n        \"\"\"\n        contact_count = self.contact_repo.count_active()\n        total_count = self.contact_repo.count_all()\n        deleted_count = total_count - contact_count\n        \n        # Get phone number count\n        phone_count = self.db.query(PhoneNumber).count()\n        \n        # Get latest sync\n        latest_sync = self.sync_repo.get_latest_sync_state()\n        \n        # Count syncs by status\n        from sqlalchemy import func\n        sync_counts = dict(\n            self.db.query(\n                SyncState.sync_status,\n                func.count(SyncState.id)\n            ).group_by(SyncState.sync_status).all()\n        )\n        \n        return {\n            \"contacts\": {\n                \"total\": total_count,\n                \"active\": contact_count,\n                \"deleted\": deleted_count\n            },\n            \"phone_numbers\": phone_count,\n            \"sync\": {\n                \"last_sync_at\": latest_sync.last_sync_at.isoformat() if latest_sync and latest_sync.last_sync_at else None,\n                \"status\": latest_sync.sync_status if latest_sync else \"never_synced\",\n                \"has_sync_token\": latest_sync.sync_token is not None if latest_sync else False,\n                \"error_message\": latest_sync.error_message if latest_sync else None\n            },\n            \"sync_history\": sync_counts\n        }\n    \n    def clear_sync_history(self, keep_latest: bool = True) -\u003e int:\n        \"\"\"Clear old sync history.\n        \n        Args:\n            keep_latest: If True, keep the most recent sync state\n            \n        Returns:\n            Number of sync states deleted\n        \"\"\"\n        if keep_latest:\n            # Keep only the latest sync state\n            latest = self.sync_repo.get_latest_sync_state()\n            if latest:\n                count = self.db.query(SyncState).filter(\n                    SyncState.id != latest.id\n                ).delete()\n            else:\n                count = 0\n        else:\n            # Delete all sync states\n            count = self.db.query(SyncState).delete()\n        \n        self.db.commit()\n        return count\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Test Safe Sync**:\n   ```bash\n   curl -X POST http://localhost:8000/api/sync/safe\n   # Returns success or 409 if already running\n   ```\n\n2. **Get Sync Statistics**:\n   ```bash\n   curl http://localhost:8000/api/sync/statistics\n   # Shows comprehensive sync stats\n   ```\n\n3. **Get Sync History**:\n   ```bash\n   curl http://localhost:8000/api/sync/history?limit=5\n   # Shows last 5 syncs\n   ```\n\n4. **Clear History**:\n   ```bash\n   curl -X DELETE http://localhost:8000/api/sync/history?keep_latest=true\n   ```\n\n5. **Run Tests**:\n   ```bash\n   pytest tests/test_sync_service.py -v\n   ```\n\n## Notes\n\n- **Concurrency Protection**: Lock prevents multiple simultaneous syncs\n- **Sync History**: Useful for debugging and monitoring\n- **Statistics**: Provides overview of sync health\n- **Background Scheduler**: Optional feature for automatic syncs\n- **Thread Safety**: Sync lock is thread-safe using Python's Lock\n\n## Common Issues\n\n1. **Concurrent Sync Attempts**: Lock prevents issues\n2. **Large Sync History**: Periodically clear old history\n3. **Scheduler Memory**: Daemon thread cleanup on shutdown\n4. **Lock Deadlock**: Lock is always released in finally block\n\n## Configuration Options\n\nAdd to `config.py`:\n\n```python\n# Sync scheduler settings (optional)\nsync_scheduler_enabled: bool = False\nsync_interval_minutes: int = 60  # Sync every hour\n```\n\n## Related Documentation\n\n- Python Threading: https://docs.python.org/3/library/threading.html\n- Schedule Library: https://schedule.readthedocs.io/\n- SQLAlchemy Aggregates: https://docs.sqlalchemy.org/en/20/orm/queryguide/select.html\n\n## Estimated Time\n\n3-4 hours","acceptance_criteria":"☑ Sync service prevents concurrent syncs\n☑ Sync progress can be queried in real-time\n☑ Sync history is maintained\n☑ Sync statistics are accurate\n☑ Manual sync trigger works\n☑ Sync errors are logged and reported\n☐ Sync can be cancelled (optional - not implemented)\n☑ Background sync scheduling works (optional)","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":1,"issue_type":"task","estimated_minutes":180,"created_at":"2026-01-08T03:10:59.272284743Z","created_by":"vscode","updated_at":"2026-01-08T03:26:33.136051942Z","closed_at":"2026-01-08T03:11:16.465876837Z","close_reason":"Closed","labels":["P1","backend","sync"]}
{"id":"google-contacts-cisco-8np","title":"Make home page feature buttons functional","description":"## Summary\n\nThe three feature cards on the home page (\"Cisco Phone Support\", \"Auto Sync\", and \"Fast Search\") are currently static display-only elements. They should be clickable and navigate users to the relevant pages.\n\n## Current State\n\nIn `frontend/src/views/HomeView.vue` (lines 144-181), there are three feature cards in the Features Section:\n\n1. **Cisco Phone Support** (phone icon) - Currently static, no navigation\n2. **Auto Sync** (sync icon) - Currently static, no navigation  \n3. **Fast Search** (search icon) - Currently static, no navigation\n\nThese cards are rendered in a grid but have no click handlers or navigation functionality.\n\n## Required Changes\n\n### 1. Make Feature Cards Clickable\n\nTransform the feature cards from static `\u003cdiv\u003e` elements to interactive router links that navigate to the appropriate pages:\n\n- **Cisco Phone Support** → Create new page at `/directory-info` route to show directory endpoint info\n  - Should display the directory XML endpoint URL: `/directory`\n  - Explain how to configure Cisco IP Phones to use this endpoint\n  - Show example: `http://your-server:8000/directory`\n  - Provide instructions for adding to Cisco phone directory services\n  - NOTE: This is different from the web contacts view - this is specifically for Cisco phone consumption\n  - IMPORTANT: The actual directory endpoint is `/directory`, NOT `/api/directory`\n  \n- **Auto Sync** → Navigate to `/sync` (SyncView)\n  - Already implemented and fully functional sync management page\n  \n- **Fast Search** → Navigate to `/search` (SearchView)\n  - Currently a placeholder page but route exists\n\n### 2. Implementation Options for Cisco Phone Support\n\n**Option A: Create a new Directory Info View (RECOMMENDED)**\n- Create new route `/directory-info` in `frontend/src/router/index.ts`\n  - Use `/directory-info` (not `/directory`) to avoid conflict with the actual XML directory endpoint at `/directory`\n- Create new view `frontend/src/views/DirectoryInfoView.vue`\n- Display:\n  - The full directory endpoint URL (constructed from window.location)\n  - Instructions for configuring Cisco IP Phones\n  - Link to test the XML: `\u003ca href=\"/directory\" target=\"_blank\"\u003eView Directory XML\u003c/a\u003e`\n  - QR code (optional) for easy mobile scanning\n  - Copy-to-clipboard button for the URL\n\n**Option B: Modal/Dialog (Alternative)**\n- Show a modal on click with directory endpoint information\n- Less navigation, but may be harder to share/bookmark\n\n**Option A is recommended** as it provides a dedicated page that users can bookmark and reference.\n\n### 3. Implementation Details\n\n**Files to modify:**\n\n1. **`frontend/src/router/index.ts`** - Add new route:\n```typescript\n{\n  path: '/directory-info',\n  name: 'DirectoryInfo',\n  component: () =\u003e import('@/views/DirectoryInfoView.vue'),\n  meta: {\n    title: 'Cisco Phone Directory',\n    description: 'Configure Cisco IP Phones with directory endpoint',\n  },\n}\n```\n\n2. **`frontend/src/views/DirectoryInfoView.vue`** - Create new view with:\n   - Display full directory URL (e.g., `http://your-server:8000/directory`)\n   - Copy-to-clipboard functionality\n   - Instructions for Cisco phone configuration\n   - Link to test the XML endpoint at `/directory`\n   - Link back to home or contacts\n\n3. **`frontend/src/views/HomeView.vue`** - Update features array:\n```typescript\nconst features = [\n  {\n    icon: 'phone',\n    title: 'Cisco Phone Support',\n    description: 'Access your contacts directly from Cisco IP Phone directory with optimized XML format.',\n    gradient: 'from-emerald-500 to-teal-600',\n    route: '/directory-info', // Links to directory info page\n  },\n  {\n    icon: 'sync',\n    title: 'Auto Sync',\n    description: 'Automatic synchronization with Google Contacts keeps your directory always up-to-date.',\n    gradient: 'from-brand-500 to-brand-700',\n    route: '/sync',\n  },\n  {\n    icon: 'search',\n    title: 'Fast Search',\n    description: 'Quick full-text search by name or phone number with instant results.',\n    gradient: 'from-accent-500 to-pink-600',\n    route: '/search',\n  },\n]\n```\n\n4. Wrap feature cards with `\u003crouter-link\u003e` in template (lines 145-180)\n\n### 4. Directory Info Page Content\n\nThe new DirectoryInfoView should include:\n\n- **Title**: \"Cisco IP Phone Directory Setup\"\n- **Endpoint URL**: Display the full URL (get from window.location)\n  - **CORRECT URL**: `http://your-server:8000/directory`\n  - **NOT**: `/api/directory` (this is incorrect)\n- **Copy Button**: One-click copy to clipboard\n- **Setup Instructions**:\n  1. Access your Cisco IP Phone admin interface\n  2. Navigate to Directory settings\n  3. Add new directory service\n  4. Enter the URL: [show URL with `/directory` endpoint]\n  5. Save and test\n- **Test Link**: Link to `/directory` to view XML (opens in new tab)\n- **Documentation**: Link to any relevant docs about the directory format\n- **Back Navigation**: Button/link back to home\n\n### 5. Update Tests\n\n**Test scenarios to cover:**\n1. Each feature card renders as a clickable link\n2. Clicking \"Cisco Phone Support\" navigates to `/directory-info`\n3. Clicking \"Auto Sync\" navigates to `/sync`\n4. Clicking \"Fast Search\" navigates to `/search`\n5. DirectoryInfoView renders correctly\n6. Directory URL is correctly constructed from current host with `/directory` endpoint (NOT `/api/directory`)\n7. Copy-to-clipboard functionality works\n8. Hover states work correctly on all cards\n9. Keyboard navigation works (Tab to focus, Enter to activate)\n10. Cards maintain existing visual styling\n\n## Acceptance Criteria\n\n- [ ] All three feature cards are clickable/navigable\n- [ ] \"Cisco Phone Support\" card links to `/directory-info` route\n- [ ] New DirectoryInfoView page created with endpoint information\n- [ ] Directory endpoint URL shows `/directory` (NOT `/api/directory`)\n- [ ] Directory endpoint URL is dynamically constructed from current host\n- [ ] Copy-to-clipboard button works for directory URL\n- [ ] Link to test XML (`/directory`) opens in new tab\n- [ ] \"Auto Sync\" card links to `/sync` route\n- [ ] \"Fast Search\" card links to `/search` route\n- [ ] Cards show visual feedback on hover (cursor change, subtle animation)\n- [ ] Keyboard navigation works (can tab to cards and activate with Enter)\n- [ ] Cards maintain existing styling (gradient backgrounds, icons, text)\n- [ ] No console errors or warnings\n- [ ] All existing tests pass\n- [ ] New tests added to verify navigation and DirectoryInfoView functionality\n- [ ] Verified in browser that clicking each card navigates correctly\n- [ ] Accessibility: Cards have proper ARIA labels and keyboard support\n\n## Technical Notes\n\n- Use Vue Router's `\u003crouter-link\u003e` component for navigation\n- Preserve existing animations (slide-up, staggered delays)\n- Maintain the existing card hover transform: `hover:-translate-y-1 transition-transform duration-300`\n- For directory URL, use: `const directoryUrl = \\`\\${window.location.origin}/directory\\``\n  - **IMPORTANT**: The endpoint is `/directory`, NOT `/api/directory`\n  - The directory router is mounted at the root level with prefix=\"/directory\" (see `main.py` line 177)\n- Consider adding additional hover effects like a subtle border or shadow change\n- Ensure the entire card is clickable, not just text\n- The directory XML endpoint at `/directory` is for Cisco phone consumption\n- Make it clear to users this is for configuring their Cisco phones, not for web browsing\n- Use `/directory-info` for the Vue route to avoid conflicting with the backend `/directory` endpoint\n\n## Files to Create/Modify\n\n- `frontend/src/views/DirectoryInfoView.vue` - NEW: Directory endpoint information page\n- `frontend/src/router/index.ts` - Add `/directory-info` route\n- `frontend/src/views/HomeView.vue` - Add navigation to feature cards (add route property, wrap with router-link)\n- Test files for HomeView and DirectoryInfoView components\n\n## Definition of Done\n\n- Code changes implemented and committed\n- New DirectoryInfoView page created with helpful information\n- Directory URL correctly shows `/directory` endpoint\n- All tests passing (existing + new)\n- Manual testing completed in browser\n- Verified directory URL is correctly displayed as `/directory` (not `/api/directory`)\n- Verified copy-to-clipboard works\n- Verified clicking the test link goes to `/directory` and shows XML\n- No linter errors or warnings\n- PR created with screenshots showing clickable cards and new directory info page\n- Accessibility verified (keyboard nav + screen reader if possible)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T07:34:43.358764365Z","created_by":"vscode","updated_at":"2026-01-10T04:25:23.139296509Z","labels":["enhancement","frontend","ui/ux"]}
{"id":"google-contacts-cisco-9ip","title":"Security: XSS vulnerability in Cisco XML responses","description":"## Problem\nXML formatter (`services/xml_formatter.py`) relies solely on lxml automatic escaping but has potential XSS issues:\n1. No explicit validation of user-controlled content (contact names)\n2. Comments indicate trust in lxml (lines 113, 146) without input sanitization\n3. Contact display names could contain XML special chars or scripts\n4. Cisco phones may interpret malicious XML/HTML\n\n## Affected Code\n```python\n# xml_formatter.py lines 113-114\nname.text = contact.display_name or \"\"\n# lxml handles XML escaping automatically when setting .text\n\n# lines 146-148\ntitle.text = contact.display_name or \"\"\n# No sanitization before assignment\n```\n\n## Security Impact\n- **XSS on Cisco Phones**: Malicious contact names could inject scripts\n- **XML Injection**: Could break XML structure\n- **DoS**: Malformed XML could crash phone interface\n\n## Attack Vectors\n1. Contact name: `\u003cscript\u003ealert('xss')\u003c/script\u003e`\n2. Contact name: `]]\u003e\u003c/Name\u003e\u003cTelephone\u003eevil`\n3. Contact name: `\u0026lt;img src=x onerror=alert(1)\u0026gt;`\n\n## Required Fix\n1. Add explicit XML/HTML sanitization layer before lxml\n2. Validate all user-controlled fields (names, phone labels)\n3. Add maximum length limits for XML fields\n4. Test with malicious contact names\n5. Add Content-Security-Policy headers if Cisco phones support","status":"open","priority":1,"issue_type":"bug","created_at":"2026-01-09T21:18:45.057507112-08:00","created_by":"rohan","updated_at":"2026-01-09T21:18:45.057507112-08:00","labels":["backend","security","xml","xss"]}
{"id":"google-contacts-cisco-a5l","title":"Phone Number Normalization","description":"# Unknown\n\n\n## Overview\n\nImplement phone number normalization and search functionality to enable searching contacts by phone number. This includes normalizing phone numbers to E.164 format for consistent storage and comparison, and implementing search logic.\n\n## Priority\n\n**P1 (High)** - Required for search functionality\n\n## Dependencies\n\n- Task 1.2: Database Setup\n- Task 2.1: Contact Data Models\n\n## Objectives\n\n1. Implement phone number normalization to E.164 format\n2. Handle various input formats (local, international, with/without formatting)\n3. Store normalized values in database for search\n4. Implement phone number comparison logic\n5. Handle invalid phone numbers gracefully\n6. Add support for country-specific formatting\n7. Test with various phone number formats\n8. Optimize for search performance\n\n## Technical Context\n\n### Phone Number Formats\n- **E.164**: International standard (+1234567890)\n- **National**: Local format without country code\n- **Formatted**: With parentheses, dashes, spaces\n- **Extensions**: Business numbers with extensions\n\n## Implementation Steps\n\n### 1. Add phonenumbers Dependency\n\nUpdate `pyproject.toml`:\n\n```toml\n[project]\ndependencies = [\n    \"fastapi\u003e=0.115.0\",\n    \"sqlalchemy\u003e=2.0.0\",\n    \"lxml\u003e=5.0.0\",\n    \"google-auth\u003e=2.35.0\",\n    \"google-auth-oauthlib\u003e=1.2.0\",\n    \"google-api-python-client\u003e=2.150.0\",\n    \"aiohttp\u003e=3.10.0\",\n    \"pydantic\u003e=2.9.0\",\n    \"pydantic-settings\u003e=2.6.0\",\n    \"phonenumbers\u003e=8.13.0\",  # Phone number parsing and validation\n]\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Test Normalization**:\n   ```python\n   from google_contacts_cisco.utils.phone_utils import get_phone_normalizer\n   \n   normalizer = get_phone_normalizer()\n   \n   # Test various formats\n   print(normalizer.normalize(\"555-123-4567\"))\n   # Output: ('+15551234567', '(555) 123-4567')\n   \n   print(normalizer.normalize(\"+44 20 7946 0958\"))\n   # Output: ('+442079460958', '+44 20 7946 0958')\n   ```\n\n2. **Test Search**:\n   ```python\n   from google_contacts_cisco.models import get_db\n   from google_contacts_cisco.repositories.contact_repository import ContactRepository\n   \n   db = next(get_db())\n   repo = ContactRepository(db)\n   \n   # Search by phone\n   results = repo.search_by_phone(\"555-123-4567\")\n   print(f\"Found {len(results)} contacts\")\n   ```\n\n3. **Run Tests**:\n   ```bash\n   uv run pytest tests/test_phone_utils.py -v\n   ```\n\n## Notes\n\n- **phonenumbers Library**: Industry-standard library by Google\n- **E.164 Format**: International standard (+[country][number])\n- **Display vs. Storage**: Store normalized, display original\n- **Search Flexibility**: Handle partial matches, various formats\n- **Performance**: Normalization is fast, but cache if needed\n- **Country Codes**: Default to US, but support international\n- **Extensions**: Strip for normalization, but could preserve in display\n- **Validation**: Invalid numbers are stored but flagged\n\n## Common Issues\n\n1. **Invalid Numbers**: Log warnings but don't fail sync\n2. **International Numbers**: Require + prefix or country code\n3. **Extensions**: Need special handling\n4. **Short Codes**: May not normalize (SMS services)\n5. **Performance**: Normalization is I/O bound, consider batching\n\n## Related Documentation\n\n- phonenumbers: https://github.com/daviddrysdale/python-phonenumbers\n- E.164 Format: https://en.wikipedia.org/wiki/E.164\n- libphonenumber: https://github.com/google/libphonenumber\n\n## Estimated Time\n\n4-5 hours","acceptance_criteria":"☐ Phone numbers are normalized to E.164 format\n☐ Handles US, international, and formatted numbers\n☐ Original display format is preserved\n☐ Search works with various input formats\n☐ Invalid numbers are handled without errors\n☐ Normalization is idempotent\n☐ Performance is acceptable for 10,000+ contacts\n☐ Tests cover edge cases (extensions, special characters, etc.)","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.403620333Z","created_by":"vscode","updated_at":"2026-01-08T05:16:30.113413874Z","closed_at":"2026-01-08T05:16:30.113413874Z","close_reason":"Closed","labels":["P0","backend","search"]}
{"id":"google-contacts-cisco-a70","title":"Edge Case: Empty/whitespace-only contact names cause directory errors","description":"## Problem\nContact transformer and XML formatter don't handle edge cases for names:\n1. Contacts with only whitespace in display_name pass validation\n2. Empty string names allowed (contact.py allows nullable=False but empty string)\n3. XML formatter shows empty menu items for whitespace names\n4. Search by empty name returns unexpected results\n5. Cisco phones may crash on empty directory entries\n\n## Affected Code\n```python\n# contact.py line 21\ndisplay_name = Column(String, nullable=False)  # Empty string allowed!\n\n# xml_formatter.py lines 113-114\nname.text = contact.display_name or \"\"  # Empty name OK\n\n# schemas/contact.py - Need to check if min_length validation exists\n```\n\n## Test Cases That Should Fail\n1. Contact with display_name = \"   \" (whitespace only)\n2. Contact with display_name = \"\" (empty)\n3. Contact with display_name = \"\\t\\n\" (tabs/newlines)\n4. Contact with Unicode whitespace (\\u00A0, \\u2003)\n\n## Impact\n- **UI Issues**: Empty contact names in directory\n- **Search Broken**: Can't find or identify contacts\n- **Phone Crashes**: Cisco phones may reject empty directory entries\n- **Data Quality**: Invalid contacts in database\n\n## Required Fix\n1. Add Pydantic min_length=1 validation on display_name\n2. Add string strip() and validation in transformer\n3. Fallback to 'Unnamed Contact' for empty names\n4. Add database constraint for non-empty display_name\n5. Add migration to clean existing bad data\n6. Add validation tests for whitespace-only names","status":"open","priority":2,"issue_type":"bug","created_at":"2026-01-09T21:19:38.492933888-08:00","created_by":"rohan","updated_at":"2026-01-09T21:19:38.492933888-08:00","labels":["backend","bug","edge-case","validation"]}
{"id":"google-contacts-cisco-b28","title":"Security: OAuth state parameter CSRF validation missing","description":"## Problem\nThe OAuth flow in `google_contacts_cisco/api/routes.py` does not validate the state parameter for CSRF protection. The state parameter is generated but never stored or validated on callback.\n\n## Security Impact\n- **CSRF Attack Risk**: Attacker can trick users into authorizing their Google account\n- **Session Hijacking**: OAuth code can be intercepted and replayed\n- **Critical Security Vulnerability**: P0 priority\n\n## Affected Files\n- `google_contacts_cisco/api/routes.py` - Lines 154, 199-201\n- `google_contacts_cisco/auth/oauth.py` - Lines 241-257\n\n## Current Implementation\n```python\n# State is generated but not validated\nauthorization_url, generated_state = flow.authorization_url(\n    access_type=\"offline\",\n    include_granted_scopes=\"true\",\n    prompt=\"consent\",\n    state=state,  # State is passed but not stored\n)\n```\n\n## Required Fix\n1. Store state parameter in session/database when generating auth URL\n2. Validate state on callback against stored value\n3. Implement proper session management for state storage\n4. Add CSRF token validation tests\n\n## References\n- OWASP OAuth CSRF: https://owasp.org/www-community/attacks/csrf\n- RFC 6749 Section 10.12: https://tools.ietf.org/html/rfc6749#section-10.12","status":"open","priority":0,"issue_type":"bug","created_at":"2026-01-09T21:18:08.440399704-08:00","created_by":"rohan","updated_at":"2026-01-09T21:18:08.440399704-08:00","labels":["critical","csrf","oauth","security"]}
{"id":"google-contacts-cisco-b58","title":"Fix automatic sync scheduling and timezone handling in sync timestamps","description":"## Problem Description\n\nTwo related bugs have been identified in the sync functionality:\n\n1. **Automatic Sync Not Running**: The automatic sync scheduler does not appear to be executing periodic syncs, even when enabled\n2. **Incorrect Timezone Display**: Sync timestamps are displayed in UTC instead of the user's local timezone, despite a TIMEZONE environment variable being available to the Docker container\n\n## Current Behavior\n\n### Scheduler Issue\n- The sync scheduler is configured via `SYNC_SCHEDULER_ENABLED` and `SYNC_INTERVAL_MINUTES` environment variables\n- When enabled, `start_sync_scheduler()` is called in `main.py` during application startup\n- However, automatic syncs do not appear to be executing on schedule\n- Manual syncs via the UI work correctly\n\n### Timezone Issue\n- All timestamps are stored in UTC (correctly using `datetime.now(timezone.utc)`)\n- When serialized via `.isoformat()`, timestamps are sent to frontend as ISO 8601 strings (e.g., \"2026-01-09T19:07:07.123456+00:00\")\n- Frontend displays these using JavaScript's `Date.toLocaleString()` which should use browser timezone\n- However, users report timestamps appearing in wrong timezone\n- Docker containers have access to `TIMEZONE` environment variable but it's not being utilized\n\n## Expected Behavior\n\n### Scheduler Fix\n- When `SYNC_SCHEDULER_ENABLED=true`, automatic syncs should execute every `SYNC_INTERVAL_MINUTES`\n- Scheduler logs should indicate sync execution (\"Running scheduled sync\", \"Scheduled sync completed\")\n- Sync history should show regular automatic syncs\n\n### Timezone Fix\n- Timestamps should be displayed in the user's local timezone (from TIMEZONE env var or system default)\n- Frontend should receive timezone-aware timestamps or properly configured timezone information\n- Sync history and status displays should show times in local timezone\n\n## Files to Investigate\n\n### Backend\n- `google_contacts_cisco/services/scheduler.py` - Scheduler implementation\n- `google_contacts_cisco/main.py` - Scheduler initialization (lines 61-66)\n- `google_contacts_cisco/config.py` - Configuration settings (lines 52-54)\n- `google_contacts_cisco/services/sync_service.py` - Timestamp serialization (lines 298, 548, 599)\n- `google_contacts_cisco/api/sync.py` - API response models\n\n### Frontend\n- `frontend/src/views/SyncView.vue` - Timestamp display (lines 74-90, 248-252)\n- `frontend/src/api/client.ts` - API client\n\n## Technical Details\n\n### Scheduler Architecture\n- Uses Python threading (`threading.Thread` with daemon=True)\n- Implements `_run_scheduler()` loop that waits using `_stop_event.wait(timeout=interval_seconds)`\n- Global `_scheduler` instance managed by `start_sync_scheduler()` and `stop_sync_scheduler()`\n- Should call `sync_service.safe_auto_sync()` on interval\n\n### Timestamp Flow\n1. Backend stores timestamps in UTC: `datetime.now(timezone.utc)`\n2. Serialized via `state.last_sync_at.isoformat()` (sync_service.py:298, 548, 599)\n3. Frontend receives ISO 8601 string\n4. Displayed via `formatDate(dateStr)` using `date.toLocaleString()` (SyncView.vue:248-252)\n\n## Debugging Steps\n\n1. **Verify Scheduler Configuration**:\n   - Check if `SYNC_SCHEDULER_ENABLED=true` in environment\n   - Verify `SYNC_INTERVAL_MINUTES` is set and \u003e= 5\n   - Check startup logs for \"Sync scheduler started\" message\n\n2. **Check Scheduler Thread**:\n   - Verify daemon thread is created and started\n   - Check if `_run_scheduler()` loop is executing\n   - Look for \"Running scheduled sync\" log entries\n\n3. **Investigate Timezone**:\n   - Check if `TIMEZONE` env var is accessible in Python\n   - Verify frontend JavaScript timezone detection\n   - Test ISO 8601 parsing in browser console\n\n## Acceptance Criteria\n\n1. **Scheduler Fix**:\n   - [ ] Automatic syncs execute on the configured interval when enabled\n   - [ ] Scheduler logs appear showing sync execution\n   - [ ] Sync history shows regular automatic sync entries\n   - [ ] Scheduler can be enabled/disabled via environment variable\n   - [ ] Add unit tests for scheduler functionality\n\n2. **Timezone Fix**:\n   - [ ] Timestamps display in user's local timezone (from TIMEZONE env var)\n   - [ ] Relative time display (\"11 hours ago\") uses correct timezone\n   - [ ] Full timestamp display shows correct timezone\n   - [ ] Add timezone configuration to settings\n   - [ ] Update documentation for TIMEZONE environment variable\n\n3. **Testing**:\n   - [ ] Add integration test for scheduler execution\n   - [ ] Add test for timezone handling\n   - [ ] Verify Docker container timezone support\n   - [ ] Test with various timezone configurations\n\n## Additional Context\n\n- Screenshot provided by user shows sync history with timestamps appearing incorrect\n- Docker environment uses `TIMEZONE` environment variable (should be documented in .env.example)\n- Current implementation uses UTC everywhere which is correct for storage but needs proper display conversion\n- Consider using pytz or zoneinfo for Python timezone handling\n- Consider sending timezone info to frontend in API responses","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-09T20:38:54.78042043-08:00","created_by":"rohan","updated_at":"2026-01-09T20:43:59.926724555-08:00","closed_at":"2026-01-09T20:43:59.926724555-08:00","close_reason":"Closed","labels":["backend","scheduler","sync","timezone"]}
{"id":"google-contacts-cisco-b5x","title":"Bug: Race condition in concurrent sync operations","description":"## Problem\nSync service (`services/sync_service.py`) uses module-level lock but has race conditions:\n1. Lock is only used in `safe_auto_sync` (line 499) but not in direct `full_sync`/`incremental_sync` calls\n2. Database `is_sync_in_progress` check (line 336) is separate from actual sync start - TOCTOU bug\n3. Multiple API endpoints can trigger syncs without coordination\n4. Scheduler can start sync while API sync is running\n\n## Affected Code\n```python\n# sync_service.py lines 131-157\ndef full_sync(self, batch_size=100, page_delay=0.1):\n    # No lock acquisition - can run concurrently!\n    logger.info(\"Starting full sync\")\n    stats = SyncStatistics()\n    sync_state = self.sync_repo.create_sync_state(status=SyncStatus.SYNCING)\n    # Race: Another sync could start here\n```\n\n## Impact\n- **Data Corruption**: Concurrent syncs could create duplicate contacts\n- **Database Locks**: Multiple transactions fighting for same records\n- **Incorrect Statistics**: Race in sync state updates\n- **Resource Exhaustion**: Multiple Google API calls simultaneously\n\n## Race Scenarios\n1. User clicks sync button twice quickly\n2. Scheduler triggers sync while manual sync running\n3. Multiple API requests trigger full_sync directly\n4. Webhook and scheduler sync overlap\n\n## Required Fix\n1. Move lock to instance level, protect all sync methods\n2. Add distributed lock for multi-instance deployments\n3. Add sync_in_progress flag check before lock acquisition\n4. Return 409 Conflict if sync already running\n5. Add integration tests for concurrent sync attempts","status":"open","priority":1,"issue_type":"bug","created_at":"2026-01-09T21:18:56.212989187-08:00","created_by":"rohan","updated_at":"2026-01-09T21:18:56.212989187-08:00","labels":["backend","bug","concurrency","race-condition"]}
{"id":"google-contacts-cisco-bhr","title":"Bug: UI version number not syncing with Python package version","description":"## Problem\n\nThe version number displayed in the UI is fixed at v0.1.0 and does not stay in sync with the version defined in google_contacts_cisco/_version.py (currently v0.1.1).\n\n## Root Cause\n\n- Frontend version is hardcoded in frontend/package.json (0.1.0)\n- Vite config reads version from package.json and injects as __APP_VERSION__\n- BaseLayout.vue displays the hardcoded version from build time\n- When Python version is bumped via bumpversion, frontend package.json is not updated\n- No single source of truth for version number\n\n## Current Architecture\n\n- Python version: Defined in google_contacts_cisco/_version.py (v0.1.1)\n- Backend: Already exposes version via /health endpoint\n- Frontend: Hardcoded in package.json, injected at build time via Vite\n- Version management: .bumpversion.toml only updates Python files, not package.json\n\n## Proposed Solution\n\n**Primary Fix: Fetch version from backend API at runtime**\n\n1. Create dedicated /api/version endpoint (or use existing /health endpoint)\n2. Frontend fetches version from backend on component mount\n3. Display fetched version with loading state and error handling\n4. Remove reliance on hardcoded package.json version\n\n**Secondary Fix: Keep package.json in sync for consistency**\n\n5. Update .bumpversion.toml to also bump frontend/package.json version\n6. This ensures both sources stay in sync during version bumps","design":"## Files to Modify\n\n### Backend\n- google_contacts_cisco/api/routes.py or new google_contacts_cisco/api/version.py - Add version endpoint\n- google_contacts_cisco/api/schemas.py - Add VersionResponse model\n- tests/api/test_routes.py or new tests/api/test_version.py - Add tests\n\n### Frontend\n- frontend/src/api/client.ts - Add fetchVersion function\n- frontend/src/types/api.ts - Add VersionResponse type\n- frontend/src/components/BaseLayout.vue - Update to fetch version from API\n- frontend/src/env.d.ts - Keep as fallback\n\n### Version Management\n- .bumpversion.toml - Add package.json to version bump files\n\n### Tests\n- tests/api/test_version.py - Backend tests for version endpoint\n\n## Implementation Notes\n\n- The backend /health endpoint already returns version - evaluate if this is sufficient or if dedicated /api/version is better\n- Frontend should handle API errors gracefully and fall back to build-time version\n- Consider caching version response to avoid repeated API calls\n- Version fetch should not block UI rendering\n- Ensure version endpoint does not require authentication\n\n## Testing Strategy\n\n1. Unit tests for backend version endpoint\n2. Unit tests for frontend version fetch logic\n3. Integration test: verify version in UI matches _version.py\n4. Test bumpversion workflow: verify both files update correctly\n5. Test error cases: backend down, network error, invalid response","acceptance_criteria":"### Backend Changes\n- [ ] Create /api/version endpoint that returns current version from _version.py\n  - Response format: { version: 0.1.1 }\n  - Endpoint should be simple and fast (no authentication required)\n  - Add type schema for response (Pydantic model)\n  - Alternative: Confirm /health endpoint is suitable and document its use\n\n### Frontend Changes\n- [ ] Create API client function to fetch version from backend\n  - Add to frontend/src/api/client.ts or new version.ts file\n  - Add TypeScript type for version response\n  - Include error handling\n- [ ] Update BaseLayout.vue to fetch version from API on mount\n  - Use onMounted lifecycle hook to fetch version\n  - Display loading state while fetching (show v... or skeleton)\n  - Display fetched version once loaded\n  - Fallback to __APP_VERSION__ if fetch fails (graceful degradation)\n  - Add error handling with console warning if fetch fails\n- [ ] Update TypeScript types in frontend/src/types/api.ts\n  - Add VersionResponse interface\n\n### Version Management\n- [ ] Update .bumpversion.toml to include frontend/package.json\n  - Add new [[tool.bumpversion.files]] entry\n  - Set correct search/replace pattern for package.json version field\n  - Test that bumpversion updates both Python and frontend versions\n\n### Testing\n- [ ] Add backend test for /api/version endpoint\n  - Test returns correct version from _version.py\n  - Test response schema matches Pydantic model\n  - Add to appropriate test file in tests/api/\n- [ ] Add frontend unit test for version fetching\n  - Mock API response\n  - Test loading state\n  - Test error handling\n  - Test fallback behavior\n- [ ] Manual testing checklist:\n  - [ ] Version displays correctly on initial page load\n  - [ ] Version matches _version.py value\n  - [ ] Works when backend is available\n  - [ ] Graceful fallback when backend is unavailable\n  - [ ] Version updates after running bumpversion command\n\n### Documentation\n- [ ] Update README or docs with version synchronization approach\n- [ ] Document bumpversion usage for developers\n- [ ] Add comment in BaseLayout.vue explaining version fetch logic\n\n### Verification Steps\nAfter implementation:\n1. Run backend and frontend locally\n2. Verify UI displays correct version (should be v0.1.1)\n3. Change version in _version.py to v0.2.0\n4. Restart backend\n5. Refresh frontend - should show v0.2.0\n6. Run bumpversion: bump-my-version bump patch\n7. Verify both _version.py and package.json are updated\n8. All tests pass","status":"closed","priority":2,"issue_type":"bug","estimated_minutes":120,"created_at":"2026-01-09T07:26:26.293999596Z","created_by":"vscode","updated_at":"2026-01-09T20:39:25.566192588-08:00","closed_at":"2026-01-09T20:39:25.566192588-08:00","close_reason":"Closed","labels":["backend","frontend","version-sync"]}
{"id":"google-contacts-cisco-d0p","title":"Testing: Missing test coverage for OAuth edge cases","description":"## Problem\nOAuth tests exist but miss critical edge cases:\n1. No tests for state parameter validation (CSRF)\n2. No tests for concurrent token refresh\n3. Missing tests for token expiry during request\n4. No tests for revoked token scenarios\n5. Integration tests don't cover callback errors\n\n## Current Coverage Gaps\n```python\n# auth/oauth.py - Missing test coverage:\n- handle_oauth_callback with invalid state\n- get_credentials with expired refresh token\n- revoke_credentials with network failure\n- Concurrent refresh_token calls\n- Token file corruption scenarios\n```\n\n## Critical Untested Scenarios\n1. **CSRF Attack**: Callback with forged state parameter\n2. **Race Condition**: Two processes refresh token simultaneously  \n3. **Token Revocation**: User revokes in Google, app tries to refresh\n4. **Network Failures**: Timeout during token exchange\n5. **File Corruption**: token.json becomes corrupted\n6. **Permission Errors**: Cannot write to token file\n\n## Impact\n- **Security Vulnerabilities**: CSRF not tested\n- **Production Bugs**: Edge cases fail in production\n- **Brittle Auth**: Small issues cause complete auth failure\n- **Low Confidence**: Cannot trust auth system reliability\n\n## Required Fix\n1. Add unit tests for all OAuth error paths\n2. Add integration tests for OAuth flow variations\n3. Mock Google API failure scenarios\n4. Test concurrent token refresh with threading\n5. Test token file I/O errors\n6. Add security-focused OAuth tests\n7. Achieve \u003e90% coverage on auth module\n\n## Test Cases Needed\n```python\ndef test_oauth_callback_invalid_state():\ndef test_token_refresh_concurrent():\ndef test_token_file_permission_denied():\ndef test_credentials_revoked_externally():\ndef test_oauth_callback_network_timeout():\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T21:21:08.924287948-08:00","created_by":"rohan","updated_at":"2026-01-09T21:21:08.924287948-08:00","labels":["backend","coverage","oauth","testing"]}
{"id":"google-contacts-cisco-dis","title":"Fix phone number validation for special formats and prefixes","description":"## Bug Summary\n\nSome contacts are stored in Google in formats that the phone utils consider invalid:\n1. Phone numbers with special formatting like `(XXX) XXX-XXXX` may fail in edge cases\n2. Phone numbers with dialing prefixes like `*67`, `*82`, `#31#` (caller ID block/unblock)\n3. Phone numbers with country codes using alternative formats like `+46` followed by spaces\n\n## Current Behavior\n\nThe `PhoneNumberSchema.normalize_phone_number` validator:\n1. Attempts to normalize using the `phonenumbers` library\n2. Falls back to extracting digits and `+` characters only\n3. Fails to handle valid dialing prefixes that include `*` or `#`\n4. May reject valid phone numbers that contain special prefixes\n\nThis causes contacts with these formats to:\n- Be skipped during sync from Google Contacts\n- Not appear in the directory\n- Not be searchable by phone number\n\n## Root Cause\n\nThe fallback normalization in `google_contacts_cisco/schemas/contact.py` line 56:\n```python\ndigits = \"\".join(c for c in value if c.isdigit() or c == \"+\")\n```\n\nThis only preserves digits and `+`, dropping valid prefixes like `*67`, `*82`, `#31#`.\n\n## Expected Behavior\n\nThe phone number validator should:\n1. Handle North American dialing prefixes: `*67`, `*82`, `*66`, etc.\n2. Handle international dialing prefixes: `#31#`, `*31#` (Europe)\n3. Strip prefixes before normalization but preserve them in display value\n4. Continue to normalize the actual phone number portion\n5. Handle edge cases in formatted numbers like `(XXX) XXX-XXXX`\n\n## Acceptance Criteria\n\n### 1. Phone Prefix Support\n- [ ] North American `*67` (hide caller ID) is handled correctly\n- [ ] North American `*82` (show caller ID) is handled correctly\n- [ ] European `#31#` prefix is handled correctly\n- [ ] International `+` country codes continue to work\n- [ ] Prefix is preserved in `display_value` but stripped for normalization\n\n### 2. Format Handling\n- [ ] `(XXX) XXX-XXXX` format works in all edge cases\n- [ ] Numbers with spaces and prefixes: `*67 (555) 123-4567`\n- [ ] Mixed formats: `+1 *67 5551234567` are handled gracefully\n\n### 3. Backward Compatibility\n- [ ] All existing phone number formats continue to work\n- [ ] No regression in existing test suite\n- [ ] E.164 normalization still works for valid numbers\n\n### 4. Error Handling\n- [ ] Invalid phone numbers still raise appropriate errors\n- [ ] Numbers with only special characters are rejected\n- [ ] Empty phone numbers are rejected\n\n### 5. Testing\n- [ ] Add test cases for `*67` prefix\n- [ ] Add test cases for `*82` prefix  \n- [ ] Add test cases for `#31#` prefix\n- [ ] Add test cases for mixed prefix + format combinations\n- [ ] Add test cases for international numbers with prefixes\n- [ ] Add integration test with real Google contact data\n- [ ] Verify existing tests still pass\n\n## Implementation Plan\n\n### Step 1: Enhance `_clean_input` method\nFile: `google_contacts_cisco/utils/phone_utils.py`\n\nAdd prefix detection and stripping:\n- Detect common dialing prefixes at start of number\n- Strip them before normalization\n- Return both cleaned number and detected prefix\n\n### Step 2: Update `normalize` method\nFile: `google_contacts_cisco/utils/phone_utils.py`\n\n- Use enhanced `_clean_input` to extract prefix\n- Normalize the number portion without prefix\n- Include prefix in display value if desired\n\n### Step 3: Update fallback in PhoneNumberSchema\nFile: `google_contacts_cisco/schemas/contact.py`\n\n- Use enhanced cleaning logic for fallback\n- Allow common prefixes in fallback extraction\n- Preserve display value with prefix\n\n### Step 4: Add comprehensive tests\nFile: `tests/unit/utils/test_phone_utils.py`\n\nNew test class: `TestPhoneNumberPrefixes`\n- Test each prefix type\n- Test prefix + various formats\n- Test edge cases\n\nFile: `tests/unit/schemas/test_contact.py`\n- Test schema validation with prefixes\n- Test display value preservation\n\n### Step 5: Update documentation\nFile: `google_contacts_cisco/utils/phone_utils.py`\n- Document supported prefix patterns\n- Add examples in docstrings\n\n## Testing Strategy\n\n1. **Unit Tests**: Test each prefix pattern individually\n2. **Integration Tests**: Test with realistic Google contact data\n3. **Regression Tests**: Ensure all existing tests pass\n4. **Edge Cases**: Empty strings, invalid formats, multiple prefixes\n\n## Files to Modify\n\n1. `google_contacts_cisco/utils/phone_utils.py` - Add prefix handling\n2. `google_contacts_cisco/schemas/contact.py` - Update fallback logic\n3. `tests/unit/utils/test_phone_utils.py` - Add prefix tests\n4. `tests/unit/schemas/test_contact.py` - Add schema validation tests\n\n## References\n\n- North American dial prefixes: https://en.wikipedia.org/wiki/Vertical_service_code\n- European caller ID prefixes: https://en.wikipedia.org/wiki/Caller_ID#Blocking\n- E.164 format: https://en.wikipedia.org/wiki/E.164\n\n## Priority\n\n**P1 (High)** - Users are losing contact data during sync\n\n## Estimated Effort\n\n3 hours\n","status":"closed","priority":1,"issue_type":"bug","estimated_minutes":180,"created_at":"2026-01-09T07:25:24.266991592Z","created_by":"vscode","updated_at":"2026-01-09T20:38:22.088493486-08:00","closed_at":"2026-01-09T20:38:22.088493486-08:00","close_reason":"Closed"}
{"id":"google-contacts-cisco-ioj","title":"Contact Data Models","description":"# Unknown\n\n\n## Overview\n\nDefine Pydantic schemas for validating and transforming contact data from Google People API format to our internal database format. These schemas ensure type safety and data consistency throughout the application.\n\n## Priority\n\n**P0 (Critical)** - Required for MVP\n\n## Dependencies\n\n- Task 1.2: Database Setup\n- Task 2.2: Google API Client\n\n## Objectives\n\n1. Create Pydantic schemas for Google API response parsing\n2. Create schemas for internal contact representation\n3. Implement transformation logic from Google format to database format\n4. Handle missing or optional fields gracefully\n5. Validate phone numbers and email addresses\n6. Test schema validation and transformations\n\n## Technical Context\n\n### Google People API Person Resource Structure\n```json\n{\n  \"resourceName\": \"people/c1234567890\",\n  \"etag\": \"%EgcBARkE...\",\n  \"names\": [{\n    \"displayName\": \"John Doe\",\n    \"familyName\": \"Doe\",\n    \"givenName\": \"John\"\n  }],\n  \"phoneNumbers\": [{\n    \"value\": \"(555) 123-4567\",\n    \"type\": \"mobile\",\n    \"formattedType\": \"Mobile\"\n  }],\n  \"emailAddresses\": [{\n    \"value\": \"john@example.com\",\n    \"type\": \"work\"\n  }],\n  \"organizations\": [{\n    \"name\": \"Acme Corp\",\n    \"title\": \"Engineer\"\n  }],\n  \"metadata\": {\n    \"sources\": [{\n      \"type\": \"CONTACT\",\n      \"id\": \"1234567890\"\n    }]\n  }\n}\n```\n\n## Implementation Steps\n\n### 1. Create API Schemas (Google Format)\n\nCreate `google_contacts_cisco/api/schemas.py`:\n\n```python\n\"\"\"Pydantic schemas for API requests and responses.\"\"\"\nfrom typing import Optional, List\nfrom pydantic import BaseModel, Field, field_validator, EmailStr\n\n\nclass GoogleName(BaseModel):\n    \"\"\"Name from Google People API.\"\"\"\n    display_name: Optional[str] = Field(None, alias=\"displayName\")\n    given_name: Optional[str] = Field(None, alias=\"givenName\")\n    family_name: Optional[str] = Field(None, alias=\"familyName\")\n    \n    class Config:\n        populate_by_name = True\n\n\nclass GooglePhoneNumber(BaseModel):\n    \"\"\"Phone number from Google People API.\"\"\"\n    value: str\n    type: Optional[str] = None\n    formatted_type: Optional[str] = Field(None, alias=\"formattedType\")\n    \n    class Config:\n        populate_by_name = True\n\n\nclass GoogleEmailAddress(BaseModel):\n    \"\"\"Email address from Google People API.\"\"\"\n    value: EmailStr\n    type: Optional[str] = None\n    \n    class Config:\n        populate_by_name = True\n\n\nclass GoogleOrganization(BaseModel):\n    \"\"\"Organization from Google People API.\"\"\"\n    name: Optional[str] = None\n    title: Optional[str] = None\n    \n    class Config:\n        populate_by_name = True\n\n\nclass GoogleMetadataSource(BaseModel):\n    \"\"\"Metadata source from Google People API.\"\"\"\n    type: str\n    id: str\n    etag: Optional[str] = None\n    \n    class Config:\n        populate_by_name = True\n\n\nclass GoogleMetadata(BaseModel):\n    \"\"\"Metadata from Google People API.\"\"\"\n    sources: List[GoogleMetadataSource] = []\n    deleted: Optional[bool] = None\n    \n    class Config:\n        populate_by_name = True\n\n\nclass GooglePerson(BaseModel):\n    \"\"\"Person from Google People API.\"\"\"\n    resource_name: str = Field(..., alias=\"resourceName\")\n    etag: Optional[str] = None\n    names: List[GoogleName] = []\n    phone_numbers: List[GooglePhoneNumber] = Field(default_factory=list, alias=\"phoneNumbers\")\n    email_addresses: List[GoogleEmailAddress] = Field(default_factory=list, alias=\"emailAddresses\")\n    organizations: List[GoogleOrganization] = []\n    metadata: Optional[GoogleMetadata] = None\n    \n    class Config:\n        populate_by_name = True\n    \n    def get_display_name(self) -\u003e str:\n        \"\"\"Get display name for contact.\n        \n        Returns:\n            Display name, falling back to email or resource name\n        \"\"\"\n        # Try names array first\n        if self.names:\n            name = self.names[0]\n            if name.display_name:\n                return name.display_name\n            elif name.given_name and name.family_name:\n                return f\"{name.given_name} {name.family_name}\"\n            elif name.given_name:\n                return name.given_name\n            elif name.family_name:\n                return name.family_name\n        \n        # Fall back to email\n        if self.email_addresses:\n            return self.email_addresses[0].value\n        \n        # Last resort: resource name\n        return self.resource_name\n    \n    def is_deleted(self) -\u003e bool:\n        \"\"\"Check if contact is deleted.\n        \n        Returns:\n            True if contact is marked as deleted\n        \"\"\"\n        return self.metadata and self.metadata.deleted is True\n    \n    def get_primary_etag(self) -\u003e Optional[str]:\n        \"\"\"Get primary etag from metadata sources.\n        \n        Returns:\n            Etag string or None\n        \"\"\"\n        if self.etag:\n            return self.etag\n        \n        if self.metadata and self.metadata.sources:\n            for source in self.metadata.sources:\n                if source.type == \"CONTACT\" and source.etag:\n                    return source.etag\n        \n        return None\n\n\nclass GoogleConnectionsResponse(BaseModel):\n    \"\"\"Response from Google People API connections list.\"\"\"\n    connections: List[GooglePerson] = []\n    next_page_token: Optional[str] = Field(None, alias=\"nextPageToken\")\n    next_sync_token: Optional[str] = Field(None, alias=\"nextSyncToken\")\n    total_people: Optional[int] = Field(None, alias=\"totalPeople\")\n    total_items: Optional[int] = Field(None, alias=\"totalItems\")\n    \n    class Config:\n        populate_by_name = True\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Test Schema Parsing**:\n   ```python\n   from google_contacts_cisco.api.schemas import GooglePerson\n   \n   # Parse Google API response\n   data = {\n       \"resourceName\": \"people/c123\",\n       \"names\": [{\"displayName\": \"John Doe\"}],\n       \"phoneNumbers\": [{\"value\": \"(555) 123-4567\"}]\n   }\n   \n   person = GooglePerson(**data)\n   print(person.get_display_name())  # \"John Doe\"\n   ```\n\n2. **Test Transformation**:\n   ```python\n   from google_contacts_cisco.services.contact_transformer import transform_google_person_to_contact\n   \n   contact = transform_google_person_to_contact(person)\n   print(contact.display_name)  # \"John Doe\"\n   print(contact.phone_numbers[0].value)  # \"5551234567\"\n   ```\n\n3. **Run Tests**:\n   ```bash\n   pytest tests/test_schemas.py tests/test_contact_transformer.py -v\n   ```\n\n## Notes\n\n- **Pydantic V2**: Using Pydantic 2.x features (Config, validators)\n- **Alias Support**: Google uses camelCase, we use snake_case internally\n- **Phone Normalization**: Strips formatting for database storage, preserves original for display\n- **Display Name**: Multiple fallback strategies ensure every contact has a name\n- **Type Safety**: All schemas fully typed for mypy compliance\n- **Validation**: Pydantic validates data automatically\n\n## Common Issues\n\n1. **Missing Names**: Some contacts have no name - fallback to email or resource name\n2. **Multiple Phone Numbers**: Mark first as primary by default\n3. **Phone Formatting**: Google returns various formats - normalize for search\n4. **Deleted Contacts**: Check metadata.deleted flag\n5. **Missing Etag**: May be in metadata.sources instead of top level\n\n## Related Documentation\n\n- Pydantic: https://docs.pydantic.dev/\n- Google Person Resource: https://developers.google.com/people/api/rest/v1/people#Person\n- Phone Number Formats: https://en.wikipedia.org/wiki/National_conventions_for_writing_telephone_numbers\n\n## Estimated Time\n\n3-4 hours","acceptance_criteria":"☐ Pydantic schemas parse Google API responses correctly\n☐ Schemas handle missing optional fields\n☐ Phone number validation works\n☐ Email validation works\n☐ Display name generation handles various name configurations\n☐ Transformation from Google to database format is tested\n☐ Deleted contacts are marked properly\n☐ Metadata and etag are preserved\n☐ All schemas have proper type hints","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":180,"created_at":"2026-01-08T03:10:59.171710603Z","created_by":"vscode","updated_at":"2026-01-08T03:26:32.334727989Z","closed_at":"2026-01-08T03:11:16.456511253Z","close_reason":"Closed","labels":["P0","backend","models"]}
{"id":"google-contacts-cisco-is8","title":"Documentation: API documentation missing error responses and rate limits","description":"## Problem\nAPI documentation incomplete in several areas:\n1. OpenAPI docs don't document error responses\n2. No rate limiting documentation\n3. Missing authentication requirements per endpoint\n4. No examples of error scenarios\n5. Postman collection may be outdated\n\n## Documentation Gaps\n```python\n# main.py FastAPI instance has good descriptions\n# But error responses not documented in endpoint decorators\n@router.get(\"/contacts\")\nasync def get_contacts(...):\n    # Missing: @responses decorator for 401, 500, etc.\n```\n\n## Missing Information\n1. **Error Codes**: What errors can each endpoint return?\n2. **Rate Limits**: Are there any rate limits?\n3. **Auth Requirements**: Which endpoints need auth?\n4. **Pagination**: How does pagination work?\n5. **Sorting/Filtering**: What params are supported?\n6. **Examples**: Request/response examples\n\n## Impact\n- **Integration Difficulty**: Users struggle to integrate\n- **Support Burden**: More support questions\n- **Trial \u0026 Error**: Users must test to learn API\n- **Broken Clients**: Clients don't handle errors properly\n\n## Required Fix\n1. Add @responses decorator to all endpoints\n2. Document error response schemas\n3. Add authentication notes to each endpoint\n4. Document rate limiting policy\n5. Update Postman collection with error examples\n6. Add API usage examples to docs/api.md\n7. Generate complete OpenAPI spec\n8. Add integration guide with code samples\n\n## Example Addition\n```python\n@router.get(\"/contacts\", \n    responses={\n        200: {\"model\": ContactListResponse},\n        401: {\"description\": \"Not authenticated\"},\n        500: {\"description\": \"Server error\"}\n    }\n)\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T21:21:49.6016182-08:00","created_by":"rohan","updated_at":"2026-01-09T21:21:49.6016182-08:00","labels":["api","documentation","openapi"]}
{"id":"google-contacts-cisco-iw1","title":"Security: Missing email_addresses relationship in Contact model","description":"## Problem\nThe `Contact` model (`google_contacts_cisco/models/contact.py`) defines relationship to `phone_numbers` but is missing the `email_addresses` relationship, yet:\n1. The schema references EmailAddress in `contact_repository.py` line 451\n2. API responses include email_addresses in `api/contacts.py` line 297\n3. This causes AttributeError when accessing contact.email_addresses\n\n## Impact\n- **Runtime Errors**: AttributeError when retrieving contacts\n- **Data Loss**: Email addresses cannot be accessed or displayed\n- **API Inconsistency**: Breaks contact statistics endpoint\n\n## Affected Files\n- `google_contacts_cisco/models/contact.py` - Missing relationship\n- `google_contacts_cisco/repositories/contact_repository.py` - Lines 451, 465, 482\n- `google_contacts_cisco/api/contacts.py` - Line 297\n\n## Current Code\n```python\n# contact.py - Only has phone_numbers\nphone_numbers = relationship(\n    \"PhoneNumber\", back_populates=\"contact\", cascade=\"all, delete-orphan\"\n)\n# email_addresses relationship is MISSING\n```\n\n## Required Fix\n1. Add EmailAddress model if missing (check models directory)\n2. Add email_addresses relationship to Contact model\n3. Ensure EmailAddress model has contact_id foreign key\n4. Update database schema/migration\n5. Add tests for email functionality","status":"open","priority":0,"issue_type":"bug","created_at":"2026-01-09T21:18:17.559987578-08:00","created_by":"rohan","updated_at":"2026-01-09T21:18:17.559987578-08:00","labels":["backend","bug","data-model"]}
{"id":"google-contacts-cisco-iwj","title":"Security: No rate limiting on authentication endpoints","description":"## Problem\nAuthentication endpoints have no rate limiting:\n1. `/auth/google` can be spammed\n2. `/auth/callback` vulnerable to brute force\n3. `/auth/refresh` can be abused\n4. No CAPTCHA or IP-based throttling\n5. Could enable DoS or credential stuffing\n\n## Vulnerable Endpoints\n```python\n# api/routes.py - No rate limiting decorators\n@router.get(\"/google\")  # Can spam OAuth initiations\n@router.get(\"/callback\")  # Can brute force codes\n@router.post(\"/refresh\")  # Can spam refresh attempts\n```\n\n## Attack Vectors\n1. **OAuth Spam**: Flood with /auth/google requests\n2. **Code Brute Force**: Try random codes at /callback\n3. **Refresh Abuse**: Spam token refresh endpoint\n4. **DoS**: Overwhelm server with auth requests\n5. **Credential Stuffing**: Automated OAuth attempts\n\n## Impact\n- **DoS Vulnerability**: Service can be overwhelmed\n- **Security Risk**: Brute force attacks possible\n- **Cost**: Unnecessary Google API calls\n- **Performance**: Auth endpoints consume resources\n\n## Required Fix\n1. Implement rate limiting middleware (slowapi/fastapi-limiter)\n2. Add rate limits per IP and per endpoint\n3. Add exponential backoff for failed attempts\n4. Add CAPTCHA for repeated failures (optional)\n5. Log and alert on rate limit violations\n6. Add rate limit headers (X-RateLimit-Limit, etc.)\n7. Document rate limits in API docs\n\n## Suggested Limits\n```python\n# Per IP address\n/auth/google: 10 requests/minute\n/auth/callback: 5 requests/minute  \n/auth/refresh: 20 requests/hour\n/auth/revoke: 5 requests/hour\n\n# Global  \nAll auth endpoints: 1000 requests/minute\n```\n\n## Implementation\n```python\nfrom slowapi import Limiter\nfrom slowapi.util import get_remote_address\n\nlimiter = Limiter(key_func=get_remote_address)\n\n@router.get(\"/google\")\n@limiter.limit(\"10/minute\")\nasync def auth_google(...):\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T21:22:14.116211974-08:00","created_by":"rohan","updated_at":"2026-01-09T21:22:14.116211974-08:00","labels":["auth","backend","rate-limiting","security"]}
{"id":"google-contacts-cisco-jjm","title":"Contacts Directory with Integrated Search","description":"# Unknown\n\n\n## Overview\n\nCreate a comprehensive Vue 3 contact management interface with real-time integrated search, alphabetical filtering, grid/list views, and contact details modal. This combines traditional directory browsing with powerful search capabilities in a single, cohesive interface.\n\n## Priority\n\n**P1 (High)** - Required for MVP\n\n## Dependencies\n\n- Task 1.2: Database Setup\n- Task 2.1: Contact Data Models\n- Task 5.3: Search API Endpoints\n- Task 6.1: Frontend Framework Setup (Vue 3 + Vite + TypeScript)\n\n## Objectives\n\n1. Create contacts list page with real-time search integrated\n2. Display contacts in grid/list view toggle\n3. Show contact details in modal\n4. Implement alphabetical filtering (A-Z, #)\n5. Add sorting (by name, recently updated)\n6. Integrate real-time search with debouncing\n7. Add pagination for large contact lists\n8. Make fully responsive (mobile/tablet/desktop)\n9. Type-safe with full TypeScript coverage\n10. Test with various data sizes (1-10,000 contacts)\n\n## Technical Context\n\n### Integrated Search Architecture\n- **Single Page**: One `/contacts` route with search integrated\n- **Search Bar**: Prominent search input at top\n- **Dual Mode**: \n  - **Browse Mode**: Alphabetical filtering, pagination (default)\n  - **Search Mode**: Real-time search results (when typing)\n- **Smooth Transition**: Seamlessly switch between modes\n\n## Implementation Steps\n\n### 1. Define TypeScript Types\n\nCreate `frontend/src/types/contact.ts`:\n\n```typescript\n/**\n * Contact-related TypeScript types\n */\n\nexport interface PhoneNumber {\n  id: string;\n  value: string;\n  display_value: string;\n  type: string;\n  primary: boolean;\n}\n\nexport interface EmailAddress {\n  id: string;\n  value: string;\n  type: string;\n  primary: boolean;\n}\n\nexport interface Contact {\n  id: string;\n  display_name: string;\n  given_name?: string;\n  family_name?: string;\n  phone_numbers: PhoneNumber[];\n  email_addresses: EmailAddress[];\n  updated_at?: string;\n}\n\nexport interface ContactListResponse {\n  contacts: Contact[];\n  total: number;\n  offset: number;\n  limit: number;\n  has_more: boolean;\n}\n\nexport interface ContactStats {\n  total: number;\n  by_letter: Record\u003cstring, number\u003e;\n}\n\nexport interface SearchResult extends Contact {\n  match_type: 'exact' | 'prefix' | 'substring' | 'phone';\n  match_field?: string;\n  relevance_score?: number;\n}\n\nexport interface SearchResponse {\n  results: SearchResult[];\n  count: number;\n  query: string;\n  elapsed_ms: number;\n}\n\nexport type ViewMode = 'grid' | 'list';\nexport type SortOrder = 'name' | 'recent';\nexport type LetterGroup = 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '#' | '';\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Install Dependencies**:\n   ```bash\n   cd frontend\n   npm install\n   ```\n\n2. **Start Development Servers**:\n   ```bash\n   # Terminal 1: Backend\n   uv run python -m google_contacts_cisco.main\n\n   # Terminal 2: Frontend\n   cd frontend \u0026\u0026 npm run dev\n   ```\n\n3. **Test Contacts Page**:\n   - Visit http://localhost:5173/contacts\n   - Should show search bar and contact cards/list\n\n4. **Test Real-Time Search**:\n   - Type in search box\n   - Results should update after ~300ms\n   - Highlighting should work\n\n5. **Test Alphabetical Filtering**:\n   - Click letter buttons (A, B, C, etc.)\n   - Contacts should filter by first letter\n\n6. **Test View Toggle**:\n   - Switch between Grid and List views\n   - Layout should change\n   - Preference should persist (localStorage)\n\n7. **Test Contact Modal**:\n   - Click on any contact\n   - Modal should open with full details\n   - Click X or outside to close\n   - Press Escape to close\n\n8. **Test Pagination**:\n   - If \u003e30 contacts, pagination should appear\n   - Click Next/Previous\n   - Page should update\n\n9. **Test Responsive**:\n   - Resize browser\n   - Mobile: 1 column, tablet: 2 columns, desktop: 3 columns\n\n10. **Test TypeScript**:\n    ```bash\n    cd frontend\n    npm run type-check\n    ```\n\n11. **Run Tests**:\n    ```bash\n    cd frontend\n    npm run test:unit\n    ```\n\n## Notes\n\n- **Integrated Search**: Search seamlessly integrated into main contacts view\n- **Dual Mode**: Browse with filters OR search - smooth transition\n- **Real-Time**: Debounced search prevents excessive API calls\n- **Type-Safe**: Full TypeScript coverage\n- **Performance**: Client-side caching, lazy loading\n- **UX**: Loading states, empty states, error handling\n- **Responsive**: Mobile-first design\n- **Accessible**: Keyboard navigation, semantic HTML\n- **Persist Preferences**: View mode saved to localStorage\n\n## Common Issues\n\n1. **Search Lag**: Adjust debounce delay if needed\n2. **Type Errors**: Run `npm run type-check`\n3. **Highlight Issues**: Escape special regex characters\n4. **Modal Not Closing**: Check z-index and event handling\n5. **CORS**: Ensure backend allows frontend origin\n\n## Performance Optimization\n\nFor large contact lists (\u003e1000):\n1. Implement virtual scrolling (vue-virtual-scroller)\n2. Add request cancellation for abandoned searches\n3. Cache search results client-side\n4. Lazy load images if added\n5. Use Web Workers for filtering\n\n## Related Documentation\n\n- Vue 3 Composition API: https://vuejs.org/guide/extras/composition-api-faq.html\n- TypeScript with Vue: https://vuejs.org/guide/typescript/overview.html\n- Tailwind CSS: https://tailwindcss.com/docs\n- Vitest: https://vitest.dev/\n\n## Estimated Time\n\n8-10 hours (combines old tasks 17 + 18)","acceptance_criteria":"☐ Search bar is prominent and functional\n☐ Real-time search works with debouncing\n☐ Alphabetical filtering works alongside search\n☐ Grid and list views toggle correctly\n☐ Sorting by name and recent works\n☐ Pagination handles 100+ contacts\n☐ Contact detail modal shows full information\n☐ Responsive on mobile, tablet, desktop\n☐ Loading states shown appropriately\n☐ Empty states handled gracefully\n☐ TypeScript types cover all components\n☐ Tests cover search and filtering\n☐ Performance acceptable with 1000+ contacts","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":1,"issue_type":"task","estimated_minutes":480,"created_at":"2026-01-08T03:10:59.476392545Z","created_by":"vscode","updated_at":"2026-01-08T05:28:54.792770277Z","closed_at":"2026-01-08T05:28:54.792770277Z","close_reason":"Closed","labels":["P1","contacts","frontend","search"]}
{"id":"google-contacts-cisco-jut","title":"Frontend Framework Setup","description":"# Unknown\n\n\n## Overview\n\nSet up a modern frontend framework using Vue 3 with Vite and TypeScript, integrated with FastAPI backend. This provides reactive data binding, component architecture, and type safety for building a maintainable web interface.\n\n## Priority\n\n**P1 (High)** - Required for MVP web interface\n\n## Dependencies\n\n- Task 1.1: Environment Setup\n\n## Objectives\n\n1. Set up Vite with Vue 3 and TypeScript\n2. Configure Tailwind CSS with PostCSS\n3. Set up Vue Router for client-side routing\n4. Create base layout and components\n5. Configure API client with TypeScript types\n6. Set up development and production builds\n7. Integrate with FastAPI static file serving\n8. Test hot module replacement (HMR)\n\n## Technical Context\n\n### Technology Stack\n- **Vue 3**: Composition API with `\u003cscript setup\u003e` syntax\n- **Vite**: Fast dev server and optimized builds\n- **TypeScript**: Type safety and better DX\n- **Vue Router**: Client-side routing\n- **Tailwind CSS**: Utility-first CSS framework\n- **Pinia** (optional): State management if needed\n\n## Implementation Steps\n\n### 1. Create Frontend Project Structure\n\n```bash\n# Create frontend directory\nmkdir -p frontend\ncd frontend\n\n# Initialize Vite project with Vue + TypeScript\nnpm create vite@latest . -- --template vue-ts\n\n# Install dependencies\nnpm install\n\n# Install additional dependencies\nnpm install -D tailwindcss postcss autoprefixer\nnpm install vue-router@4\nnpm install axios\n\n# Initialize Tailwind\nnpx tailwindcss init -p\n```\n\n## Verification\n\nAfter completing this task:\n\n## Notes\n\n- **Vite Proxy**: Development proxy forwards API calls to FastAPI backend\n- **TypeScript**: Provides type safety for API responses and props\n- **Vue Router**: Uses HTML5 history mode for clean URLs\n- **Production Build**: Vite builds to `static/dist/` for FastAPI to serve\n- **Hot Module Replacement**: Vite provides instant feedback during development\n- **Composition API**: Modern Vue 3 approach with `\u003cscript setup\u003e`\n- **Path Aliases**: `@/` maps to `src/` for cleaner imports\n\n## Common Issues\n\n1. **Port Conflicts**: Change Vite port in `vite.config.ts` if 5173 is taken\n2. **CORS Errors**: Ensure proxy is configured correctly in development\n3. **Type Errors**: Run `npm run type-check` to find TypeScript issues\n4. **Build Failures**: Check that all imports are correct and types are defined\n5. **Routing Issues**: Ensure FastAPI serves `index.html` for SPA routes\n6. **API 404s**: Verify proxy configuration matches FastAPI routes\n\n## Performance Optimization\n\n- Vite automatically code-splits routes\n- Tree-shaking removes unused code\n- Tailwind purges unused CSS in production\n- Use `defineAsyncComponent` for lazy loading\n- Enable Vite build compression plugin\n\n## Future Enhancements\n\n- Add Pinia for centralized state management\n- Add Vue DevTools integration\n- Add unit tests with Vitest\n- Add E2E tests with Playwright\n- Add PWA support with vite-plugin-pwa\n- Add i18n for internationalization\n- Add component library (Headless UI)\n\n## Related Documentation\n\n- Vue 3: https://vuejs.org/\n- Vite: https://vitejs.dev/\n- Vue Router: https://router.vuejs.org/\n- TypeScript: https://www.typescriptlang.org/\n- Tailwind CSS: https://tailwindcss.com/\n- Composition API: https://vuejs.org/guide/extras/composition-api-faq.html\n\n## Estimated Time\n\n5-6 hours","acceptance_criteria":"☐ Vite dev server runs with HMR\n☐ TypeScript compilation works without errors\n☐ Tailwind CSS is configured and working\n☐ Vue Router handles navigation\n☐ API client connects to FastAPI backend\n☐ Production build generates optimized files\n☐ FastAPI serves the Vue app\n☐ Types are defined for API responses\n☐ Components are properly typed\n☐ Tests run successfully","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":300,"created_at":"2026-01-08T03:10:59.371292962Z","created_by":"vscode","updated_at":"2026-01-08T03:26:33.948203554Z","closed_at":"2026-01-08T03:11:16.473965261Z","close_reason":"Closed","labels":["P0","frontend","infrastructure"]}
{"id":"google-contacts-cisco-kj7","title":"Code Quality: Inconsistent error handling patterns across API endpoints","description":"## Problem\nError handling varies significantly across endpoints:\n1. Some return JSON errors, others HTML (api/routes.py vs api/contacts.py)\n2. Inconsistent HTTP status codes for same errors\n3. Some endpoints catch Exception, others specific exceptions\n4. Error messages vary in format and detail level\n5. No standardized error response schema\n\n## Examples\n```python\n# api/routes.py line 107 - Returns 500 with HTTPException\nraise HTTPException(status_code=500, detail=\"...\")\n\n# api/contacts.py line 161 - Returns 500 different way\nraise HTTPException(status_code=500, detail=f\"Failed to...\")\n\n# api/directory_routes.py line 115 - Returns 200 with error XML!\nreturn _error_response(\"Error loading directory\")\n```\n\n## Inconsistencies\n1. **Error format**: Some f-string, some plain string\n2. **Status codes**: Authentication failure is 500 vs 401\n3. **Error details**: Some expose stack traces, others generic\n4. **Logging**: Some log exceptions, others don't\n5. **Response type**: JSON vs HTML vs XML\n\n## Impact\n- **API Confusion**: Clients can't parse errors reliably\n- **Debugging Difficulty**: Inconsistent logging\n- **Security**: Some errors leak implementation details\n- **Testing**: Hard to test error scenarios consistently\n\n## Required Fix\n1. Create standard ErrorResponse Pydantic model\n2. Implement global exception handler in main.py\n3. Standardize status codes per error type\n4. Separate user-facing and debug messages\n5. Add error code enum (AUTH_001, SYNC_002, etc)\n6. Log all errors with correlation IDs\n7. Update API documentation with error responses\n8. Add error handling tests for all endpoints\n\n## Suggested Standard\n```python\nclass ErrorResponse(BaseModel):\n    error_code: str\n    message: str\n    details: Optional[dict] = None\n    timestamp: datetime\n    request_id: str\n```","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T21:20:44.898719523-08:00","created_by":"rohan","updated_at":"2026-01-09T21:20:44.898719523-08:00","labels":["backend","code-quality","error-handling","refactor"]}
{"id":"google-contacts-cisco-l2i","title":"Frontend: API client has no retry logic or circuit breaker","description":"## Problem\nFrontend API client (`api/client.ts`) has no resilience patterns:\n1. No retry logic for failed requests\n2. No exponential backoff for rate limits\n3. No circuit breaker for cascading failures\n4. Timeout is hardcoded to 30s (line 37)\n5. No request cancellation for navigation\n\n## Current Implementation\n```typescript\n// api/client.ts lines 32-38\nthis.client = axios.create({\n  baseURL: import.meta.env.DEV ? '' : '',\n  timeout: 30000, // Fixed timeout, no retries\n})\n// No retry interceptor!\n```\n\n## Impact\n- **Flaky UX**: Transient failures not retried\n- **Slow Loading**: No progressive timeout\n- **Resource Waste**: Abandoned requests not cancelled\n- **Poor Mobile**: Network issues cause complete failure\n\n## Failure Scenarios\n1. Temporary network glitch → User sees error (should retry)\n2. Backend restart → All requests fail (should backoff)\n3. Rate limit → Should wait and retry, not error\n4. User navigates away → Request continues (should cancel)\n5. Slow endpoint → 30s wait with no feedback\n\n## Required Fix\n1. Implement axios-retry with exponential backoff\n2. Add circuit breaker pattern (e.g., cockatiel)\n3. Add request cancellation on route change\n4. Add loading states with progressive timeout\n5. Handle 429 rate limit with Retry-After\n6. Add request deduplication\n7. Add resilience tests\n\n## Implementation\n```typescript\nimport axiosRetry from 'axios-retry'\n\naxiosRetry(this.client, {\n  retries: 3,\n  retryDelay: axiosRetry.exponentialDelay,\n  retryCondition: (error) =\u003e {\n    return axiosRetry.isNetworkOrIdempotentRequestError(error)\n      || error.response?.status === 429\n  }\n})\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T21:21:39.886352561-08:00","created_by":"rohan","updated_at":"2026-01-09T21:21:39.886352561-08:00","labels":["api-client","frontend","resilience","ux"]}
{"id":"google-contacts-cisco-li5","title":"Security: Sensitive data in logs needs redaction","description":"## Problem\nApplication logs may expose sensitive information:\n1. OAuth tokens logged in debug mode\n2. Phone numbers logged in search queries\n3. Contact names in XML formatter logs\n4. API request/response bodies in axios interceptor\n5. Database connection strings in startup logs\n\n## Current Logging Issues\n```python\n# oauth.py line 130 - Token in logs\nlogger.info(\"Refreshing expired access token\")\n# Could log token value in some paths\n\n# api/client.ts lines 45-51 - Full request data logged\nconsole.error('API Error:', {\n    url: error.config?.url,\n    data: error.response?.data,  // May contain sensitive info\n})\n\n# sync_service.py - Contact data in logs\nlogger.info(\"Processing %d contacts\", len(connections))\n# Connections array may be logged elsewhere\n```\n\n## Sensitive Data Types\n1. **OAuth Tokens**: Access tokens, refresh tokens\n2. **PII**: Phone numbers, email addresses, names\n3. **Secrets**: Client IDs, secrets in error messages\n4. **Credentials**: Database URLs with passwords\n5. **Session Data**: State parameters, cookies\n\n## Impact\n- **Privacy Violation**: PII exposure in logs\n- **Security Risk**: Tokens/secrets in log files\n- **Compliance**: GDPR/CCPA violations\n- **Data Breach**: Logs collected by monitoring systems\n\n## Required Fix\n1. Implement log sanitization middleware\n2. Redact sensitive fields before logging\n3. Use separate logger for audit trail\n4. Remove sensitive data from error messages\n5. Add log level guards (no PII in INFO)\n6. Encrypt sensitive logs at rest\n7. Add security audit of all log statements\n\n## Sanitization Patterns\n```python\ndef sanitize_for_logging(data: dict) -\u003e dict:\n    sensitive_fields = [\n        'token', 'refresh_token', 'access_token',\n        'password', 'secret', 'phone_number',\n        'email', 'ssn'\n    ]\n    return {\n        k: '***REDACTED***' if k in sensitive_fields else v\n        for k, v in data.items()\n    }\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T21:22:26.186407973-08:00","created_by":"rohan","updated_at":"2026-01-09T21:22:26.186407973-08:00","labels":["backend","logging","privacy","security"]}
{"id":"google-contacts-cisco-nlw","title":"OAuth Setup Interface","description":"# Unknown\n\n\n## Overview\n\nCreate a Vue 3 component for setting up Google OAuth authentication. This interface will guide users through the OAuth flow, handle the callback, and display the current authentication status using modern reactive patterns with TypeScript.\n\n## Priority\n\n**P0 (Critical)** - Required for initial setup\n\n## Dependencies\n\n- Task 1.3: Configuration Management\n- Task 2.2: OAuth Implementation  \n- Task 6.1: Frontend Framework Setup (Vue 3 + Vite + TypeScript)\n\n## Objectives\n\n1. Create OAuth setup Vue component\n2. Display current OAuth status reactively\n3. Implement \"Connect Google\" button with proper UX\n4. Handle OAuth callback with Vue Router\n5. Show token expiry information with auto-refresh\n6. Add token refresh functionality\n7. Handle errors gracefully with user-friendly messages\n8. Type-safe API integration with TypeScript\n9. Test OAuth flow end-to-end\n\n## Technical Context\n\n### OAuth Flow with Vue\n1. User clicks \"Connect Google\" button in Vue component\n2. Redirected to Google OAuth consent screen (external)\n3. User authorizes application\n4. Redirected back to Vue app callback route\n5. Vue component processes callback, saves OAuth tokens\n6. Reactive state updates show success\n\n## Implementation Steps\n\n### 1. Define TypeScript Types\n\nCreate `frontend/src/types/oauth.ts`:\n\n```typescript\n/**\n * OAuth-related TypeScript types\n */\n\nexport interface OAuthTokenInfo {\n  valid: boolean;\n  expired: boolean;\n  expiry: string | null;\n  scopes: string[];\n}\n\nexport interface OAuthStatus {\n  authenticated: boolean;\n  token_info: OAuthTokenInfo | null;\n}\n\nexport interface OAuthStatusResponse {\n  authenticated: boolean;\n  token_info?: OAuthTokenInfo;\n}\n\nexport interface ApiResponse\u003cT = unknown\u003e {\n  message?: string;\n  detail?: string;\n  data?: T;\n}\n\nexport interface ApiError {\n  detail: string;\n  status?: number;\n}\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Install Dependencies**:\n   ```bash\n   cd frontend\n   npm install\n   ```\n\n2. **Start Development Servers**:\n   ```bash\n   # Terminal 1: Backend\n   uv run python -m google_contacts_cisco.main\n\n   # Terminal 2: Frontend\n   cd frontend \u0026\u0026 npm run dev\n   ```\n\n3. **Test OAuth Setup Page**:\n   - Visit http://localhost:5173/oauth/setup\n   - Should show \"Setup Instructions\" if not authenticated\n   - Should show \"Connected\" status if authenticated\n\n4. **Test OAuth Flow**:\n   - Click \"Connect Google Account\"\n   - Should redirect to Google consent screen\n   - After authorization, redirected to callback page\n   - Should show success message\n\n5. **Test Token Refresh**:\n   - After connecting, click \"Refresh Token\"\n   - Should show loading spinner\n   - Should update token info\n\n6. **Test Disconnect**:\n   - Click \"Disconnect\"\n   - Should show confirmation dialog\n   - After confirmation, status should change\n\n7. **Test TypeScript Compilation**:\n   ```bash\n   cd frontend\n   npm run type-check\n   # Should complete without errors\n   ```\n\n8. **Run Component Tests**:\n   ```bash\n   cd frontend\n   npm run test:unit\n   ```\n\n## Notes\n\n- **Reactive**: Uses Vue 3 Composition API with `ref` and `computed`\n- **Type-Safe**: Full TypeScript coverage for API calls and component props\n- **Error Handling**: Comprehensive error states with user-friendly messages\n- **Loading States**: Loading spinners and disabled buttons during async operations\n- **Vue Router**: Proper integration with client-side routing\n- **Composables**: Could extract OAuth logic into a composable for reuse\n- **No Jinja2**: Pure Vue SFC, no server-side templates needed\n\n## Common Issues\n\n1. **CORS Errors**: Ensure backend CORS allows frontend origin\n2. **Type Errors**: Run `npm run type-check` to catch TypeScript issues\n3. **API URL**: Check `VITE_API_URL` in `.env` file\n4. **Router Issues**: Ensure routes are registered in router/index.ts\n5. **Redirect URI**: Must match Google Console configuration\n\n## Related Documentation\n\n- Vue 3 Composition API: https://vuejs.org/guide/extras/composition-api-faq.html\n- Vue Router: https://router.vuejs.org/\n- TypeScript with Vue: https://vuejs.org/guide/typescript/overview.html\n- Vitest: https://vitest.dev/\n\n## Estimated Time\n\n4-5 hours","acceptance_criteria":"☐ OAuth setup page displays current status reactively\n☐ \"Connect Google\" button initiates OAuth flow\n☐ Callback route displays success/error message\n☐ Token expiry is shown and updates\n☐ Refresh button works and shows loading state\n☐ Error messages are user-friendly with retry options\n☐ TypeScript types cover all API responses\n☐ Component tests cover OAuth flow\n☐ Works with real Google consent screen","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.459438485Z","created_by":"vscode","updated_at":"2026-01-08T05:20:09.811680021Z","closed_at":"2026-01-08T05:20:09.811680021Z","close_reason":"Closed","labels":["P0","auth","frontend"]}
{"id":"google-contacts-cisco-pzv","title":"Code Quality: Duplicate code in repository methods","description":"## Problem\nContact and sync repositories have significant code duplication:\n1. Both have similar `get_by_id` patterns\n2. Pagination logic duplicated (get_contacts vs get_contacts_by_letter_group)\n3. Query building patterns repeated\n4. Similar error handling and logging\n5. Could extract base repository class\n\n## Duplication Examples\n```python\n# contact_repository.py lines 302-328 and 330-373\n# Almost identical pagination/filtering logic\ndef get_contacts(...):\n    query = self.db.query(Contact).filter(Contact.deleted == False)\n    if sort_by_recent: query.order_by(Contact.updated_at.desc())\n    else: query.order_by(Contact.display_name.asc())\n    \ndef get_contacts_by_letter_group(...):\n    query = self.db.query(Contact).filter(Contact.deleted == False)\n    # Same sorting logic repeated!\n    if sort_by_recent: query.order_by(Contact.updated_at.desc())\n    else: query.order_by(Contact.display_name.asc())\n```\n\n## Code Duplication Metrics\n- contact_repository.py: ~100 lines duplicated (20% of file)\n- sync_repository.py: Similar patterns\n- Maintainability debt: Changes need updates in multiple places\n\n## Impact\n- **Maintenance Burden**: Fix bugs in multiple places\n- **Inconsistency Risk**: Fixes applied inconsistently\n- **Code Bloat**: Larger file sizes, harder to review\n- **Testing Overhead**: Duplicate test coverage needed\n\n## Required Fix\n1. Create BaseRepository class with common CRUD operations\n2. Extract pagination logic to shared method\n3. Extract query building helpers\n4. Refactor repositories to inherit from base\n5. Add type hints for generic repository\n6. Update tests to cover base repository\n7. Document repository pattern in code\n\n## Design\n```python\nclass BaseRepository(Generic[T]):\n    def get_by_id(self, id: UUID) -\u003e Optional[T]: ...\n    def _apply_pagination(self, query, limit, offset): ...\n    def _apply_sorting(self, query, sort_field, desc=False): ...\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T21:20:57.547381879-08:00","created_by":"rohan","updated_at":"2026-01-09T21:20:57.547381879-08:00","labels":["backend","code-quality","duplication","refactor"]}
{"id":"google-contacts-cisco-qrc","title":"Performance: Missing database indexes on frequently queried columns","description":"## Problem\nDatabase models are missing critical indexes for common queries:\n1. `contacts.deleted` - Filtered in every query but no index\n2. `contacts.updated_at` - Used for sorting, no index  \n3. `phone_numbers.display_value` - Searched but not indexed\n4. Composite indexes missing for common filter+sort patterns\n5. No index on sync_state.last_sync_at\n\n## Affected Queries\n```python\n# contact_repository.py line 320 - Slow without deleted index\n.filter(Contact.deleted == False)\n\n# line 324 - Slow without updated_at index\n.order_by(Contact.updated_at.desc())\n\n# search_service.py line 400 - display_value search unindexed\nconditions.append(PhoneNumber.display_value.like(digit_pattern))\n```\n\n## Current Indexes\n- contacts: display_name, resource_name (contact.py lines 42-45)\n- phone_numbers: value, contact_id (phone_number.py lines 24-28)\n\n## Missing Indexes\n1. `idx_contacts_deleted` on contacts.deleted\n2. `idx_contacts_updated_at` on contacts.updated_at\n3. `idx_contacts_deleted_updated` composite (deleted, updated_at)\n4. `idx_contacts_deleted_name` composite (deleted, display_name)\n5. `idx_phone_display_value` on phone_numbers.display_value\n6. `idx_sync_state_last_sync` on sync_state.last_sync_at\n\n## Performance Impact\n- **Slow Queries**: Full table scans on every contact list\n- **Poor UX**: 2-5 second page loads with 1K+ contacts\n- **API Timeouts**: Search times out with large databases\n- **Scalability**: Cannot handle 10K+ contacts efficiently\n\n## Required Fix\n1. Create Alembic migration to add missing indexes\n2. Test query performance before/after with EXPLAIN ANALYZE\n3. Add composite indexes for common query patterns\n4. Update models to declare indexes\n5. Document indexing strategy in README\n6. Add performance tests with large dataset","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T21:20:20.376384306-08:00","created_by":"rohan","updated_at":"2026-01-09T21:20:20.376384306-08:00","labels":["backend","database","indexes","performance"]}
{"id":"google-contacts-cisco-r7t","title":"XML Formatter Service","description":"# Unknown\n\n\n## Overview\n\nCreate a service to format contact data into Cisco IP Phone XML format. This includes generating main directory menus, group menus, and individual contact directories with proper XML structure.\n\n## Priority\n\n**P0 (Critical)** - Required for MVP\n\n## Dependencies\n\n- Task 1.2: Database Setup\n- Task 3.1: Full Sync Implementation\n\n## Objectives\n\n1. Implement main directory menu generation (group selection)\n2. Implement group directory menu generation (contact list)\n3. Implement individual contact directory generation (phone numbers)\n4. Implement contact name to group mapping logic\n5. Handle XML escaping and special characters\n6. Generate proper Cisco XML structure\n7. Build RESTful URLs for navigation\n8. Test XML output with various contact data\n\n## Technical Context\n\n### Cisco XML Object Types\n1. **CiscoIPPhoneMenu**: For menus with selectable items\n2. **CiscoIPPhoneDirectory**: For contact phone numbers\n\n## Implementation Steps\n\n### 1. Create XML Formatter Service\n\nCreate `google_contacts_cisco/services/xml_formatter.py`:\n\n```python\n\"\"\"XML formatter for Cisco IP Phone directory.\"\"\"\nimport xml.etree.ElementTree as ET\nfrom typing import List, Dict\nfrom lxml import etree\nfrom html import escape\n\nfrom ..models.contact import Contact\nfrom ..models.phone_number import PhoneNumber\nfrom ..config import settings\nfrom ..utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\n\n# Group mapping for phone keypad\nGROUP_MAPPINGS = {\n    \"1\": [\"1\"],\n    \"2ABC\": [\"2\", \"A\", \"B\", \"C\"],\n    \"3DEF\": [\"3\", \"D\", \"E\", \"F\"],\n    \"4GHI\": [\"4\", \"G\", \"H\", \"I\"],\n    \"5JKL\": [\"5\", \"J\", \"K\", \"L\"],\n    \"6MNO\": [\"6\", \"M\", \"N\", \"O\"],\n    \"7PRQS\": [\"7\", \"P\", \"Q\", \"R\", \"S\"],\n    \"8TUV\": [\"8\", \"T\", \"U\", \"V\"],\n    \"9WXYZ\": [\"9\", \"W\", \"X\", \"Y\", \"Z\"],\n    \"0\": [\"0\"]\n}\n\n\nclass CiscoXMLFormatter:\n    \"\"\"Format contacts into Cisco IP Phone XML.\"\"\"\n    \n    def __init__(self, base_url: str = \"http://localhost:8000\"):\n        \"\"\"Initialize formatter.\n        \n        Args:\n            base_url: Base URL for generating links\n        \"\"\"\n        self.base_url = base_url.rstrip('/')\n    \n    def generate_main_directory(self) -\u003e str:\n        \"\"\"Generate main directory menu with group options.\n        \n        Returns:\n            XML string for main directory\n        \"\"\"\n        root = etree.Element(\"CiscoIPPhoneMenu\")\n        \n        # Title\n        title = etree.SubElement(root, \"Title\")\n        title.text = settings.directory_title\n        \n        # Add menu items for each group\n        for group_name in GROUP_MAPPINGS.keys():\n            item = etree.SubElement(root, \"MenuItem\")\n            \n            name = etree.SubElement(item, \"Name\")\n            name.text = group_name\n            \n            url = etree.SubElement(item, \"URL\")\n            url.text = f\"{self.base_url}/directory/groups/{group_name}\"\n        \n        # Add soft keys\n        self._add_softkeys(root, show_help=True, help_context=\"main\")\n        \n        return self._to_xml_string(root)\n    \n    def generate_group_directory(self, group: str, contacts: List[Contact]) -\u003e str:\n        \"\"\"Generate directory menu for a specific group.\n        \n        Args:\n            group: Group identifier (e.g., \"2ABC\")\n            contacts: List of contacts in this group\n            \n        Returns:\n            XML string for group directory\n        \"\"\"\n        root = etree.Element(\"CiscoIPPhoneMenu\")\n        \n        # Title\n        title = etree.SubElement(root, \"Title\")\n        title.text = group\n        \n        # Add menu items for each contact\n        for contact in contacts:\n            item = etree.SubElement(root, \"MenuItem\")\n            \n            name = etree.SubElement(item, \"Name\")\n            name.text = self._escape_xml(contact.display_name)\n            \n            url = etree.SubElement(item, \"URL\")\n            url.text = f\"{self.base_url}/directory/contacts/{contact.id}\"\n        \n        # Add soft keys\n        self._add_softkeys(root, show_help=True, help_context=f\"group/{group}\")\n        \n        return self._to_xml_string(root)\n    \n    def generate_contact_directory(self, contact: Contact) -\u003e str:\n        \"\"\"Generate directory for individual contact with phone numbers.\n        \n        Args:\n            contact: Contact with phone numbers\n            \n        Returns:\n            XML string for contact directory\n        \"\"\"\n        root = etree.Element(\"CiscoIPPhoneDirectory\")\n        \n        # Title\n        title = etree.SubElement(root, \"Title\")\n        title.text = self._escape_xml(contact.display_name)\n        \n        # Add phone numbers\n        if contact.phone_numbers:\n            for phone in sorted(contact.phone_numbers, key=lambda p: not p.primary):\n                entry = etree.SubElement(root, \"DirectoryEntry\")\n                \n                name = etree.SubElement(entry, \"Name\")\n                # Use type as label (Mobile, Work, etc.)\n                phone_label = phone.type.capitalize() if phone.type else \"Phone\"\n                if phone.primary:\n                    phone_label += \" (Primary)\"\n                name.text = phone_label\n                \n                telephone = etree.SubElement(entry, \"Telephone\")\n                telephone.text = phone.display_value\n        else:\n            # No phone numbers\n            entry = etree.SubElement(root, \"DirectoryEntry\")\n            name = etree.SubElement(entry, \"Name\")\n            name.text = \"No phone numbers\"\n            telephone = etree.SubElement(entry, \"Telephone\")\n            telephone.text = \"\"\n        \n        # Add soft keys for contact view\n        # Position 1: Exit (go to home directory)\n        exit_key = etree.SubElement(root, \"SoftKeyItem\")\n        exit_name = etree.SubElement(exit_key, \"Name\")\n        exit_name.text = \"Exit\"\n        exit_position = etree.SubElement(exit_key, \"Position\")\n        exit_position.text = \"1\"\n        exit_url = etree.SubElement(exit_key, \"URL\")\n        exit_url.text = f\"{self.base_url}/directory\"\n        \n        # Position 2: Back (go back to group list)\n        back_key = etree.SubElement(root, \"SoftKeyItem\")\n        back_name = etree.SubElement(back_key, \"Name\")\n        back_name.text = \"Back\"\n        back_position = etree.SubElement(back_key, \"Position\")\n        back_position.text = \"2\"\n        back_url = etree.SubElement(back_key, \"URL\")\n        back_url.text = \"SoftKey:Back\"\n        \n        # Position 3: Call\n        call_key = etree.SubElement(root, \"SoftKeyItem\")\n        call_name = etree.SubElement(call_key, \"Name\")\n        call_name.text = \"Call\"\n        call_position = etree.SubElement(call_key, \"Position\")\n        call_position.text = \"3\"\n        call_url = etree.SubElement(call_key, \"URL\")\n        call_url.text = \"SoftKey:Select\"\n        \n        return self._to_xml_string(root)\n    \n    def map_contact_to_group(self, contact: Contact) -\u003e str:\n        \"\"\"Map contact to appropriate group based on first character.\n        \n        Args:\n            contact: Contact to map\n            \n        Returns:\n            Group identifier (e.g., \"2ABC\")\n        \"\"\"\n        if not contact.display_name:\n            return \"0\"\n        \n        first_char = contact.display_name[0].upper()\n        \n        for group, chars in GROUP_MAPPINGS.items():\n            if first_char in chars:\n                return group\n        \n        # Default to \"0\" for special characters\n        return \"0\"\n    \n    def generate_help(self, context: str = \"main\") -\u003e str:\n        \"\"\"Generate help text for different contexts.\n        \n        Args:\n            context: Help context (main, group/\u003cgroup\u003e, contact)\n            \n        Returns:\n            XML string for help text\n        \"\"\"\n        root = etree.Element(\"CiscoIPPhoneText\")\n        \n        # Title\n        title = etree.SubElement(root, \"Title\")\n        title.text = \"Help\"\n        \n        # Help text based on context\n        text = etree.SubElement(root, \"Text\")\n        if context == \"main\":\n            text.text = (\n                \"Directory Help:\\n\\n\"\n                \"Select a group (e.g., 2ABC) to view contacts starting with those letters.\\n\\n\"\n                \"Use the keypad to quickly jump to a group.\\n\\n\"\n                \"Press Exit to return to main menu.\"\n            )\n        elif context.startswith(\"group/\"):\n            group = context.split(\"/\", 1)[1] if \"/\" in context else \"\"\n            text.text = (\n                f\"Group {group} Help:\\n\\n\"\n                \"Select a contact to view their phone numbers.\\n\\n\"\n                \"Use View button to open contact details.\\n\\n\"\n                \"Press Exit to return to directory home.\"\n            )\n        elif context == \"contact\":\n            text.text = (\n                \"Contact Help:\\n\\n\"\n                \"Select a phone number and press Call to dial.\\n\\n\"\n                \"Press Back to return to contact list.\\n\\n\"\n                \"Press Exit to return to directory home.\"\n            )\n        else:\n            text.text = \"Use the menu to navigate the directory. Press Exit to return to main menu.\"\n        \n        # Soft key to go back\n        soft_key = etree.SubElement(root, \"SoftKeyItem\")\n        key_name = etree.SubElement(soft_key, \"Name\")\n        key_name.text = \"Back\"\n        key_position = etree.SubElement(soft_key, \"Position\")\n        key_position.text = \"1\"\n        key_url = etree.SubElement(soft_key, \"URL\")\n        key_url.text = \"SoftKey:Back\"\n        \n        return self._to_xml_string(root)\n    \n    def _add_softkeys(self, root: etree.Element, show_help: bool = False, help_context: str = \"main\"):\n        \"\"\"Add standard soft keys to menu.\n        \n        Args:\n            root: XML root element\n            show_help: Whether to include help button\n            help_context: Context for help (main, group/\u003cgroup\u003e, contact)\n        \"\"\"\n        # Exit key\n        exit_key = etree.SubElement(root, \"SoftKeyItem\")\n        exit_name = etree.SubElement(exit_key, \"Name\")\n        exit_name.text = \"Exit\"\n        exit_position = etree.SubElement(exit_key, \"Position\")\n        exit_position.text = \"1\"\n        exit_url = etree.SubElement(exit_key, \"URL\")\n        exit_url.text = \"Init:Directories\"\n        \n        # View/Select key\n        view_key = etree.SubElement(root, \"SoftKeyItem\")\n        view_name = etree.SubElement(view_key, \"Name\")\n        view_name.text = \"View\"\n        view_position = etree.SubElement(view_key, \"Position\")\n        view_position.text = \"2\"\n        view_url = etree.SubElement(view_key, \"URL\")\n        view_url.text = \"SoftKey:Select\"\n        \n        # Optional help key\n        if show_help:\n            help_key = etree.SubElement(root, \"SoftKeyItem\")\n            help_name = etree.SubElement(help_key, \"Name\")\n            help_name.text = \"Help\"\n            help_position = etree.SubElement(help_key, \"Position\")\n            help_position.text = \"4\"\n            help_url = etree.SubElement(help_key, \"URL\")\n            help_url.text = f\"{self.base_url}/directory/help?context={help_context}\"\n    \n    def _escape_xml(self, text: str) -\u003e str:\n        \"\"\"Escape special XML characters.\n        \n        Args:\n            text: Text to escape\n            \n        Returns:\n            Escaped text\n        \"\"\"\n        if not text:\n            return \"\"\n        return escape(text, quote=True)\n    \n    def _to_xml_string(self, root: etree.Element) -\u003e str:\n        \"\"\"Convert XML element to string with proper formatting.\n        \n        Args:\n            root: XML root element\n            \n        Returns:\n            Formatted XML string\n        \"\"\"\n        xml_str = etree.tostring(\n            root,\n            encoding='UTF-8',\n            xml_declaration=True,\n            pretty_print=False\n        ).decode('utf-8')\n        \n        return xml_str\n\n\ndef get_xml_formatter(base_url: str = \"http://localhost:8000\") -\u003e CiscoXMLFormatter:\n    \"\"\"Get XML formatter instance.\n    \n    Args:\n        base_url: Base URL for generating links\n        \n    Returns:\n        CiscoXMLFormatter instance\n    \"\"\"\n    return CiscoXMLFormatter(base_url)\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Generate and View XML**:\n   ```python\n   from google_contacts_cisco.services.xml_formatter import get_xml_formatter\n   from google_contacts_cisco.models import get_db\n   from google_contacts_cisco.repositories.contact_repository import ContactRepository\n   \n   db = next(get_db())\n   formatter = get_xml_formatter()\n   \n   # Generate main directory\n   xml = formatter.generate_main_directory()\n   print(xml)\n   \n   # Generate group directory\n   repo = ContactRepository(db)\n   contacts = repo.get_all_active()\n   xml = formatter.generate_group_directory(\"2ABC\", contacts[:5])\n   print(xml)\n   ```\n\n2. **Validate XML**:\n   ```python\n   from lxml import etree\n   \n   # Parse XML to validate structure\n   root = etree.fromstring(xml.encode('utf-8'))\n   print(f\"Valid XML: {root.tag}\")\n   ```\n\n3. **Run Tests**:\n   ```bash\n   pytest tests/test_xml_formatter.py -v\n   ```\n\n## Notes\n\n- **lxml vs ElementTree**: Using lxml for better XML generation and pretty printing\n- **XML Escaping**: Critical for special characters in names\n- **URL Encoding**: URLs in XML must be properly escaped\n- **Group Mapping**: Case-insensitive matching\n- **SoftKeys**: Standard navigation buttons for Cisco phones\n- **Primary Phone**: Displayed first in contact directory\n\n## Common Issues\n\n1. **Special Characters**: Must escape \u0026, \u003c, \u003e, \", '\n2. **Empty Groups**: Handle gracefully with message\n3. **Long Names**: May be truncated by phone display\n4. **Multiple Numbers**: Sort by primary flag\n5. **URL Encoding**: Ampersands in URLs must be \u0026amp;\n\n## Related Documentation\n\n- lxml: https://lxml.de/\n- Cisco XML Objects: https://www.cisco.com/c/en/us/td/docs/voice_ip_comm/cuipph/all_models/xsi/\n- XML Entities: https://www.w3.org/TR/xml/#sec-predefined-ent\n\n## Estimated Time\n\n4-5 hours","acceptance_criteria":"☐ Main directory menu generates correctly with all groups\n☐ Group menu generates correctly with filtered contacts\n☐ Individual contact directory shows all phone numbers\n☐ Contact names are mapped to correct groups\n☐ Special characters are properly escaped\n☐ URLs are correctly formatted and escaped\n☐ Empty groups are handled gracefully\n☐ Phone number types are displayed (Mobile, Work, etc.)\n☐ Help messages are context-specific and useful\n☐ Help soft key appears in all menus\n☐ XML validates against Cisco format\n☐ Tests cover all XML generation scenarios","notes":"## Testing Requirements\n\n**⚠️ Critical**: This task is not complete until comprehensive unit tests are written and passing.","status":"closed","priority":0,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.305374445Z","created_by":"vscode","updated_at":"2026-01-08T03:26:33.406757857Z","closed_at":"2026-01-08T03:11:16.468220678Z","close_reason":"Closed","labels":["P0","backend","cisco-xml"]}
{"id":"google-contacts-cisco-slh","title":"Monitoring and Logging","description":"# Unknown\n\n\n## Overview\n\nImplement comprehensive monitoring, logging, and observability infrastructure to track application health, performance metrics, errors, and usage patterns in production with Prometheus metrics, structured logging, and alerting.\n\n## Priority\n\n**P2 (Medium)** - Important for production operations and maintenance\n\n## Dependencies\n\n- Task 8.2: Deployment Preparation\n- All implementation tasks\n\n## Objectives\n\n1. Configure structured JSON logging with context\n2. Implement Prometheus metrics collection\n3. Create comprehensive health check endpoints\n4. Add request tracing with unique IDs\n5. Set up error tracking and notifications\n6. Create Grafana monitoring dashboard\n7. Configure log rotation and retention\n8. Set up alerting rules\n9. Add performance profiling\n10. Document monitoring procedures\n\n## Technical Context\n\n### Monitoring Architecture\n```\nApplication → Logs (JSON) → Log Aggregator (optional)\n           → Metrics (/metrics) → Prometheus → Grafana\n           → Health Checks → Monitoring System\n```\n\n## Implementation Steps\n\n### 1. Install Monitoring Dependencies\n\nUpdate `pyproject.toml`:\n\n```toml\n[project]\ndependencies = [\n    # ... existing dependencies ...\n    \"python-json-logger\u003e=2.0.7\",\n    \"prometheus-client\u003e=0.19.0\",\n]\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Check Logging Works**:\n   ```bash\n   # Start application\n   uv run python -m google_contacts_cisco.main\n   \n   # Check logs\n   tail -f logs/app.log\n   \n   # Make some requests\n   curl http://localhost:8000/api/contacts\n   \n   # Check logs show JSON format\n   tail -1 logs/app.log | jq\n   ```\n\n2. **Check Metrics Endpoint**:\n   ```bash\n   curl http://localhost:8000/metrics\n   \n   # Should see Prometheus metrics\n   # HELP http_requests_total Total HTTP requests\n   # TYPE http_requests_total counter\n   # http_requests_total{method=\"GET\",endpoint=\"/api/contacts\",status=\"200\"} 1.0\n   ```\n\n3. **Test Health Check**:\n   ```bash\n   curl http://localhost:8000/health | jq\n   \n   # Should return detailed health status\n   ```\n\n4. **Test Request Tracing**:\n   ```bash\n   curl -v http://localhost:8000/api/contacts\n   \n   # Check response headers\n   # X-Request-ID: 550e8400-e29b-41d4-a716-446655440000\n   # X-Response-Time: 45.23ms\n   ```\n\n5. **Set Up Prometheus** (optional):\n   ```yaml\n   # prometheus.yml\n   scrape_configs:\n     - job_name: 'contacts-app'\n       static_configs:\n         - targets: ['localhost:8000']\n       metrics_path: '/metrics'\n       scrape_interval: 15s\n   ```\n\n6. **Import Grafana Dashboard**:\n   - Open Grafana\n   - Import `monitoring/grafana/dashboard.json`\n   - Verify panels show data\n\n## Notes\n\n- **Structured Logging**: JSON format for easy parsing and aggregation\n- **Request IDs**: Unique UUID for tracing requests across logs\n- **Metrics**: Prometheus-compatible for standard monitoring tools\n- **Health Checks**: Multi-component status for orchestration\n- **Log Rotation**: Prevents logs from filling disk\n- **Performance**: Minimal overhead (\u003c1% typically)\n- **Privacy**: Don't log sensitive data (passwords, tokens)\n\n## Common Issues\n\n1. **Logs Not Appearing**: Check log level, verify handlers configured\n2. **Metrics Not Updating**: Ensure MetricsCollector called correctly\n3. **High Memory Usage**: Reduce metric cardinality (labels)\n4. **Log Disk Full**: Configure log rotation correctly\n5. **Prometheus Scrape Fails**: Check /metrics endpoint accessible\n\n## Best Practices\n\n### Logging\n- Use appropriate log levels\n- Include context (request_id, user_id)\n- Don't log sensitive data\n- Use structured logging (JSON)\n- Log errors with stack traces\n- Include timing information\n\n## Related Documentation\n\n- Prometheus: https://prometheus.io/docs/introduction/overview/\n- Grafana: https://grafana.com/docs/grafana/latest/\n- python-json-logger: https://github.com/madzak/python-json-logger\n- Prometheus Python Client: https://github.com/prometheus/client_python\n- Logging Best Practices: https://12factor.net/logs\n\n## Estimated Time\n\n4-5 hours","acceptance_criteria":"☐ Structured JSON logging configured\n☐ All requests logged with timing\n☐ Prometheus metrics exposed at `/metrics`\n☐ Health check returns component status\n☐ Request IDs track requests end-to-end\n☐ Errors logged with full context\n☐ Log rotation prevents disk filling\n☐ Grafana dashboard created\n☐ Alert rules configured\n☐ Documentation complete","notes":"- **Structured Logging**: JSON format for easy parsing and aggregation\n- **Request IDs**: Unique UUID for tracing requests across logs\n- **Metrics**: Prometheus-compatible for standard monitoring tools\n- **Health Checks**: Multi-component status for orchestration\n- **Log Rotation**: Prevents logs from filling disk\n- **Performance**: Minimal overhead (\u003c1% typically)\n- **Privacy**: Don't log sensitive data (passwords, tokens)\n\n\n**Related Files:**\n\n- See `.ai/planning/tasks/` for complete implementation guide\n\n- Includes code examples, test suites, and verification steps","status":"open","priority":2,"issue_type":"task","estimated_minutes":240,"created_at":"2026-01-08T03:10:59.617019408Z","created_by":"vscode","updated_at":"2026-01-08T03:26:36.727245393Z","labels":["P2","deployment","observability"]}
{"id":"google-contacts-cisco-thr","title":"Bug: Token refresh failure handling can cause permanent auth loss","description":"## Problem\nOAuth token refresh (`auth/oauth.py` lines 125-140) catches exceptions but doesn't distinguish between recoverable and permanent failures:\n1. All refresh errors return None (line 136-140)\n2. Permanent failures (revoked token) vs transient (network) treated same\n3. No retry logic for transient failures\n4. Token file not deleted on permanent failure\n5. User not notified to re-authenticate\n\n## Affected Code\n```python\n# oauth.py lines 135-140\nexcept RefreshError as e:\n    logger.error(\"Error refreshing token: %s\", e)\n    return None  # Returns None for ALL refresh failures\nexcept Exception as e:\n    logger.error(\"Unexpected error during token refresh: %s\", e)\n    return None\n```\n\n## Impact\n- **Auth State Limbo**: User stuck with expired token, can't refresh\n- **Silent Failures**: No user notification of permanent auth loss\n- **Bad UX**: Must manually delete token file to fix\n- **Service Degradation**: All API calls fail silently\n\n## Failure Scenarios\n1. Token revoked by user in Google console → permanent (should delete token)\n2. Network timeout during refresh → transient (should retry)\n3. Google API rate limit → transient (should backoff retry)\n4. Invalid client credentials → permanent (should alert admin)\n\n## Required Fix\n1. Distinguish permanent vs transient RefreshError types\n2. Delete token file on permanent failures (revoked, invalid)\n3. Implement retry with exponential backoff for transient failures\n4. Add specific error responses for API to show user\n5. Add monitoring/alerting for auth failures\n6. Add integration tests for refresh failure scenarios","status":"open","priority":1,"issue_type":"bug","created_at":"2026-01-09T21:19:06.605172794-08:00","created_by":"rohan","updated_at":"2026-01-09T21:19:06.605172794-08:00","labels":["backend","bug","error-handling","oauth"]}
{"id":"google-contacts-cisco-tov","title":"Edge Case: Phone number normalization fails for international formats","description":"## Problem\nPhone normalizer (utils/phone_utils.py) uses hardcoded US default:\n1. Default country is \"US\" with no runtime configuration (line 26)\n2. International numbers without + prefix may fail\n3. European dialing prefixes (#31#, *31#) handled but not tested\n4. No multi-country support for international users\n5. Prefix pattern may incorrectly match phone number digits\n\n## Affected Code\n```python\n# phone_utils.py lines 26-32\ndef __init__(self, default_country: str = \"US\"):\n    self.default_country = default_country  # Hardcoded US\n\n# lines 158-159\nprefix_pattern = r\"^[\\s]*([*#]\\d{1,3}[#])[\\s]*|^[\\s]*([*]\\d{2})(?=[\\s\\-\\(\\)\\+\\.]\"\n# Complex regex may have edge cases\n```\n\n## Failing Cases\n1. UK number without +: \"020 7946 0958\" → Treated as US number\n2. German mobile: \"0151 12345678\" → Normalization fails\n3. Prefix in middle: \"555-*67-1234\" → Should not match prefix\n4. Multiple prefixes: \"*67*82202-555-0100\" → Only strips first\n\n## Impact\n- **International Users**: Cannot use non-US numbers\n- **Search Failures**: International numbers not found\n- **Data Quality**: Numbers stored in wrong format\n- **Cisco Dial Issues**: Phones can't call international contacts\n\n## Required Fix\n1. Make default_country configurable via settings\n2. Add per-contact country code support\n3. Test international formats comprehensively\n4. Add libphonenumber region detection\n5. Document supported countries and formats\n6. Add integration tests with various country formats\n7. Consider auto-detecting country from contact metadata","status":"open","priority":2,"issue_type":"bug","created_at":"2026-01-09T21:19:50.779662168-08:00","created_by":"rohan","updated_at":"2026-01-09T21:19:50.779662168-08:00","labels":["backend","bug","edge-case","internationalization"]}
{"id":"google-contacts-cisco-u7z","title":"Integration Tests","description":"# Unknown\n\n\n## Overview\n\nCreate integration tests that verify components work together correctly across the entire stack, including API endpoints, database operations, service interactions, and external dependencies (with mocking).\n\n## Priority\n\n**P1 (High)** - Required for production readiness\n\n## Dependencies\n\n- Task 7.1: Unit Tests\n- All implementation tasks (1-19)\n\n## Objectives\n\n1. Test complete API endpoint workflows\n2. Test database transactions and rollbacks\n3. Test service integration (sync, search, XML)\n4. Test OAuth flow with mocked Google API\n5. Test error propagation across layers\n6. Test concurrent operations\n7. Test data persistence\n8. Verify request/response contracts\n\n## Technical Context\n\n### Integration Test Scope\nIntegration tests verify:\n- **API Layer**: HTTP requests/responses, routing, middleware\n- **Service Layer**: Business logic coordination\n- **Data Layer**: Database operations, transactions\n- **External Services**: Mocked Google API responses\n\n## Implementation Steps\n\n### 1. Create Integration Test Configuration\n\nUpdate `pyproject.toml`:\n\n```toml\n[tool.pytest.ini_options]\nmarkers = [\n    \"unit: Unit tests\",\n    \"integration: Integration tests\",\n    \"e2e: End-to-end tests\",\n    \"slow: Slow running tests\",\n]\n\n# Integration test specific settings\n[tool.pytest.integration]\ntimeout = 300  # 5 minutes max for integration tests\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Run Integration Tests**:\n   ```bash\n   uv run pytest tests/integration -v\n   ```\n\n2. **Run With Coverage**:\n   ```bash\n   uv run pytest tests/integration --cov=google_contacts_cisco --cov-report=term\n   ```\n\n3. **Run Specific Test File**:\n   ```bash\n   uv run pytest tests/integration/test_api_contacts.py -v\n   ```\n\n4. **Run Only Integration Tests**:\n   ```bash\n   uv run pytest -m integration -v\n   ```\n\n5. **Check Test Duration**:\n   ```bash\n   uv run pytest tests/integration --durations=10\n   # Shows slowest 10 tests\n   ```\n\n## Notes\n\n- **Test Database**: Use in-memory SQLite for speed\n- **Mocking**: Mock external APIs (Google), not internal code\n- **Transactions**: Each test runs in a transaction, rolled back after\n- **Fixtures**: Share fixtures via conftest.py\n- **Performance**: Integration tests should complete in \u003c2 minutes total\n- **Isolation**: Tests should not depend on each other\n- **Real HTTP**: Use TestClient for actual HTTP requests\n\n## Common Issues\n\n1. **Slow Tests**: Check database queries, add indexes\n2. **Flaky Tests**: Avoid time-dependent assertions\n3. **Mock Leaks**: Ensure mocks are cleaned up between tests\n4. **Database Locks**: Use separate connection pools\n5. **Port Conflicts**: Use random ports for test servers\n\n## Best Practices\n\n- Test happy path and error cases\n- Use realistic mock data\n- Test API contracts (request/response schemas)\n- Verify database state after operations\n- Test concurrent operations\n- Clean up resources after tests\n- Use descriptive test names\n- Group related tests in classes\n\n## Related Documentation\n\n- FastAPI Testing: https://fastapi.tiangolo.com/tutorial/testing/\n- pytest-asyncio: https://pytest-asyncio.readthedocs.io/\n- TestClient: https://www.starlette.io/testclient/\n\n## Estimated Time\n\n6-8 hours","acceptance_criteria":"☐ All API endpoints are tested end-to-end\n☐ Database transactions are verified\n☐ Service integration is tested\n☐ OAuth flow is tested with mocks\n☐ Error handling is verified across layers\n☐ Concurrent operations are tested\n☐ Data persistence is verified\n☐ Tests run in \u003c2 minutes\n☐ Tests are isolated and repeatable\n☐ Mock data matches real API responses","notes":"- **Test Database**: Use in-memory SQLite for speed\n- **Mocking**: Mock external APIs (Google), not internal code\n- **Transactions**: Each test runs in a transaction, rolled back after\n- **Fixtures**: Share fixtures via conftest.py\n- **Performance**: Integration tests should complete in \u003c2 minutes total\n- **Isolation**: Tests should not depend on each other\n- **Real HTTP**: Use TestClient for actual HTTP requests\n\n\n**Related Files:**\n\n- See `.ai/planning/tasks/` for complete implementation guide\n\n- Includes code examples, test suites, and verification steps","status":"closed","priority":1,"issue_type":"task","estimated_minutes":360,"created_at":"2026-01-08T03:10:59.532630804Z","created_by":"vscode","updated_at":"2026-01-08T09:16:57.464663951Z","closed_at":"2026-01-08T09:16:57.464663951Z","close_reason":"Closed","labels":["P1","integration","testing"]}
{"id":"google-contacts-cisco-u8k","title":"Standardize phone number formatting in Cisco directory (remove + and normalize display)","description":"Phone numbers in the /directory endpoint need to be displayed in a consistent format for Cisco phone dialplan compatibility. Currently, numbers are displayed with varying formats including + prefix (e.g., '+1 123 544 5555', '+1-555-1234', '(555) 123-4567') which breaks Cisco phone dialplan and creates an inconsistent user experience.\n\n## Root Cause\nThe XML formatter (xml_formatter.py:166) outputs phone.display_value directly to the Cisco directory XML without processing or normalization. The display_value field contains phone numbers in various formats from Google Contacts API, including international format with + prefix.\n\n## Technical Details\n- File: google_contacts_cisco/services/xml_formatter.py\n- Method: generate_contact_directory()\n- Line: 166 - telephone.text = phone.display_value\n- Issue: display_value contains inconsistent formats including + prefix\n- Impact: \n  - Cisco IP phones cannot properly dial numbers with + prefix\n  - Inconsistent display format confuses users\n  - No standardization across directory\n\n## Solution Approach\nImplement consistent phone number formatting for Cisco directory display:\n\n1. **Standard Format**: Use E.164 without + prefix, with spaces for readability\n   - Format: \"1 555 123 4567\" (country code, space-separated groups)\n   - No + prefix (breaks Cisco dialplan)\n   - No parentheses, dashes, or other special characters\n   - Just digits with spaces for readability\n\n2. **Implementation**:\n   - Add helper method to CiscoXMLFormatter class: _format_phone_for_cisco(display_value)\n   - Method should:\n     a. Strip leading + character\n     b. Extract digits from display_value\n     c. Reformat consistently based on length:\n        - 11 digits (US/Canada): \"1 555 123 4567\" (1 XXX XXX XXXX)\n        - 10 digits (US/Canada local): \"555 123 4567\" (XXX XXX XXXX)\n        - Other lengths: Space-separate by country code standards\n   - Use this method in generate_contact_directory() before setting telephone.text\n\n3. **Edge Cases**:\n   - Handle phone numbers with extensions (strip extension markers)\n   - Preserve only dialable number portion\n   - Handle international numbers (various lengths)\n   - Handle malformed numbers gracefully\n\n## Acceptance Criteria\n- [ ] All phone numbers in Cisco directory XML use consistent format\n- [ ] Leading + is always removed from phone numbers\n- [ ] US/Canada numbers (11 digits starting with 1) formatted as: \"1 XXX XXX XXXX\"\n- [ ] US/Canada local numbers (10 digits) formatted as: \"XXX XXX XXXX\"\n- [ ] International numbers formatted consistently with spaces\n- [ ] No parentheses, dashes, or other special characters in output\n- [ ] Numbers are dialable from Cisco phones (no + prefix)\n- [ ] Formatting only affects /directory endpoint XML output\n- [ ] Stored display_value in database remains unchanged\n- [ ] Other API endpoints (REST APIs) preserve original display_value\n\n## Testing Requirements\n\n### 1. Unit Tests (tests/unit/services/test_xml_formatter.py)\n\nAdd new test class: TestPhoneNumberFormattingForCisco\n\nTests should verify:\n- **US/Canada 11-digit numbers**: \n  - Input: \"+1 555-123-4567\" → Output: \"1 555 123 4567\"\n  - Input: \"+1-555-123-4567\" → Output: \"1 555 123 4567\"\n  - Input: \"(555) 123-4567\" → Output: \"555 123 4567\"\n  - Input: \"+15551234567\" → Output: \"1 555 123 4567\"\n\n- **US/Canada 10-digit numbers**:\n  - Input: \"555-123-4567\" → Output: \"555 123 4567\"\n  - Input: \"(555) 123-4567\" → Output: \"555 123 4567\"\n\n- **International numbers**:\n  - Input: \"+44 20 7946 0958\" → Output: \"44 20 7946 0958\" (UK)\n  - Input: \"+33 1 42 86 82 00\" → Output: \"33 1 42 86 82 00\" (France)\n  - Input: \"+61 2 1234 5678\" → Output: \"61 2 1234 5678\" (Australia)\n\n- **Edge cases**:\n  - Numbers without + remain unchanged and reformatted\n  - Multiple formats from same contact all normalized\n  - Empty phone numbers handled gracefully\n  - Phone numbers with extensions (strip extension)\n\n- **XML validity**:\n  - Generated XML is valid and parseable\n  - Telephone elements contain properly formatted numbers\n  - No XML encoding issues\n\n### 2. Integration Tests (tests/integration/api/test_api_directory.py)\n\nAdd test class: TestDirectoryPhoneNumberFormatting\n\nTests should verify:\n- Create contact with phone in format \"+1-555-123-4567\"\n  - GET /directory/contacts/{id} returns \"1 555 123 4567\"\n  \n- Create contact with multiple phones in different formats\n  - All numbers in XML output are consistently formatted\n  \n- Verify other endpoints preserve original:\n  - GET /api/contacts/{id} returns original display_value with +\n  - GET /api/search returns original display_value with +\n\n- Test various input formats all normalize correctly:\n  - \"+1 (555) 123-4567\"\n  - \"15551234567\"\n  - \"+1-555-123-4567\"\n  - \"555.123.4567\"\n\n### 3. Manual Testing\n- Access directory from Cisco IP phone simulator/device\n- Verify all phone numbers display in consistent format\n- Verify numbers without + are dialable from Cisco phone\n- Test dialing various formatted numbers\n- Verify user experience is consistent across all contacts\n\n## Files to Modify\n- **google_contacts_cisco/services/xml_formatter.py**:\n  - Add _format_phone_for_cisco() helper method (~20-30 lines)\n  - Modify generate_contact_directory() to use helper (1 line change at line 166)\n\n## Tests to Add/Modify\n- **tests/unit/services/test_xml_formatter.py**:\n  - Add TestPhoneNumberFormattingForCisco class (~150-200 lines)\n  - ~15-20 new test methods\n\n- **tests/integration/api/test_api_directory.py**:\n  - Add TestDirectoryPhoneNumberFormatting class (~100 lines)\n  - ~5-7 new test methods\n\n## Implementation Details\n\nExample helper method signature:\n\n\n## Quality Checks\n- [ ] All existing tests pass\n- [ ] New tests added for phone formatting\n- [ ] All edge cases covered by tests\n- [ ] Code coverage maintained/improved (target: \u003e95%)\n- [ ] Ruff linter passes\n- [ ] No changes to database schema or stored data\n- [ ] No changes to other API endpoints\n- [ ] Phone numbers dialable from Cisco devices\n- [ ] User experience consistent across directory\n\n## Benefits\n1. **Cisco Compatibility**: Numbers without + work with dialplan\n2. **Consistency**: All users see numbers in same format\n3. **Usability**: Predictable, clean format easier to read\n4. **Maintainability**: Single source of truth for Cisco formatting\n5. **Reliability**: Reduces user confusion from mixed formats","status":"closed","priority":2,"issue_type":"bug","estimated_minutes":90,"created_at":"2026-01-09T08:54:30.630860217Z","created_by":"vscode","updated_at":"2026-01-09T21:19:34.031538117-08:00","closed_at":"2026-01-09T21:19:34.031538117-08:00","close_reason":"Closed","labels":["bug","cisco","phone-numbers"]}
{"id":"google-contacts-cisco-wu9","title":"Code Quality: Missing type hints in several modules reduce type safety","description":"## Problem\nType hints are incomplete across the codebase:\n1. Some functions have no return type hints\n2. Optional types not consistently annotated\n3. Dict/List without generic types (Dict[str, Any])\n4. No type hints in some service methods\n5. MyPy config allows untyped defs (pyproject.toml line 82)\n\n## Examples\n```python\n# Missing specific types\ndef get_sync_status(self):  # Missing -\u003e dict return type\n    sync_state = self.sync_repo.get_latest_sync_state()\n    contact_count = self.contact_repo.count_active()\n    \n# Using generic Any\ndef to_dict(self) -\u003e dict:  # Should be -\u003e Dict[str, Union[int, str]]\n    return {\n        \"total_fetched\": self.total_fetched,\n        ...\n    }\n```\n\n## Current MyPy Config Issues\n```toml\n# pyproject.toml lines 82-83\ndisallow_untyped_defs = false  # Should be true!\ndisallow_incomplete_defs = false  # Should be true!\n```\n\n## Impact\n- **Type Safety**: Runtime type errors not caught\n- **IDE Support**: Reduced autocomplete/hints\n- **Refactoring**: Harder to refactor safely\n- **Documentation**: Type hints serve as docs\n\n## Modules Needing Improvement\n1. `services/sync_service.py` - Many dict returns\n2. `repositories/*.py` - Some methods untyped\n3. `utils/phone_utils.py` - Tuple types incomplete\n4. `api/schemas.py` - Dict responses\n5. `services/google_client.py` - Dict[str, Any] overuse\n\n## Required Fix\n1. Add return type hints to all functions\n2. Replace dict with Dict[str, X] or TypedDict\n3. Replace list with List[X]\n4. Add Optional[] where None possible\n5. Enable strict MyPy settings gradually\n6. Run MyPy in CI and fail on errors\n7. Add type checking pre-commit hook\n\n## Approach\n1. Enable `check_untyped_defs = true` first\n2. Fix revealed issues module by module\n3. Enable `disallow_incomplete_defs = true`\n4. Finally enable `disallow_untyped_defs = true`","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T21:22:02.953420126-08:00","created_by":"rohan","updated_at":"2026-01-09T21:22:02.953420126-08:00","labels":["backend","code-quality","mypy","type-hints"]}
{"id":"google-contacts-cisco-wxy","title":"API Documentation","description":"# Unknown\n\n\n## Overview\n\nCreate comprehensive API documentation using FastAPI's automatic OpenAPI generation, add detailed descriptions, create usage guides, and provide Postman collections for testing and integration.\n\n## Priority\n\n**P1 (High)** - Required for maintainability and external integration\n\n## Dependencies\n\n- All API implementation tasks (1-19)\n\n## Objectives\n\n1. Enhance OpenAPI schema with descriptions\n2. Document all request/response models\n3. Add usage examples to endpoints\n4. Document error responses\n5. Create Postman collection\n6. Write setup and deployment guides\n7. Document Cisco phone configuration\n8. Create troubleshooting guide\n\n## Technical Context\n\n### FastAPI Auto-Documentation\nFastAPI automatically generates:\n- **OpenAPI 3.0** schema\n- **Swagger UI** at `/docs`\n- **ReDoc** at `/redoc`\n- **JSON Schema** for all models\n\n## Implementation Steps\n\n### 1. Enhance API Endpoint Documentation\n\nUpdate `google_contacts_cisco/api/contacts.py` with detailed docs:\n\n```python\n@router.get(\"\", response_model=ContactListResponse)\nasync def list_contacts(\n    limit: int = Query(\n        50,\n        ge=1,\n        le=100,\n        description=\"Maximum number of contacts to return (1-100)\"\n    ),\n    offset: int = Query(\n        0,\n        ge=0,\n        description=\"Number of contacts to skip for pagination\"\n    ),\n    sort: str = Query(\n        \"name\",\n        regex=\"^(name|recent)$\",\n        description=\"Sort order: 'name' for alphabetical, 'recent' for recently updated\"\n    ),\n    group: Optional[str] = Query(\n        None,\n        max_length=1,\n        description=\"Filter by first letter (A-Z) or '#' for numbers/special characters\"\n    ),\n    db: Session = Depends(get_db)\n):\n    \"\"\"\n    List all contacts with pagination, filtering, and sorting.\n    \n    This endpoint returns a paginated list of contacts from the database.\n    Use the `offset` and `limit` parameters to implement pagination in your client.\n    \n    **Filtering:**\n    - Use `group` parameter to filter by first letter of contact name\n    - Example: `?group=A` returns only contacts starting with 'A'\n    - Use `group=#` for contacts starting with numbers or special characters\n    \n    **Sorting:**\n    - `sort=name`: Alphabetical by display name (default)\n    - `sort=recent`: Most recently updated first\n    \n    **Performance:**\n    - Response time: \u003c100ms for typical queries\n    - Maximum 100 contacts per request\n    \n    **Example Usage:**\n    ```\n    GET /api/contacts?limit=20\u0026offset=0\u0026sort=name\u0026group=A\n    ```\n    \n    **Response includes:**\n    - `contacts`: Array of contact objects\n    - `total`: Total number of contacts (across all pages)\n    - `offset`: Current offset\n    - `limit`: Current limit\n    - `has_more`: Boolean indicating if more pages exist\n    \"\"\"\n    # Implementation...\n```\n\n## Verification\n\nAfter completing this task:\n\n1. **Check OpenAPI Docs**:\n   - Visit http://localhost:8000/docs\n   - Verify all endpoints are documented\n   - Test endpoints from Swagger UI\n\n2. **Check ReDoc**:\n   - Visit http://localhost:8000/redoc\n   - Verify clean documentation layout\n\n3. **Test Postman Collection**:\n   - Import `docs/postman/collection.json`\n   - Run all requests\n   - Verify responses\n\n4. **Review Documentation**:\n   - Check all docs/ files are complete\n   - Verify links work\n   - Test code examples\n\n## Estimated Time\n\n3-4 hours","acceptance_criteria":"☐ All endpoints have descriptions\n☐ Request/response schemas documented\n☐ Usage examples provided\n☐ Error codes documented\n☐ Postman collection created\n☐ Setup guide complete\n☐ Cisco phone guide complete\n☐ OAuth guide complete\n☐ Troubleshooting guide complete\n☐ OpenAPI schema validates","notes":"\n**Related Files:**\n\n- See `.ai/planning/tasks/` for complete implementation guide\n\n- Includes code examples, test suites, and verification steps","status":"closed","priority":1,"issue_type":"task","estimated_minutes":180,"created_at":"2026-01-08T03:10:59.578541295Z","created_by":"vscode","updated_at":"2026-01-08T09:23:21.707536196Z","closed_at":"2026-01-08T09:23:21.707536196Z","close_reason":"Closed","labels":["P1","api","documentation"]}
{"id":"google-contacts-cisco-y6m","title":"Security: SQL injection risk in LIKE queries with user input","description":"## Problem\nSearch service (`services/search_service.py`) uses LIKE queries with user input. While basic escaping exists (lines 357-361), the implementation has gaps:\n1. Phone number search conditions don't escape user input (lines 390-400)\n2. Potential for SQL injection through carefully crafted phone/digit patterns\n3. Missing input validation before query construction\n\n## Affected Code\n```python\n# search_service.py lines 390-392\nsuffix_pattern = f\"%{digits_only[-7:]}\"  # No escaping\nconditions.append(PhoneNumber.value.like(suffix_pattern))\n\n# lines 397-398\ndigit_pattern = f\"%{digits}%\"  # No escaping\nconditions.append(PhoneNumber.value.like(digit_pattern))\n```\n\n## Security Impact\n- **SQL Injection Risk**: Though using SQLAlchemy, pattern injection possible\n- **Data Exposure**: Could leak sensitive contact information\n- **DoS Risk**: Malicious patterns could cause performance issues\n\n## Required Fix\n1. Escape all user input in LIKE patterns consistently\n2. Use parameterized queries for all phone search conditions\n3. Add input validation/sanitization before search\n4. Add SQL injection tests with malicious patterns\n5. Review all LIKE queries across codebase\n\n## Testing\nTest with inputs like: `%'; DROP TABLE contacts; --`, `%\\%`, `___`","status":"open","priority":1,"issue_type":"bug","created_at":"2026-01-09T21:18:35.344156381-08:00","created_by":"rohan","updated_at":"2026-01-09T21:18:35.344156381-08:00","labels":["backend","security","sql-injection"]}
{"id":"google-contacts-cisco-zgf","title":"Edge Case: Cisco XML pagination missing for large contact groups","description":"## Problem\nCisco directory XML formatter generates unlimited entries per group:\n1. No pagination in group_directory (xml_formatter.py lines 87-130)\n2. Config has max_entries_per_page=32 (config.py line 45) but not used\n3. Large groups (\u003e100 contacts) could overwhelm Cisco phones\n4. No \"Next Page\" mechanism implemented\n5. Memory issues generating huge XML responses\n\n## Affected Code\n```python\n# xml_formatter.py lines 107-117\nif contacts:\n    # Add menu items for each contact - NO LIMIT!\n    for contact in contacts:\n        item = etree.SubElement(root, \"MenuItem\")\n        # Could be 1000+ contacts in one XML response\n```\n\n## Cisco Phone Limits\n- Most models: 32-64 entries per page\n- Exceeding limit: Phone displays nothing or crashes\n- Slow rendering with \u003e100 entries\n\n## Impact\n- **Phone Unusable**: Large groups don't display\n- **Performance**: Huge XML generation and transmission\n- **Memory**: Server OOM generating large XML\n- **UX**: No way to navigate large contact lists\n\n## Required Fix\n1. Implement pagination using Cisco IP Phone pagination format\n2. Add page parameter to group directory endpoint\n3. Use settings.directory_max_entries_per_page (32)\n4. Add \"Next Page\" and \"Previous Page\" soft keys\n5. Add page count indicator in title (\"Page 1 of 5\")\n6. Test with 500+ contact group\n7. Document pagination in Cisco setup guide\n\n## References\n- Cisco IP Phone Directory Services: Pagination format","status":"open","priority":2,"issue_type":"bug","created_at":"2026-01-09T21:20:01.743421648-08:00","created_by":"rohan","updated_at":"2026-01-09T21:20:01.743421648-08:00","labels":["backend","bug","cisco","edge-case","pagination"]}
{"id":"google-contacts-cisco-zgu","title":"Filter contacts without phone numbers from directory view","description":"## Bug Description\n\nContacts without phone numbers in Google are being synchronized to the local database (which is correct), but they are appearing in the Cisco IP Phone directory view (which is incorrect).\n\n**Expected Behavior**: \n- Contacts should sync from Google regardless of whether they have phone numbers\n- Only contacts WITH phone numbers should appear in the directory view\n- Contacts without phone numbers should be hidden from the directory but remain in the database\n\n**Current Behavior**:\n- All active contacts appear in the directory view, including those without phone numbers\n- When a contact without phone numbers is selected, it shows \"No phone numbers\" message\n\n## Root Cause\n\nThe get_group_directory endpoint in directory_routes.py (line 142) uses contact_repo.get_all_active() which returns ALL active contacts regardless of whether they have phone numbers. These contacts are then displayed in the directory.\n\n## Implementation Plan\n\n### 1. Repository Layer Enhancement\nFile: google_contacts_cisco/repositories/contact_repository.py\n\nAdd a new method to fetch only contacts with phone numbers:\n\n```python\ndef get_all_active_with_phones(self) -\u003e List[Contact]:\n    \"\"\"Get all non-deleted contacts that have at least one phone number.\n    \n    Returns:\n        List of active contacts with phone numbers\n    \"\"\"\n    return (\n        self.db.query(Contact)\n        .join(PhoneNumber)\n        .filter(Contact.deleted == False)  # noqa: E712\n        .distinct()\n        .all()\n    )\n```\n\n### 2. Directory Route Update\nFile: google_contacts_cisco/api/directory_routes.py\n\nUpdate get_group_directory endpoint (around line 142):\n\nBefore:\n```python\n# Get all active contacts\nall_contacts = contact_repo.get_all_active()\n```\n\nAfter:\n```python\n# Get all active contacts with phone numbers\nall_contacts = contact_repo.get_all_active_with_phones()\n```\n\n### 3. Test Updates\n\n#### Unit Tests - tests/unit/api/test_directory_routes.py\n\nAdd a new test class:\n\n```python\nclass TestContactsWithoutPhoneNumbersFiltered:\n    \"\"\"Test that contacts without phone numbers are filtered from directory.\"\"\"\n    \n    def test_group_directory_excludes_contacts_without_phones(self, client, db_session):\n        \"\"\"Test contacts without phone numbers don't appear in group directory.\"\"\"\n        # Create contact WITH phone\n        contact_with_phone = Contact(\n            id=uuid.uuid4(),\n            resource_name=\"people/withphone\",\n            display_name=\"Alice Test\",\n            deleted=False,\n        )\n        db_session.add(contact_with_phone)\n        db_session.flush()\n        \n        phone = PhoneNumber(\n            id=uuid.uuid4(),\n            contact_id=contact_with_phone.id,\n            type=\"mobile\",\n            value=\"5551234567\",\n            display_value=\"(555) 123-4567\",\n            primary=True,\n        )\n        db_session.add(phone)\n        \n        # Create contact WITHOUT phone\n        contact_no_phone = Contact(\n            id=uuid.uuid4(),\n            resource_name=\"people/nophone\",\n            display_name=\"Bob NoPhone\",\n            deleted=False,\n        )\n        db_session.add(contact_no_phone)\n        db_session.commit()\n        \n        # Request group directory\n        response = client.get(\"/directory/groups/2ABC\")\n        root = etree.fromstring(response.content)\n        \n        menu_items = root.findall(\"MenuItem\")\n        names = [item.find(\"Name\").text for item in menu_items]\n        \n        # Only contact with phone should appear\n        assert \"Alice Test\" in names\n        assert \"Bob NoPhone\" not in names\n    \n    def test_main_directory_still_accessible(self, client, db_session):\n        \"\"\"Test main directory still works when contacts have no phones.\"\"\"\n        # Create contact without phone\n        contact = Contact(\n            id=uuid.uuid4(),\n            resource_name=\"people/nophone\",\n            display_name=\"Contact NoPhone\",\n            deleted=False,\n        )\n        db_session.add(contact)\n        db_session.commit()\n        \n        # Main directory should still load\n        response = client.get(\"/directory\")\n        assert response.status_code == 200\n        \n        root = etree.fromstring(response.content)\n        assert root.tag == \"CiscoIPPhoneMenu\"\n    \n    def test_empty_group_when_no_contacts_with_phones(self, client, db_session):\n        \"\"\"Test group shows empty message when no contacts have phones.\"\"\"\n        # Create contacts in 5JKL group but without phones\n        contact = Contact(\n            id=uuid.uuid4(),\n            resource_name=\"people/john\",\n            display_name=\"John NoPhone\",\n            deleted=False,\n        )\n        db_session.add(contact)\n        db_session.commit()\n        \n        response = client.get(\"/directory/groups/5JKL\")\n        root = etree.fromstring(response.content)\n        \n        menu_items = root.findall(\"MenuItem\")\n        # Should show \"(No contacts)\" message\n        assert len(menu_items) == 1\n        assert \"No contacts\" in menu_items[0].find(\"Name\").text\n```\n\n#### Repository Tests - tests/unit/repositories/test_contact_repository.py\n\nAdd test for new repository method:\n\n```python\ndef test_get_all_active_with_phones(self, repo, db_session):\n    \"\"\"Test get_all_active_with_phones returns only contacts with phone numbers.\"\"\"\n    # Create contact with phone\n    contact1 = Contact(\n        resource_name=\"people/withphone\",\n        display_name=\"Has Phone\",\n        deleted=False,\n    )\n    db_session.add(contact1)\n    db_session.flush()\n    \n    phone = PhoneNumber(\n        contact_id=contact1.id,\n        value=\"+15551234567\",\n        display_value=\"+1-555-123-4567\",\n        type=\"mobile\",\n        primary=True,\n    )\n    db_session.add(phone)\n    \n    # Create contact without phone\n    contact2 = Contact(\n        resource_name=\"people/nophone\",\n        display_name=\"No Phone\",\n        deleted=False,\n    )\n    db_session.add(contact2)\n    \n    # Create deleted contact with phone\n    contact3 = Contact(\n        resource_name=\"people/deleted\",\n        display_name=\"Deleted With Phone\",\n        deleted=True,\n    )\n    db_session.add(contact3)\n    db_session.flush()\n    \n    phone2 = PhoneNumber(\n        contact_id=contact3.id,\n        value=\"+15559876543\",\n        display_value=\"+1-555-987-6543\",\n        type=\"work\",\n        primary=True,\n    )\n    db_session.add(phone2)\n    db_session.commit()\n    \n    # Get contacts with phones\n    results = repo.get_all_active_with_phones()\n    \n    # Should only return contact1\n    assert len(results) == 1\n    assert results[0].display_name == \"Has Phone\"\n\ndef test_get_all_active_with_phones_empty(self, repo, db_session):\n    \"\"\"Test get_all_active_with_phones with no qualifying contacts.\"\"\"\n    # Create contact without phone\n    contact = Contact(\n        resource_name=\"people/nophone\",\n        display_name=\"No Phone\",\n        deleted=False,\n    )\n    db_session.add(contact)\n    db_session.commit()\n    \n    results = repo.get_all_active_with_phones()\n    assert len(results) == 0\n```\n\n## Acceptance Criteria\n\n- [ ] New repository method get_all_active_with_phones() implemented\n- [ ] get_group_directory endpoint updated to use new method\n- [ ] Contacts without phone numbers are NOT displayed in any directory group view\n- [ ] Contacts with phone numbers continue to display normally\n- [ ] Empty groups show \"(No contacts)\" message appropriately\n- [ ] Main directory menu continues to work regardless of phone number presence\n- [ ] All existing directory tests pass\n- [ ] New tests added to verify filtering behavior\n- [ ] Repository tests added for new method\n- [ ] Code coverage maintained or improved\n\n## Testing Checklist\n\n### Manual Testing\n- [ ] Sync contacts from Google (including contacts without phone numbers)\n- [ ] Verify contacts without phones are in database (check via API or SQL)\n- [ ] Access directory via Cisco IP Phone (or test client)\n- [ ] Verify contacts without phones do NOT appear in group listings\n- [ ] Verify contacts with phones DO appear correctly\n- [ ] Verify empty groups display appropriate message\n\n### Automated Testing\n- [ ] Run full test suite: pytest tests/\n- [ ] Run directory-specific tests: pytest tests/unit/api/test_directory_routes.py -v\n- [ ] Run repository tests: pytest tests/unit/repositories/test_contact_repository.py -v\n- [ ] Verify coverage: ./scripts/coverage-report.sh\n- [ ] All tests pass with new filtering logic\n\n## Implementation Notes\n\n### Files to Modify\n1. google_contacts_cisco/repositories/contact_repository.py - Add new method\n2. google_contacts_cisco/api/directory_routes.py - Update endpoint (line ~142)\n3. tests/unit/api/test_directory_routes.py - Add filtering tests\n4. tests/unit/repositories/test_contact_repository.py - Add repository tests\n\n### Files to Review (No Changes Expected)\n- google_contacts_cisco/services/xml_formatter.py - Already handles empty phone lists correctly\n- google_contacts_cisco/services/sync_service.py - Should continue syncing all contacts\n- Search functionality - Should remain unaffected (can search contacts without phones)\n\n### Edge Cases to Consider\n- Contact has phone numbers, then they are all removed in a sync\n- Contact has zero-length or whitespace-only phone values\n- Deleted contacts with phone numbers (should not appear)\n- Multiple contacts in same group with/without phones\n\n### Performance Considerations\n- New query uses JOIN which is indexed\n- Should have minimal performance impact\n- Consider adding integration test for performance with large datasets\n\n## Related Documentation\n- Cisco IP Phone XML Directory API: docs/cisco-directory-api.md\n- Sync process: .ai/planning/tasks/07-full-sync-implementation.md","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-09T07:31:57.521367548Z","created_by":"vscode","updated_at":"2026-01-09T20:46:16.858971871-08:00","closed_at":"2026-01-09T20:46:16.858971871-08:00","close_reason":"Closed"}
